<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualizador de Taxonomía</title>
  <style>
    /* Actualización de colores y estilos base */
    :root {
      --primary: #008a9b;
      --primary-dark: #006d7a;
      --secondary: #64748b;
      --success: #00968f;
      --danger: #dc5b5b;
      --warning: #b88746;
      --background: #f8fafc;
      --surface: #ffffff;
      --text: #2c3e50;
      --text-light: #64748b;
      --border: #e2e8f0;
      --shadow: rgba(0, 138, 155, 0.1);
    }
    
    body {
      background-color: var(--background);
      color: var(--text);
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    
    /* Ajustes generales de layout y espaciado */
    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    
    .top-bar {
      padding: 10px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      z-index: 1001;
    }
    
    .main-content {
      display: flex;
      position: relative;
      overflow: hidden;
      flex: 1;
    }
    
    /* Ajustes para el panel YAML-JSON */
    .YAML-JSON {
      width: 0;
      overflow: hidden;
      transition: width 0.3s ease;
      flex-shrink: 0;
      position: fixed;
      top: 150px; /* Aumentar para dejar espacio al logo */
      left: 0;
      bottom: 40px;
      background-color: var(--surface);
      border-right: 1px solid var(--border);
      z-index: 10;
      padding: 0;
    }
    
    .YAML-JSON h2 {
      margin: 10px;
      padding: 0;
      font-size: 1.2em;
    }
    
    /* Textarea de datos */
    #data-display {
      width: 100%;
      height: calc(100% - 80px); /* Ajustar altura considerando el header y el botón */
      border: none;
      padding: 10px;
      margin: 0;
      font-family: monospace;
      font-size: 14px;
      background-color: var(--surface);
      color: var(--text);
      resize: none;
      box-sizing: border-box;
    }
    
    /* Contenedor de nodos */
    .nodes-container {
      padding-left: 20px; /* Añadir un pequeño padding a la izquierda */
      flex-grow: 1;
      overflow: auto;
      transition: margin-left 0.3s ease;
    }
    
    /* Panel de información inferior */
    .info-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: var(--surface);
      color: var(--text);
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      height: 40px;
      box-sizing: border-box;
      z-index: 30;
      font-size: 14px;
      transition: height 0.3s ease, left 0.3s ease, width 0.3s ease;
      overflow: hidden;
      border-top: 1px solid var(--border);
      box-shadow: 0 -1px 3px var(--shadow);
    }
    
    .info-panel.expanded {
      height: 200px; /* Reducido de 250px para mejor uso del espacio */
      overflow-y: auto;
    }
    
    .info-panel-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      padding-bottom: 15px;
    }
    
    /* Mejora para el contenedor de metadatos */
    .metadata-cards-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
      overflow-y: auto;
      max-height: 120px; /* Reducido para mejor equilibrio */
      padding-bottom: 10px;
    }
    
    /* Asegurar que botones tengan buen espaciado */
    button {
      margin: 5px;
      padding: 8px 15px;
    }
    
    #update-visualization {
      margin: 10px;
      width: calc(100% - 20px); /* Ajustar ancho considerando los márgenes */
    }
    
    /* Prevenir superposición de elementos */
    .pyramid-container {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    /* Estilos para el logo ASCII con scroll */
    .ascii-logo {
      position: fixed; /* Cambiar de relative a fixed */
      top: 20px;
      left: 20px;
      z-index: 1000; /* Añadir z-index */
      background-color: var(--surface); /* Añadir fondo */
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow);
      padding: 10px;
      max-height: 100px;
      overflow-y: auto;
      overflow-x: hidden;
      transition: left 0.3s ease; /* Añadir transición suave */
    }
    
    #ascii-container {
      margin: 0;
      padding-top: 5px;
      font-family: monospace;
      font-size: 4px;
      line-height: 0.8;
      white-space: pre;
      letter-spacing: 0;
      cursor: pointer;
    }
    
    .ascii-char {
      font-size: 4px;  /* Asegurar que los caracteres individuales también sean pequeños */
      line-height: 0.8;
    }
    
    /* Estilo para el cursor personalizado */
    #custom-cursor {
      position: absolute;
      font-family: monospace;
      font-size: 10px;
      line-height: 1;
      white-space: pre;
      color: rgba(255, 255, 255, 0.8);
      text-shadow: 0 0 5px #65b8c4, 0 0 10px #65b8c4;
      pointer-events: none; /* Para que no interfiera con los eventos del mouse */
      display: none; /* Inicialmente oculto */
      transform: translate(-50%, -50%); /* Centrar en el cursor */
      z-index: 10;
    }
    
    /* Ajustar el layout de la barra superior */
    .top-bar {
      display: flex;
      justify-content: flex-end; /* Cambiar de space-between a flex-end */
      align-items: flex-start;
      padding: 20px 20px;
      min-height: 120px;
      margin-left: 200px; /* Añadir margen para el logo */
    }
    
    .top-bar h1 {
      margin: 0;
      font-size: 1.5rem;
    }
    
    .controls {
      display: flex;
      gap: 10px;
      align-self: flex-start; /* Alinear controles en la parte superior */
      padding-top: 10px; /* Añadir algo de espacio superior */
    }
    
    .controls button, .controls select,
    #update-visualization {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    
    .controls button:hover,
    .controls select:hover,
    #update-visualization:hover {
      background-color: var(--primary-dark);
      transform: translateY(-1px);
    }
    
    /* Ajustar los estilos del contenedor principal y el contenedor de nodos */
    .main-content {
      display: flex;
      flex-direction: row;
      align-items: stretch;
      overflow: hidden;
      height: 100vh; /* Asegurar que ocupe toda la altura de la ventana */
      margin-top: 20px; /* Añadir espacio después de la barra superior */
    }
    
    .YAML-JSON.visible {
      width: 40%;
      min-width: 300px;
      max-width: 500px;
    }
    
    .nodes-container {
      flex-grow: 1;
      overflow-y: auto; /* Permitir scroll vertical */
      overflow-x: auto; /* Mantener scroll horizontal */
      height: 100%; /* Ocupar toda la altura disponible */
      padding: 20px; /* Añadir algo de padding para mejor visualización */
      position: relative;
    }
    
    .toggle-panel {
      position: fixed;
      top: 50%;
      left: 10px;
      width: 40px;
      height: 40px;
      background-color: var(--surface);
      color: var(--text);
      border: none;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px var(--shadow);
    }
    
    .toggle-props-panel {
      position: fixed;
      top: 50%;
      right: 10px;
      width: 40px;
      height: 40px;
      background-color: var(--surface);
      color: var(--text);
      border: none;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px var(--shadow);
    }
    
    .toggle-panel:hover, .toggle-props-panel:hover {
      background-color: var(--primary);
      color: white;
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 4px 12px var(--shadow);
      transition: all 0.2s ease;
    }
    
    /* Estilos para la visualización de nodos */
    .pyramid-container {
      min-height: min-content; /* Permitir que crezca según el contenido */
      width: 100%;
      padding-bottom: 50px; /* Espacio extra al final para mejor scroll */
      box-sizing: border-box;
      max-width: 100%; /* Asegurar que use todo el ancho disponible */
      align-items: flex-start; /* Asegurar que los elementos internos se alineen a la izquierda */
      margin-left: 0; /* Eliminar cualquier margen izquierdo */
    }
    
    .pyramid-level {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 30px; /* Aumentar espacio entre niveles */
      width: 100%;
    }
    
    /* Contenedor para un nodo y sus hijos */
    .node-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }
    
    /* Contenedor para los hijos de un nodo */
    .children-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
      padding-left: 50px; /* Aumentar el espacio a la izquierda para que los hijos aparezcan más a la derecha */
      margin-top: 15px;
      position: relative;
      opacity: 0;
      max-height: 0;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .children-container.visible {
      opacity: 1;
      max-height: 1000px; /* Valor alto para permitir animación */
      margin-top: 0;
    }
    
    /* Estilos para nodos colapsados/expandidos */
    .pyramid-node.collapsed::after {
      content: "▶";
      position: absolute;
      top: 50%;
      right: 5px;
      transform: translateY(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    .pyramid-node.expanded::after {
      content: "▼";
      position: absolute;
      top: 50%;
      right: 5px;
      transform: translateY(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    .pyramid-node {
      padding: 12px 15px; /* Reducir el padding horizontal */
      min-width: 100px; /* Reducir el ancho mínimo de 120px a 100px */
      max-width: 150px;
      border-radius: 8px;
      text-align: center;
      cursor: grab; /* Cambiar el cursor para indicar que se puede arrastrar */
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px var(--shadow);
      word-wrap: break-word;
      flex-shrink: 0;
      position: relative;
      /* Eliminar tabindex para evitar que los nodos reciban foco con Tab */
      outline: none;
      background: var(--surface);
      border: 1px solid var(--border);
      
      /* Añadir estas propiedades para centrar el texto vertical y horizontalmente */
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .pyramid-node.dragging {
      opacity: 0.5;
      cursor: grabbing;
      transform: scale(1.05);
      z-index: 1000;
    }
    
    /* Estilo para indicar dónde se puede soltar */
    .pyramid-node.drop-target {
      border: 2px dashed var(--primary);
      background-color: rgba(0, 138, 155, 0.1);
    }
    
    /* Nodos minimizados (subnodos cuando su padre no está activo) */
    .pyramid-node.minimized {
      transform: scale(0.8);
      opacity: 0.7;
      filter: saturate(0.7);
    }
    
    /* Estilos para los diferentes tipos de nodos */
    .pyramid-node.main {
      background-color: var(--primary);
      color: white;
      -webkit-tap-highlight-color: transparent;
    }
    .pyramid-node.main::selection {
      background-color: #ff7564; /* Complementario de --primary (#008a9b) */
      color: black;
    }
    
    .pyramid-node.category {
      background-color: #009b8a;
      color: white;
      -webkit-tap-highlight-color: transparent;
    }
    .pyramid-node.category::selection {
      background-color: #ff6475; /* Complementario de #009b8a */
      color: black;
    }
    
    .pyramid-node.subcategory {
      background-color: #3a7b8c;
      color: white;
      -webkit-tap-highlight-color: transparent;
    }
    .pyramid-node.subcategory::selection {
      background-color: #c58473; /* Complementario de #3a7b8c */
      color: black;
    }
    
    .pyramid-node.example {
      background-color: #5f8a93;
      color: white;
      -webkit-tap-highlight-color: transparent;
    }
    .pyramid-node.example::selection {
      background-color: #93756c; /* Complementario de #5f8a93 */
      color: black;
    }
    
    /* Nodo actualmente seleccionado/enfocado */
    .pyramid-node.focused {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0, 138, 155, 0.2);
      z-index: 5;
      background-color: var(--primary);
      border: 2px solid var(--primary);
      color: white;
    }
    
    /* Efecto de brillo para el nodo enfocado */
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(0, 138, 155, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(0, 138, 155, 0); }
      100% { box-shadow: 0 0 0 0 rgba(0, 138, 155, 0); }
    }
    
    .pyramid-node.focused {
      animation: pulse 2s infinite;
    }
    
    /* Hijos directos del nodo activo */
    .pyramid-node.active-child {
      transform: scale(1);
      opacity: 1;
      filter: saturate(1);
      box-shadow: 0 3px 7px rgba(0,0,0,0.25);
    }
    
    /* Indicador visual para nodos con hijos */
    .pyramid-node.has-children::after {
      content: "▼";
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    textarea {
      width: 100%;
      height: 70%;
      font-family: monospace;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
      resize: none;
      white-space: pre;
      overflow-x: auto;
      overflow-wrap: normal;
    }
    
    #update-visualization {
      margin-top: 10px;
      padding: 8px 15px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    /* Estilos para pantallas pequeñas */
    @media (max-width: 768px) {
      .pyramid-node {
        min-width: 80px;
        padding: 10px 15px;
        font-size: 14px;
      }
      
      .pyramid-level {
        gap: 15px;
      }
    }
    
    /* Indicadores de navegación */
    .navigation-indicator {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0.7;
    }
    
    .indicator-left {
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .indicator-right {
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .indicator-up {
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .indicator-down {
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    /* Estilos para el indicador de más nodos */
    .more-nodes-indicator {
      background-color: #607D8B;
      color: white;
      padding: 8px 15px;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 10px;
      display: inline-block;
      font-size: 0.9em;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .more-nodes-indicator:hover {
      background-color: #455A64;
      transform: scale(1.05);
    }
    
    /* Contenedor para los nodos ocultos */
    .hidden-nodes-container {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(0,0,0,0.05);
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .hidden-nodes-container.visible {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .pyramid-node.hidden {
      display: none;
    }
    
    .children-navigation {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      gap: 5px;
    }
    
    .nav-prev, .nav-next {
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .nav-prev:disabled, .nav-next:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .nav-indicator {
      font-size: 12px;
      color: #666;
    }
    
    /* Estilos para el panel de información con tarjetas de metadatos */
    .info-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: var(--surface);
      color: var(--text);
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      height: 40px;
      box-sizing: border-box;
      z-index: 30;
      font-size: 14px;
      transition: height 0.3s ease, left 0.3s ease, width 0.3s ease;
      overflow: hidden;
      border-top: 1px solid var(--border);
      box-shadow: 0 -1px 3px var(--shadow);
    }
    
    .info-panel.expanded {
      height: 250px; /* Aumentado para dar más espacio */
      overflow-y: auto; /* Permitir scroll cuando está expandido */
      align-items: flex-start; /* Asegurar que el contenido comience desde arriba */
    }
    
    .info-panel-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      padding-bottom: 15px; /* Añadir espacio en la parte inferior */
    }
    
    .info-basic {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap; /* Permitir que los elementos se envuelvan en pantallas pequeñas */
      margin-bottom: 5px; /* Espacio antes de las tarjetas */
    }
    
    .info-label {
      font-weight: bold;
      color: #4CAF50;
    }
    
    /* Estilos para las tarjetas de metadatos */
    .metadata-cards-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
      overflow-y: visible; /* Cambiar a visible para evitar cortes */
      max-height: 160px; /* Aumentar altura máxima */
      padding-bottom: 10px; /* Espacio adicional en la parte inferior */
    }
    
    .metadata-card {
      background-color: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      min-width: 150px;
      box-shadow: 0 2px 4px var(--shadow);
      display: flex;
      flex-direction: column;
    }
    
    .metadata-card-title {
      font-weight: bold;
      color: var(--primary);
      margin-bottom: 5px;
      font-size: 12px;
    }
    
    .metadata-card-content {
      font-size: 13px;
      color: #fff;
    }
    
    .add-metadata-card {
      background-color: transparent;
      border: 2px dashed var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      min-width: 150px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-light);
    }
    
    .add-metadata-card:hover {
      background-color: #666;
      color: white;
    }
    
    .metadata-editor {
      width: 100%;
      display: none;
    }
    
    .metadata-editor.visible {
      display: block;
    }
    
    .metadata-form {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .metadata-input-group {
      display: flex;
      gap: 10px;
    }
    
    .metadata-input {
      flex: 1;
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    
    .metadata-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    
    .edit-button, .save-button, .cancel-button {
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 5px 10px;
      cursor: pointer;
    }
    
    .cancel-button {
      background-color: #f44336;
    }
    
    .edit-button:hover, .save-button:hover {
      background-color: #45a049;
    }
    
    .cancel-button:hover {
      background-color: #d32f2f;
    }
    
    .pyramid-node.pinned {
      border: 3px solid #FFD700 !important; /* Borde dorado para el nodo fijado */
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.7) !important; /* Sombra dorada */
      z-index: 10 !important; /* Asegurar que esté por encima de otros nodos */
    }
    
    .pyramid-node.pinned::before {
      content: "📌";
      position: absolute;
      top: -10px;
      right: -10px;
      font-size: 12px;
      background-color: #FFD700;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    
    .pyramid-node.secondary-pinned::before {
      content: "📌";
      position: absolute;
      top: -10px;
      right: -10px;
      font-size: 12px;
      background-color: #1E90FF;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    
    /* Estilos para el desplazamiento del contenedor de nodos */
    .nodes-container {
      transition: margin-left 0.3s ease;
    }
    
    .nodes-container.shifted {
      margin-left: 0; /* El panel YAML-JSON tiene su propio espacio */
    }
    
    /* Ajustar el diseño para evitar superposiciones */
    .main-content {
      display: flex;
      flex-direction: row;
      align-items: stretch;
      overflow: hidden;
    }
    
    .YAML-JSON {
      width: 0;
      overflow: hidden;
      transition: width 0.3s ease;
      flex-shrink: 0;
    }
    
    .YAML-JSON.visible {
      width: 40%; /* Ancho del panel cuando está visible */
      min-width: 300px;
      max-width: 500px;
    }
    
    .nodes-container {
      flex-grow: 1;
      overflow: auto;
      transition: margin-left 0.3s ease;
    }
    
    /* Asegurar que el botón de alternar siempre esté visible */
    .toggle-panel {
      position: absolute;
      left: 10px;
      top: 10px;
      z-index: 1000;
    }
    
    /* Estilos para el panel de propiedades */
    .props-panel {
      width: 0;
      overflow: hidden;
      transition: width 0.3s ease;
      flex-shrink: 0;
      position: fixed;
      top: 120px; /* Alinear con el panel YAML */
      right: 0;
      bottom: 40px;
      background-color: var(--surface);
      z-index: 100;
      box-shadow: -2px 0 10px var(--shadow);
      border-left: 1px solid var(--border);
      overflow-y: auto;
    }
    
    .props-panel.visible {
      width: 40%;
      min-width: 300px;
      max-width: 500px;
      padding: 20px;
    }
    
    .toggle-props-panel {
      position: fixed;
      right: 10px;
      top: 10px;
      z-index: 1001;
      background-color: var(--surface);
      color: var(--text);
      border: none;
      border-radius: 4px;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      box-shadow: 0 2px 5px var(--shadow);
    }
    
    .toggle-props-panel:hover {
      background-color: var(--primary);
      color: white;
    }
    
    /* Ajustar el contenedor principal cuando el panel está visible */
    .main-content.props-panel-visible .nodes-container {
      margin-right: 40%;
      width: 60%;
    }
    
    /* Cuando ambos paneles están visibles */
    .main-content.panel-visible.props-panel-visible .nodes-container {
      margin-left: 40%;
      margin-right: 40%;
      width: 20%;
    }
    
    /* Estilos para la visualización del árbol de propiedades */
    #props-tree {
      height: 100%;
      overflow-y: auto;
      padding-bottom: 20px; /* Espacio extra al final */
    }
    
    .prop-item {
      margin-bottom: 8px;
      padding: 8px;
      border-radius: 6px;
      background-color: var(--surface);
      border: 1px solid var(--border);
      box-shadow: 0 1px 3px var(--shadow);
    }
    
    .prop-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      font-weight: bold;
    }
    
    .prop-children {
      margin-left: 20px;
      padding-left: 10px;
      border-left: 2px solid #ddd;
      margin-top: 8px;
      display: none;
    }
    
    .prop-children.visible {
      display: block;
    }
    
    .prop-toggle {
      margin-right: 5px;
      display: inline-block;
      width: 12px;
      height: 12px;
      text-align: center;
      line-height: 12px;
    }
    
    .prop-id {
      color: #666;
      font-size: 0.8em;
      margin-left: 10px;
    }
    
    .prop-value {
      color: #28a745;
      font-style: italic;
    }
    
    @media (max-width: 1200px) {
      .props-panel.visible {
        width: 350px;
        min-width: 300px;
      }
      
      .main-content.props-panel-visible .nodes-container {
        margin-right: 350px;
        width: calc(100% - 350px);
      }
      
      .main-content.panel-visible.props-panel-visible .nodes-container {
        margin-left: 350px;
        margin-right: 350px;
        width: calc(100% - 700px);
      }
    }
    
    .metadata-card.focused-card {
      transform: scale(1.05);
      box-shadow: 0 0 0 2px var(--primary), 0 4px 8px var(--shadow) !important;
      transition: all 0.2s ease;
    }
    
    /* Añadir navegación con teclado entre tarjetas */
    .metadata-card:focus {
      outline: none;
      box-shadow: 0 0 0 2px var(--primary), 0 4px 8px var(--shadow);
    }
    
    /* Ajustar el panel de información cuando el panel YAML está visible */
    .main-content.panel-visible + .info-panel {
      left: 40%; /* Debe coincidir con el ancho del panel YAML */
      width: 60%; /* El resto del espacio disponible */
    }
    
    /* Ajustar para pantallas más pequeñas */
    @media (max-width: 1200px) {
      .main-content.panel-visible + .info-panel {
        left: 350px;
        width: calc(100% - 350px);
      }
    }
    
    /* Ajustar cuando ambos paneles laterales están visibles */
    .main-content.panel-visible.props-panel-visible + .info-panel {
      left: 40%;
      width: 20%;
    }
    
    @media (max-width: 1200px) {
      .main-content.panel-visible.props-panel-visible + .info-panel {
        left: 350px;
        width: calc(100% - 700px);
      }
    }
    
    .prop-item-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      cursor: grab;
      user-select: none;
    }
    
    .prop-item-header.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }
    
    .prop-toggle {
      cursor: pointer;
      padding: 2px;
    }
    
    .prop-label {
      flex: 1;
    }
    
    .prop-id {
      color: #666;
      font-size: 0.9em;
    }
    
    /* Añadir estilos CSS para los controles de navegación de nivel */
    .level-navigation {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      gap: 10px;
    }
    
    .level-nav-prev, .level-nav-next {
      background-color: var(--primary);
      color: white;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    
    .level-nav-prev:hover, .level-nav-next:hover {
      background-color: var(--primary-dark);
      transform: scale(1.1);
    }
    
    .level-nav-prev:disabled, .level-nav-next:disabled {
      background-color: var(--secondary);
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
    }
    
    .level-nav-indicator {
      font-size: 14px;
      color: var(--text);
      min-width: 100px;
      text-align: center;
    }
    
    /* Asegurar que los niveles tengan espacio para los controles */
    .pyramid-level {
      position: relative;
      padding-bottom: 40px;
    }
    
    /* Función para ajustar dinámicamente la cantidad de nodos visibles */
    function adjustVisibleNodesCount() {
      const pyramidLevels = document.querySelectorAll('.pyramid-level');
      
      pyramidLevels.forEach(level => {
        const levelWidth = level.clientWidth;
        const nodeGroups = level.querySelectorAll('.node-group');
        
        if (nodeGroups.length === 0) return;
        
        // Calcular el ancho promedio de un nodo
        const sampleNode = nodeGroups[0].querySelector('.pyramid-node');
        if (!sampleNode) return;
        
        // Usar un margen más razonable entre nodos
        const nodeWidth = sampleNode.offsetWidth + 20;
        
        // Reducir el margen de seguridad para que se active la paginación cuando sea necesario
        const safetyMargin = 10;
        
        // Calcular cuántos nodos caben en el nivel
        const maxNodesInView = Math.floor((levelWidth - safetyMargin) / nodeWidth);
        
        // Asegurar que maxNodesInView sea al menos 1 menos que el total para mostrar la paginación
        // cuando hay muchos nodos, incluso si técnicamente podrían caber
        const adjustedMaxNodes = Math.min(maxNodesInView, nodeGroups.length > 5 ? nodeGroups.length - 1 : nodeGroups.length);
        
        // Si no caben todos los nodos o tenemos más de 5 nodos, mostrar controles de navegación
        if (adjustedMaxNodes < nodeGroups.length || nodeGroups.length > 5) {
          // Ocultar nodos que no caben
          nodeGroups.forEach((node, index) => {
            if (index < adjustedMaxNodes) {
              node.style.display = 'block';
            } else {
              node.style.display = 'none';
            }
          });
          
          // Eliminar los controles de navegación anteriores si existen
          const oldNavControls = level.querySelector('.level-navigation');
          if (oldNavControls) {
            oldNavControls.remove();
          }
          
          // Crear nuevos controles de navegación y colocarlos debajo de los nodos
          const navControls = document.createElement('div');
          navControls.className = 'level-navigation';
          
          // Asegurar que el texto del indicador sea completo
          const totalNodes = nodeGroups.length;
          navControls.innerHTML = `
            <button class="level-nav-prev" disabled>◀</button>
            <span class="level-nav-indicator">${1}-${adjustedMaxNodes} de ${totalNodes}</span>
            <button class="level-nav-next">▶</button>
          `;
          
          // Insertar los controles después del último nodo visible
          level.appendChild(navControls);
          
          // Configurar eventos para los botones de navegación
          setupLevelNavigation(level, navControls, nodeGroups, adjustedMaxNodes);
        } else {
          // Si caben todos los nodos, mostrarlos todos y quitar controles de navegación
          nodeGroups.forEach(node => {
            node.style.display = 'block';
          });
          
          const navControls = level.querySelector('.level-navigation');
          if (navControls) {
            navControls.remove();
          }
        }
      });
    }
    
    /* Actualizar los estilos CSS para los controles de navegación */
    const levelNavStyles = `
      .level-navigation {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 15px;
        margin-bottom: 10px;
        gap: 10px;
        width: 100%;
        padding: 0 5px;
        box-sizing: border-box;
      }
      
      .level-nav-prev, .level-nav-next {
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }
      
      .level-nav-prev:hover, .level-nav-next:hover {
        background-color: var(--primary-dark);
        transform: scale(1.1);
      }
      
      .level-nav-prev:disabled, .level-nav-next:disabled {
        background-color: var(--secondary);
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
      }
      
      .level-nav-indicator {
        font-size: 14px;
        color: var(--text);
        min-width: 120px;
        text-align: center;
        white-space: nowrap;
        overflow: visible;
      }
      
      /* Ajustar el espaciado de los niveles para los controles */
      .pyramid-level {
        position: relative;
        padding-bottom: 10px;
        margin-bottom: 20px;
        width: 100%;
        overflow: visible;
      }
    `;
    
    /* Asegurar que los estilos se apliquen */
    function applyLevelNavigationStyles() {
      let styleElement = document.getElementById('level-nav-styles');
      if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = 'level-nav-styles';
        styleElement.textContent = levelNavStyles;
        document.head.appendChild(styleElement);
      }
    }
    
    /* Llamar a esta función al inicio */
    document.addEventListener('DOMContentLoaded', function() {
      applyLevelNavigationStyles();
    });
    
    /* Estilo para el cursor de texto */
    #text-cursor {
      position: absolute;
      width: 2px;
      height: 16px;
      background-color: rgba(255, 255, 255, 0.8);
      pointer-events: none; /* Para que no interfiera con los eventos del mouse */
      box-shadow: 0 0 8px #fff, 0 0 12px #65b8c4;
      display: none; /* Inicialmente oculto */
    }

    /* Estilos adicionales para el logo ASCII */
    .ascii-logo pre {
      margin: 0;
      font-family: monospace;
      font-size: 8px;  /* Cambiado de 10px a 8px */
      color: #008a9b;
      line-height: 0.8;  /* Ajustado para mejor espaciado vertical */
      white-space: pre;
      letter-spacing: 0;
      cursor: pointer;
    }

    .ascii-logo pre:hover {
      background-image: linear-gradient(to right, 
        #008a9b, #3a7b8c, #5f8a93, #009b8a, #008a9b, 
        #3a7b8c, #5f8a93, #009b8a);
      background-size: 800% 100%;
      color: transparent;
      -webkit-background-clip: text;
      background-clip: text;
      animation: rainbow 3s linear infinite;
    }

    /* Nuevos estilos para mejorar la visibilidad del ASCII art */
    .ascii-highlight {
      color: #005a6b !important; /* Color más oscuro para los caracteres # */
      font-weight: bold;
      text-shadow: 0 0 1px rgba(0,0,0,0.2); /* Sombra sutil para mejorar legibilidad */
    }

    #ascii-container {
      background-color: rgba(240, 250, 255, 0.05); /* Fondo muy sutil */
      padding: 10px;
      border-radius: 5px;
    }

    #custom-cursor {
      color: rgba(0, 138, 155, 0.8); /* Cursor semi-transparente */
    }

    @keyframes rainbow { 
      0% { background-position: 0% 50%; } 
      100% { background-position: 100% 50%; }
    }

    /* Mantener los estilos existentes del hover */
    #ascii-container:hover {
      background-image: linear-gradient(to right, 
        #008a9b, #3a7b8c, #5f8a93, #009b8a, #008a9b, 
        #3a7b8c, #5f8a93, #009b8a);
      background-size: 800% 100%;
      color: transparent;
      -webkit-background-clip: text;
      background-clip: text;
      animation: rainbow 3s linear infinite;
    }

    /* Estilizar la barra de scroll para mejor apariencia */
    .ascii-logo::-webkit-scrollbar {
      width: 6px;
    }

    .ascii-logo::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 3px;
    }

    .ascii-logo::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 3px;
    }

    /* Ajustar la posición del logo cuando el panel YAML está visible */
    .main-content.panel-visible .ascii-logo {
      left: 20px; /* Mantener la posición original */
    }

    /* Mantener la posición original cuando el panel está cerrado */
    .ascii-logo {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1000;
      background-color: var(--surface);
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow);
      padding: 10px;
      max-height: 100px;
      overflow-y: auto;
      overflow-x: hidden;
      transition: left 0.3s ease; /* Añadir transición suave */
    }

    /* Ajustar para pantallas más pequeñas */
    @media (max-width: 1200px) {
      .main-content.panel-visible .ascii-logo {
        left: calc(350px + 30px); /* 350px es el ancho mínimo del panel YAML + margen */
      }
    }

    .pyramid-node.dragging {
      opacity: 0.5;
      cursor: move;
    }

    .pyramid-node.drop-target {
      border: 2px dashed #4CAF50;
      background-color: rgba(76, 175, 80, 0.1);
    }

    .pyramid-node.drop-target::before {
      content: '⤵';
      position: absolute;
      left: -20px;
      color: #4CAF50;
    }

    /* Estilos adicionales para el logo ASCII */
    .ascii-logo pre {
      margin: 0;
      font-family: monospace;
      font-size: 5px;  /* Tamaño de fuente unificado */
      color: #008a9b;
      line-height: 0.8;
      white-space: pre;
      letter-spacing: 0;
      cursor: pointer;
    }

    /* Asegurar que los caracteres ASCII también usen el mismo tamaño */
    .ascii-char {
      font-size: 5px;  /* Mismo tamaño que el pre */
      font-family: monospace;
      transition: color 0.3s ease;
    }

    /* Mantener el mismo tamaño para el cursor personalizado */
    #custom-cursor {
      font-size: 5px;  /* Mismo tamaño que los otros elementos */
      font-family: monospace;
    }

    .ascii-logo pre:hover {
      background-image: linear-gradient(to right, 
        #008a9b, #3a7b8c, #5f8a93, #009b8a, #008a9b, 
        #3a7b8c, #5f8a93, #009b8a);
      background-size: 800% 100%;
      color: transparent;
      -webkit-background-clip: text;
      background-clip: text;
      animation: rainbow 3s linear infinite;
    }

    @keyframes rainbow { 
      0% { background-position: 0% 50%; } 
      100% { background-position: 100% 50%; }
    }

    /* Estilos adicionales para el logo ASCII */
    .ascii-logo pre {
      margin: 0;
      font-family: monospace;
      font-size: 5px;  /* Cambiado de 10px a 8px */
      color: #008a9b;
      line-height: 0.8;  /* Ajustado para mejor espaciado vertical */
      white-space: pre;
      letter-spacing: 0;
      cursor: pointer;
    }

    .ascii-logo pre:hover {
      background-image: linear-gradient(to right, 
        #008a9b, #3a7b8c, #5f8a93, #009b8a, #008a9b, 
        #3a7b8c, #5f8a93, #009b8a);
      background-size: 800% 100%;
      color: transparent;
      -webkit-background-clip: text;
      background-clip: text;
      animation: rainbow 3s linear infinite;
    }

    @keyframes rainbow { 
      0% { background-position: 0% 50%; } 
      100% { background-position: 100% 50%; }
    }

    /* Estilos para el ASCII art */
    .ascii-art {
      font-family: monospace;
      white-space: pre;
      line-height: 1;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 3rem;  /* Añadido espacio inferior */
      padding-bottom: 2rem; /* Padding adicional */
      border-bottom: 1px solid rgba(101, 184, 196, 0.2); /* Línea separadora sutil */
    }

    .ascii-line {
      display: inline-block;
    }

    /* Paleta de colores basada en el tema principal */
    .color-1 { color: #65b8c4; }         /* Color principal */
    .color-2 { color: #4a9ba7; }         /* Variación más oscura */
    .color-3 { color: #80c5cf; }         /* Variación más clara */
    .color-4 { color: #3d8591; }         /* Variación aún más oscura */
    .color-5 { color: #9ad2da; }         /* Variación aún más clara */

    /* Nuevos estilos para el scroll infinito */
    .pyramid-container {
      min-height: 100%;
      height: auto;
      padding-bottom: 100px; /* Espacio adicional al final */
      overflow-y: visible;
    }
    
    .nodes-container {
      height: auto;
      min-height: 100vh;
      overflow-y: auto;
      overflow-x: hidden;
      scroll-behavior: smooth;
      padding-bottom: 50px; /* Espacio adicional para scroll */
    }
    
    /* Mejorar la visibilidad de los nodos expandidos */
    .children-container.visible {
      opacity: 1;
      max-height: none; /* Eliminar límite de altura para permitir expansión completa */
      height: auto;
      overflow: visible;
      transition: opacity 0.3s ease;
    }
    
    /* Asegurar que los niveles se expandan correctamente */
    .pyramid-level {
      width: 100%;
      height: auto;
      margin-bottom: 40px; /* Aumentar espacio entre niveles */
      overflow: visible;
    }
    
    /* Indicador de scroll */
    .scroll-indicator {
      position: fixed;
      bottom: 50px;
      right: 20px;
      background-color: var(--primary);
      color: white;
      padding: 10px 15px;
      border-radius: 30px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 1000;
      pointer-events: none;
    }
    
    .scroll-indicator.visible {
      opacity: 0.8;
    }

    /* Añadir margen inferior adicional para el último nodo */
    .nodes-container {
      padding-bottom: 10px; /* Reducido de 200px a 100px */
    }

    .pyramid-container {
      margin-bottom: auto; /* Mantener margen automático */
      min-height: calc(100vh - 300px); /* Garantizar altura mínima para todo el contenido */
    }

    /* Asegurar que el último nodo siempre tenga espacio suficiente */
    .pyramid-node:last-child {
      margin-bottom: 10px; /* Reducido de 150px a 50px */
    }

    /* También ajustar el contenedor de la visualización completa */
    #node-visualization {
      padding-bottom: 80px; /* Reducido de 200px a 80px */
      min-height: 100%;
    }

    .pyramid-level.level-0 {
      justify-content: flex-start; /* Alinear el nodo raíz a la izquierda */
      padding-left: 20px; /* Añadir el mismo padding que los otros niveles */
    }

    .pyramid-container {
      align-items: flex-start;
      margin-left: 0;
      width: 100%;
    }

    /* Asegurar que el primer nivel también se alinee a la izquierda */
    .pyramid-level:first-child {
      justify-content: flex-start;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <div class="ascii-logo">
        <div id="ascii-container"></div>
        <div id="custom-cursor">@@@@@@@@<br>@@<br>@@<br>@@<br>@@@@@@<br>@@<br>@@<br>@@<br>@@@@<br>@@@@@@@@@@</div>
      </div>
      <div class="controls">
        <button id="load-data">Cargar Datos</button>
        <button id="open-ontology">Ontología</button>
        <select id="format-selector">
          <option value="yaml">YAML</option>
          <option value="json">JSON</option>
        </select>
      </div>
    </div>
    
    <div class="main-content">
      <button class="toggle-panel" id="toggle-panel">≡</button>
      <button class="toggle-props-panel" id="toggle-props-panel">⚙</button>
      
      <div class="YAML-JSON" id="yaml-json-panel">
        <h2>Datos en formato <span id="current-format">YAML</span></h2>
        <textarea id="data-display"></textarea>
        <button id="update-visualization">Actualizar Visualización</button>
      </div>
      
      <div class="nodes-container" id="nodes-container">
        <div id="node-visualization">
          <!-- La visualización se generará aquí dinámicamente -->
        </div>
      </div>
      
      <div class="props-panel" id="props-panel">
        <h2>Jerarquía de Propiedades</h2>
        <div id="props-tree"></div>
      </div>
    </div>
    
    <!-- Panel de información del nodo -->
    <div class="info-panel" id="info-panel">
      <div class="info-panel-content">
        <!-- Sección de definiciones (izquierda) -->
        <div class="metadata-section">
          <div class="info-basic">
            <div><span class="info-label">Nodo:</span> <span id="node-name">Ninguno seleccionado</span></div>
            <div><span class="info-label">ID:</span> <span id="node-id">-</span></div>
            <button class="edit-button" id="toggle-metadata">Añadir Definición</button>
          </div>
          <div class="metadata-editor" id="metadata-editor">
            <div class="metadata-form">
              <div class="metadata-input-group">
                <input type="text" class="metadata-input" id="metadata-key" placeholder="Título (ej: Descripción, Autor, etc.)">
                <input type="text" class="metadata-input" id="metadata-value" placeholder="Valor">
              </div>
              <div class="metadata-actions">
                <button class="save-button" id="save-metadata">Guardar</button>
                <button class="cancel-button" id="cancel-metadata">Cancelar</button>
              </div>
            </div>
          </div>
          <div class="metadata-cards-container" id="metadata-cards-container">
            <!-- Las tarjetas de definiciones se generarán aquí dinámicamente -->
          </div>
        </div>
        
        <!-- Nueva sección de propiedades (derecha) -->
        <div class="properties-section">
          <div class="properties-title">Propiedades</div>
          <div class="properties-list" id="properties-list">
            <!-- Las propiedades se generarán aquí dinámicamente -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Incluir la biblioteca js-yaml para procesar YAML -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
  
  <script>
    // Configuración personalizable
    const config = {
      maxVisibleChildren: 6,  // Número máximo de nodos hijos visibles inicialmente
      animationDuration: 300, // Duración de las animaciones en milisegundos
      autoScrollDelay: 100,   // Retraso para el desplazamiento automático
      collapseByDefault: true // Colapsar nodos hijos por defecto
    };
    
    // Datos de ejemplo en formato YAML
    const yamlData = `Las pasiones del alma:
      - Admiración:
        - Orgullo
`;

    // Variables globales
    let currentFocusedNode = null;
    
    // Objeto para almacenar definiciones de nodos
    const nodeMetadata = {};
    
    // Objeto para almacenar las propiedades asignadas a cada nodo
    const nodeProperties = {};
    
    // Función para convertir YAML a JSON
    function yamlToJson(yamlString) {
      return jsyaml.load(yamlString);
    }
    
    // Función para convertir JSON a YAML
    function jsonToYaml(jsonObj) {
      return jsyaml.dump(jsonObj);
    }
    
    // Función para crear un nodo raíz fijo que siempre sea visible
    function createFixedRootNode() {
      const rootNodeId = "node_0_0_0"; // ID consistente para el nodo raíz
      
      // Crear el contenedor para el nodo raíz fijo
      const fixedRootContainer = document.createElement('div');
      fixedRootContainer.id = 'fixed-root-container';
      fixedRootContainer.className = 'fixed-root-container';
      
      // Obtener el texto del nodo raíz original
      const originalRootNode = document.querySelector(`.pyramid-node[data-id="${rootNodeId}"]`);
      const rootText = originalRootNode ? originalRootNode.textContent.trim() : 'Nodo Raíz';
      
      // Crear el nodo raíz fijo
      fixedRootContainer.innerHTML = `
        <div class="fixed-root-node" data-id="${rootNodeId}">
          <span class="root-icon">⬆</span>
          <span class="root-text">${rootText}</span>
        </div>
      `;
      
      // Añadir evento de clic para navegar al nodo raíz
      fixedRootContainer.querySelector('.fixed-root-node').addEventListener('click', function() {
        const rootNode = document.querySelector(`.pyramid-node[data-id="${rootNodeId}"]`);
        if (rootNode) {
          rootNode.click();
          
          // Hacer scroll al nodo raíz
          rootNode.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      });
      
      // Añadir el contenedor al DOM
      document.body.insertBefore(fixedRootContainer, document.body.firstChild);
      
      // Añadir estilos CSS para el nodo raíz fijo
      const style = document.createElement('style');
      style.textContent = `
        .fixed-root-container {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          background-color: var(--primary, #65b8c4);
          color: white;
          z-index: 1000;
          box-shadow: 0 2px 5px rgba(0,0,0,0.2);
          padding: 5px 0;
          text-align: center;
        }
        
        .fixed-root-node {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          padding: 5px 15px;
          border-radius: 20px;
          background-color: rgba(255, 255, 255, 0.2);
          cursor: pointer;
          transition: background-color 0.2s;
        }
        
        .fixed-root-node:hover {
          background-color: rgba(255, 255, 255, 0.3);
        }
        
        .root-icon {
          margin-right: 8px;
          font-size: 18px;
        }
        
        .root-text {
          font-weight: bold;
          font-size: 16px;
        }
        
        /* Ajustar el contenido principal para que no quede debajo del nodo raíz fijo */
        body {
          padding-top: 40px;
        }
        
        /* Hacer que el nodo raíz fijo sea más visible cuando se está navegando */
        .pyramid-node.focused:not([data-id="${rootNodeId}"]) ~ #fixed-root-container .fixed-root-node {
          animation: gentle-pulse 2s infinite;
        }
        
        @keyframes gentle-pulse {
          0% { background-color: rgba(255, 255, 255, 0.2); }
          50% { background-color: rgba(255, 255, 255, 0.4); }
          100% { background-color: rgba(255, 255, 255, 0.2); }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Modificar la función updateNodeVisualization para asegurarse de que el nodo raíz siempre esté visible
    function updateNodeVisualization(data) {
      const nodeVisualization = document.getElementById('node-visualization');
      
      try {
        if (typeof data === 'string') {
          data = yamlToJson(data);
        }
        
        console.log("Datos procesados:", data);
        
        const rootKey = Object.keys(data)[0];
        console.log("Clave raíz detectada:", rootKey);
        
        // Generar HTML para la visualización vertical
        let html = '<div class="pyramid-container">';
        
        const rootNodeId = "node_0_0_0";
        html += `
          <div class="pyramid-level level-0">
            <div class="node-group">
              <div class="pyramid-node main always-visible" tabindex="0" data-id="${rootNodeId}" data-parent="null">
                ${rootKey}
              </div>
            </div>
          </div>`;
        
        html += `<div class="children-container" id="children_${rootNodeId}">`;
        html = renderNodesRecursively(data[rootKey], rootNodeId, html, 1);
        html += `</div></div>`;
        
        nodeVisualization.innerHTML = html;
        
        // Mostrar automáticamente los hijos del nodo raíz
        document.getElementById(`children_${rootNodeId}`).classList.add('visible');
        
        // Actualizar el texto del nodo raíz fijo si existe
        const fixedRootNode = document.querySelector('.fixed-root-node');
        if (fixedRootNode) {
          const rootTextElement = fixedRootNode.querySelector('.root-text');
          if (rootTextElement) {
            rootTextElement.textContent = rootKey;
          }
          // Limpiar el breadcrumb al actualizar
          const breadcrumb = fixedRootNode.querySelector('.root-breadcrumb');
          if (breadcrumb) {
            breadcrumb.textContent = '';
          }
        } else {
          // Si no existe el nodo fijo, crearlo
          setTimeout(createFixedRootNode, 100);
        }
        
        // Configurar eventos para los nodos
        setupNodeEvents();
        
      } catch (e) {
        console.error("Error al actualizar la visualización:", e);
        nodeVisualization.innerHTML = '<p>Error al generar la visualización. Verifica el formato de los datos.</p>';
      }
    }
    
    // Función recursiva unificada que maneja cualquier nivel de la jerarquía
    function renderNodesRecursively(items, parentId, html, level) {
      if (!Array.isArray(items)) return html;
      
      // Clases de nodos basadas en el nivel (cíclico)
      const nodeClasses = ['main', 'category', 'subcategory', 'example'];
      const nodeClass = nodeClasses[level % nodeClasses.length];
      
      items.forEach((item, index) => {
        const nodeId = `node_${level}_${parentId}_${index}`;
        
        if (typeof item === 'object') {
          // El item es un objeto con clave y posibles hijos
          const itemName = Object.keys(item)[0];
          const children = item[itemName];
          
          // Renderizar este nodo
          html += `
            <div class="node-group">
              <div class="pyramid-node ${nodeClass}" tabindex="0" data-parent="${parentId}" data-id="${nodeId}">
                ${itemName}
              </div>
            </div>`;
          
          // Si tiene hijos, crear el contenedor y procesarlos recursivamente
          if (children && (Array.isArray(children) || typeof children === 'object')) {
            html += `<div class="children-container" id="children_${nodeId}">`;
            html = renderNodesRecursively(
              Array.isArray(children) ? children : [children], 
              nodeId, 
              html, 
              level + 1
            );
            html += `</div>`;
          }
        } else {
          // El item es un valor simple (string, número, etc.)
          html += `
            <div class="node-group">
              <div class="pyramid-node ${nodeClass}" tabindex="0" data-parent="${parentId}" data-id="${nodeId}">
                ${item}
              </div>
            </div>`;
        }
      });
      
      return html;
    }
    
    // Función para procesar recursivamente niveles más profundos
    function processDeepLevels(items, parentId, htmlString, level, indexPrefix) {
      if (!Array.isArray(items)) return htmlString;
      
      // Determinar la clase según el nivel
      let nodeClass;
      switch (level % 4) {
        case 0: nodeClass = 'main'; break;
        case 1: nodeClass = 'category'; break;
        case 2: nodeClass = 'subcategory'; break;
        case 3: nodeClass = 'example'; break;
      }
      
      items.forEach((item, index) => {
        const itemId = `level${level}_${indexPrefix}_${index}`;
        
        if (typeof item === 'object') {
          const itemName = Object.keys(item)[0];
          const subItems = item[itemName];
          
          htmlString += `
            <div class="node-group">
              <div class="pyramid-node ${nodeClass}" tabindex="0" data-parent="${parentId}" data-id="${itemId}">
                ${itemName}
              </div>
            </div>`;
          
          // Añadir contenedor para el siguiente nivel
          htmlString += `<div class="children-container" id="children_${itemId}">`;
          
          // Procesar recursivamente el siguiente nivel
          processDeepLevels(subItems, itemId, htmlString, level + 1, `${indexPrefix}_${index}`);
          
          htmlString += `</div>`; // Cerrar contenedor de nivel
        } else {
          // Item es un string simple
          htmlString += `
            <div class="node-group">
              <div class="pyramid-node ${nodeClass}" tabindex="0" data-parent="${parentId}" data-id="${itemId}">
                ${item}
              </div>
            </div>`;
        }
      });
      
      return htmlString;
    }
    
    // Función mejorada para configurar eventos de nodos
    function setupNodeEvents() {
      let currentFocusedNode = null;
      
      const nodes = document.querySelectorAll('.pyramid-node');
      
      nodes.forEach(node => {
        // Marcar nodos que tienen hijos
        if (childrenContainer) {
          node.classList.add('has-children');
          node.classList.add('collapsed');
        }
        
        // Evento de clic
        node.addEventListener('click', function(e) {
          e.stopPropagation();
          
          // Remover la clase 'focused' de todos los nodos
          document.querySelectorAll('.pyramid-node.focused').forEach(n => {
            n.classList.remove('focused');
          });
          
          // Añadir la clase 'focused' a este nodo
          this.classList.add('focused');
          currentFocusedNode = this;
          
          // Actualizar visualización de nodos y panel de información
          updateNodesVisualState(this.getAttribute('data-id'));
          updateNodeInfo(this);
          
          // Si no es el nodo raíz, hacer scroll con offset
          if (!this.closest('.level-0')) {
            const offset = 170; // Ajustar según necesidad (altura de la barra superior + espacio extra)
            const elementPosition = this.getBoundingClientRect().top;
            const offsetPosition = elementPosition - offset;
            
            window.scrollBy({
              top: offsetPosition,
              behavior: 'smooth'
            });
          }
        });
        
        // Evento de doble clic para expandir/colapsar
        node.addEventListener('dblclick', function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          if (childrenContainer) {
            // Alternar visibilidad del contenedor de hijos
            childrenContainer.classList.toggle('visible');
            
            // Actualizar clase del nodo
            if (childrenContainer.classList.contains('visible')) {
              this.classList.remove('collapsed');
              this.classList.add('expanded');
            } else {
              this.classList.remove('expanded');
              this.classList.add('collapsed');
            }
          }
        });
        
        // Configurar eventos de arrastre y otros eventos
        // ... (mantener los eventos de teclado y arrastre existentes)
      });
      
      // Configurar navegación con teclado
      setupKeyboardNavigation();
    }
    
    // Función para dibujar líneas de conexión entre nodos
    function drawConnectionLines() {
      const svg = document.querySelector('.connection-lines');
      if (!svg) return;
      
      // Limpiar líneas existentes
      svg.innerHTML = '';
      
      // Obtener todos los nodos expandidos
      const expandedNodes = document.querySelectorAll('.pyramid-node.expanded');
      
      expandedNodes.forEach(node => {
        const nodeId = node.getAttribute('data-id');
        const childrenContainer = document.getElementById(`children_${nodeId}`);
        
        if (childrenContainer && childrenContainer.classList.contains('visible')) {
          const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
          
          // Calcular posiciones
          const parentRect = node.getBoundingClientRect();
          const containerRect = document.querySelector('.pyramid-container').getBoundingClientRect();
          
          // Punto de inicio (desde el lado derecho del nodo padre)
          const startX = parentRect.right - containerRect.left;
          const startY = parentRect.top + parentRect.height/2 - containerRect.top;
          
          childNodes.forEach(childNode => {
            const childRect = childNode.getBoundingClientRect();
            
            // Punto final (en el lado izquierdo del nodo hijo)
            const endX = childRect.left - containerRect.left;
            const endY = childRect.top + childRect.height/2 - containerRect.top;
            
            // Crear la curva Bezier
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // Calcular puntos de control para una curva suave
            const controlX = startX + (endX - startX) / 2;
            
            // Definir la ruta de la curva
            const d = `M ${startX} ${startY} 
                       C ${controlX} ${startY}, ${controlX} ${endY}, ${endX} ${endY}`;
            
            path.setAttribute('d', d);
            path.setAttribute('class', 'connection-line');
            
            svg.appendChild(path);
          });
        }
      });
    }
    
    // Ajustar evento de redimensionamiento para redibujar las líneas
    window.addEventListener('resize', function() {
      setTimeout(drawConnectionLines, 100);
    });
    
    // Función para configurar los controles de navegación en contenedores de hijos
    function setupChildrenNavigation() {
      // Configurar botones de navegación
      document.querySelectorAll('.nav-next').forEach(button => {
        button.addEventListener('click', function() {
          const container = this.closest('.children-container');
          const totalChildren = parseInt(container.getAttribute('data-total-children'));
          let visibleStart = parseInt(container.getAttribute('data-visible-start'));
          
          // Calcular el nuevo índice de inicio
          if (visibleStart + config.maxVisibleChildren < totalChildren) {
            visibleStart++;
            container.setAttribute('data-visible-start', visibleStart);
            
            // Actualizar visibilidad de los nodos
            updateVisibleChildren(container, visibleStart);
            
            // Actualizar estado de los botones
            updateNavigationButtons(container, visibleStart, totalChildren);
          }
        });
      });
      
      document.querySelectorAll('.nav-prev').forEach(button => {
        button.addEventListener('click', function() {
          const container = this.closest('.children-container');
          let visibleStart = parseInt(container.getAttribute('data-visible-start'));
          
          // Calcular el nuevo índice de inicio
          if (visibleStart > 0) {
            visibleStart--;
            container.setAttribute('data-visible-start', visibleStart);
            
            // Actualizar visibilidad de los nodos
            updateVisibleChildren(container, visibleStart);
            
            // Actualizar estado de los botones
            updateNavigationButtons(container, visibleStart, parseInt(container.getAttribute('data-total-children')));
          }
        });
      });
      
      // Ajustar inicialmente la cantidad de nodos visibles según el espacio disponible
      adjustVisibleNodesCount();
      
      // Configurar evento de redimensionamiento para ajustar dinámicamente
      window.addEventListener('resize', adjustVisibleNodesCount);
    }
    
    // Nueva función para ajustar dinámicamente la cantidad de nodos visibles
    function adjustVisibleNodesCount() {
      const pyramidLevels = document.querySelectorAll('.pyramid-level');
      
      pyramidLevels.forEach(level => {
        const levelWidth = level.clientWidth;
        const nodeGroups = level.querySelectorAll('.node-group');
        
        if (nodeGroups.length === 0) return;
        
        // Calcular el ancho promedio de un nodo
        const sampleNode = nodeGroups[0].querySelector('.pyramid-node');
        if (!sampleNode) return;
        
        // Usar un margen más razonable entre nodos
        const nodeWidth = sampleNode.offsetWidth + 20;
        
        // Reducir el margen de seguridad para que se active la paginación cuando sea necesario
        const safetyMargin = 10;
        
        // Calcular cuántos nodos caben en el nivel
        const maxNodesInView = Math.floor((levelWidth - safetyMargin) / nodeWidth);
        
        // Asegurar que maxNodesInView sea al menos 1 menos que el total para mostrar la paginación
        // cuando hay muchos nodos, incluso si técnicamente podrían caber
        const adjustedMaxNodes = Math.min(maxNodesInView, nodeGroups.length > 5 ? nodeGroups.length - 1 : nodeGroups.length);
        
        // Si no caben todos los nodos o tenemos más de 5 nodos, mostrar controles de navegación
        if (adjustedMaxNodes < nodeGroups.length || nodeGroups.length > 5) {
          // Ocultar nodos que no caben
          nodeGroups.forEach((node, index) => {
            if (index < adjustedMaxNodes) {
              node.style.display = 'block';
            } else {
              node.style.display = 'none';
            }
          });
          
          // Eliminar los controles de navegación anteriores si existen
          const oldNavControls = level.querySelector('.level-navigation');
          if (oldNavControls) {
            oldNavControls.remove();
          }
          
          // Crear nuevos controles de navegación y colocarlos debajo de los nodos
          const navControls = document.createElement('div');
          navControls.className = 'level-navigation';
          
          // Asegurar que el texto del indicador sea completo
          const totalNodes = nodeGroups.length;
          navControls.innerHTML = `
            <button class="level-nav-prev" disabled>◀</button>
            <span class="level-nav-indicator">${1}-${adjustedMaxNodes} de ${totalNodes}</span>
            <button class="level-nav-next">▶</button>
          `;
          
          // Insertar los controles después del último nodo visible
          level.appendChild(navControls);
          
          // Configurar eventos para los botones de navegación
          setupLevelNavigation(level, navControls, nodeGroups, adjustedMaxNodes);
        } else {
          // Si caben todos los nodos, mostrarlos todos y quitar controles de navegación
          nodeGroups.forEach(node => {
            node.style.display = 'block';
          });
          
          const navControls = level.querySelector('.level-navigation');
          if (navControls) {
            navControls.remove();
          }
        }
      });
    }
    
    // Función para configurar la navegación en niveles
    function setupLevelNavigation(level, navControls, nodeGroups, maxNodesInView) {
      const prevButton = navControls.querySelector('.level-nav-prev');
      const nextButton = navControls.querySelector('.level-nav-next');
      const indicator = navControls.querySelector('.level-nav-indicator');
      const totalNodes = nodeGroups.length;
      
      // Inicializar el atributo de datos
      level.setAttribute('data-visible-start', '0');
      
      prevButton.addEventListener('click', function() {
        let visibleStart = parseInt(level.getAttribute('data-visible-start'));
        
        if (visibleStart > 0) {
          visibleStart--;
          level.setAttribute('data-visible-start', visibleStart);
          
          // Actualizar visibilidad de los nodos
          updateLevelVisibleNodes(nodeGroups, visibleStart, maxNodesInView);
          
          // Actualizar indicador y estado de botones
          const endIndex = Math.min(visibleStart + maxNodesInView, totalNodes);
          indicator.textContent = `${visibleStart + 1}-${endIndex} de ${totalNodes}`;
          prevButton.disabled = visibleStart === 0;
          nextButton.disabled = false;
        }
      });
      
      nextButton.addEventListener('click', function() {
        let visibleStart = parseInt(level.getAttribute('data-visible-start'));
        const maxStart = totalNodes - maxNodesInView;
        
        if (visibleStart < maxStart) {
          visibleStart++;
          level.setAttribute('data-visible-start', visibleStart);
          
          // Actualizar visibilidad de los nodos
          updateLevelVisibleNodes(nodeGroups, visibleStart, maxNodesInView);
          
          // Actualizar indicador y estado de botones
          const endIndex = Math.min(visibleStart + maxNodesInView, totalNodes);
          indicator.textContent = `${visibleStart + 1}-${endIndex} de ${totalNodes}`;
          prevButton.disabled = false;
          nextButton.disabled = visibleStart >= maxStart;
        }
      });
    }
    
    // Función para actualizar la visibilidad de los nodos en un nivel
    function updateLevelVisibleNodes(nodeGroups, startIndex, maxVisible) {
      nodeGroups.forEach((node, index) => {
        if (index >= startIndex && index < startIndex + maxVisible) {
          node.style.display = 'block';
        } else {
          node.style.display = 'none';
        }
      });
    }
    
    // Función para actualizar la visibilidad de los nodos hijos
    function updateVisibleChildren(container, startIndex) {
      const children = container.querySelectorAll('.pyramid-node');
      const totalChildren = children.length;
      
      // Ocultar todos los nodos
      children.forEach(child => {
        child.classList.add('hidden');
      });
      
      // Mostrar solo los nodos en el rango visible
      for (let i = startIndex; i < Math.min(startIndex + config.maxVisibleChildren, totalChildren); i++) {
        children[i].classList.remove('hidden');
      }
      
      // Actualizar el indicador de navegación
      const endIndex = Math.min(startIndex + config.maxVisibleChildren, totalChildren);
      const indicator = container.querySelector('.nav-indicator');
      if (indicator) {
        indicator.textContent = `${startIndex + 1}-${endIndex} de ${totalChildren}`;
      }
    }
    
    // Función para actualizar el estado de los botones de navegación
    function updateNavigationButtons(container, startIndex, totalChildren) {
      const prevButton = container.querySelector('.nav-prev');
      const nextButton = container.querySelector('.nav-next');
      
      if (prevButton) {
        prevButton.disabled = startIndex === 0;
      }
      
      if (nextButton) {
        nextButton.disabled = startIndex + config.maxVisibleChildren >= totalChildren;
      }
    }
    
    // Función para actualizar el estado visual de los nodos
    function updateNodesVisualState(focusedNodeId = null) {
      // Obtener todos los nodos
      const allNodes = document.querySelectorAll('.pyramid-node');
      const rootNodeId = "node_0_0_0"; // Usar el mismo ID consistente
      
      // Primero, restablecer todos los nodos a su estado minimizado, excepto los que tienen la clase always-visible
      allNodes.forEach(node => {
        node.classList.remove('focused', 'active-child');
        if (!node.classList.contains('always-visible')) {
          node.classList.add('minimized');
        }
      });
      
      // Asegurarse de que el nodo raíz siempre sea visible
      const rootNode = document.querySelector(`.pyramid-node[data-id="${rootNodeId}"]`);
      if (rootNode) {
        rootNode.classList.remove('minimized');
      }
      
      if (focusedNodeId) {
        // Obtener el nodo enfocado
        const focusedNode = document.querySelector(`.pyramid-node[data-id="${focusedNodeId}"]`);
        
        if (focusedNode) {
          // Activar el nodo enfocado
          focusedNode.classList.add('focused');
          focusedNode.classList.remove('minimized');
          
          // Activar la cadena de padres hasta la raíz
          let currentNode = focusedNode;
          let parentNode = null;
          
          while (currentNode) {
            const parentId = currentNode.getAttribute('data-parent');
            if (parentId && parentId !== 'null') {
              parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
              if (parentNode) {
                parentNode.classList.remove('minimized');
                currentNode = parentNode;
              } else {
                break;
              }
            } else {
              break;
            }
          }
          
          // Activar SOLO los hijos directos del nodo enfocado
          const childrenNodes = document.querySelectorAll(`.pyramid-node[data-parent="${focusedNodeId}"]`);
          childrenNodes.forEach(child => {
            child.classList.remove('minimized');
            child.classList.add('active-child');
          });
        }
      } else {
        // Si no hay nodo enfocado, mostrar solo el nodo raíz y sus hijos directos
        if (rootNode) {
          rootNode.classList.remove('minimized');
          rootNode.classList.add('focused');
          
          // Mostrar solo los hijos directos del nodo raíz
          const rootChildren = document.querySelectorAll(`.pyramid-node[data-parent="${rootNodeId}"]`);
          rootChildren.forEach(child => {
            child.classList.remove('minimized');
            child.classList.add('active-child');
          });
        }
      }
    }
    
    // Función para actualizar la información del nodo en el panel inferior
    function updateNodeInfo(node) {
      const infoPanel = document.getElementById('info-panel');
      const metadataEditor = document.getElementById('metadata-editor');
      const metadataCardsContainer = document.getElementById('metadata-cards-container');
      
      // Ya no necesitamos verificar si el panel está fijado
      /* 
      if (infoPanel.classList.contains('fixed')) {
        return;
      }
      */
      
      if (!node) {
        document.getElementById('node-name').textContent = 'Ninguno seleccionado';
        document.getElementById('node-id').textContent = '-';
        metadataEditor.classList.remove('visible');
        infoPanel.classList.remove('expanded');
        metadataCardsContainer.innerHTML = '';
        return;
      }
      
      const nodeName = node.textContent.trim();
      const nodeId = node.getAttribute('data-id');
      
      document.getElementById('node-name').textContent = nodeName;
      document.getElementById('node-id').textContent = nodeId;
      
      // Ocultar el editor de definiciones
      metadataEditor.classList.remove('visible');
      
      // Mostrar las tarjetas de definiciones existentes
      renderMetadataCards(nodeId);
      
      // Siempre expandir el panel cuando se selecciona un nodo
      infoPanel.classList.add('expanded');
      
      const propertiesList = document.getElementById('properties-list');
      propertiesList.innerHTML = ''; // Limpiar la lista actual
      
      // Agregar eventos de drop a la sección de propiedades
      const propertiesSection = document.querySelector('.properties-section');
      propertiesSection.addEventListener('dragover', handlePropertiesDragOver);
      propertiesSection.addEventListener('dragenter', handlePropertiesDragEnter);
      propertiesSection.addEventListener('dragleave', handlePropertiesDragLeave);
      propertiesSection.addEventListener('drop', handlePropertiesDrop);
      
      // Mostrar las propiedades existentes del nodo
      if (nodeId && nodeProperties[nodeId]) {
        // Limpiar la lista antes de añadir propiedades
        propertiesList.innerHTML = '';
        
        nodeProperties[nodeId].forEach(prop => {
          // Usar la versión mejorada de addPropertyToList que maneja propInfo correctamente
          addPropertyToList(prop.key || prop.fullPath, prop, nodeId);
        });
      }
    }
    
    // Función para renderizar las tarjetas de definiciones
    function renderMetadataCards(nodeId) {
      const container = document.getElementById('metadata-cards-container');
      container.innerHTML = '';
      
      // Si no hay definiciones para este nodo, mostrar solo el botón de añadir
      if (!nodeMetadata[nodeId] || Object.keys(nodeMetadata[nodeId]).length === 0) {
        container.innerHTML = '<div class="add-metadata-card" id="add-metadata-card" tabindex="0">+ Añadir definición</div>';
        
        // Añadir evento al botón de añadir
        setTimeout(() => {
          const addButton = document.getElementById('add-metadata-card');
          if (addButton) {
            addButton.addEventListener('click', function() {
              document.getElementById('toggle-metadata').click();
            });
            
            // Añadir navegación con teclado
            addButton.addEventListener('keydown', function(e) {
              if (e.key === 'Enter') {
                e.preventDefault();
                document.getElementById('toggle-metadata').click();
              }
            });
          }
        }, 0);
        
        return;
      }
      
      // Crear tarjetas para cada definición
      let index = 0;
      for (const [key, value] of Object.entries(nodeMetadata[nodeId])) {
        const card = document.createElement('div');
        card.className = 'metadata-card';
        card.setAttribute('tabindex', '0'); // Hacer la tarjeta enfocable
        card.setAttribute('data-key', key);
        card.setAttribute('data-index', index++);
        card.innerHTML = `
          <div class="metadata-card-title">${key}</div>
          <div class="metadata-card-content">${value}</div>
        `;
        
        // Añadir evento para editar al hacer clic en la tarjeta
        card.addEventListener('click', function() {
          editMetadataCard(this, key, value);
        });
        
        // Añadir navegación con teclado
        card.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            editMetadataCard(this, key, value);
          } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
            e.preventDefault();
            const nextCard = this.nextElementSibling;
            if (nextCard && nextCard.classList.contains('metadata-card')) {
              nextCard.focus();
            } else if (document.getElementById('add-metadata-card')) {
              document.getElementById('add-metadata-card').focus();
            }
          } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
            e.preventDefault();
            const prevCard = this.previousElementSibling;
            if (prevCard && prevCard.classList.contains('metadata-card')) {
              prevCard.focus();
            }
          } else if (e.key === 'Escape') {
            e.preventDefault();
            // Volver al nodo
            const focusedNode = document.querySelector('.pyramid-node.focused');
            if (focusedNode) {
              focusedNode.focus();
            }
          }
        });
        
        container.appendChild(card);
      }
      
      // Añadir el botón para agregar nueva definición
      const addButton = document.createElement('div');
      addButton.className = 'add-metadata-card';
      addButton.setAttribute('tabindex', '0');
      addButton.textContent = '+ Añadir definición';
      
      addButton.addEventListener('click', function() {
        document.getElementById('toggle-metadata').click();
      });
      
      // Añadir navegación con teclado
      addButton.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          document.getElementById('toggle-metadata').click();
        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
          e.preventDefault();
          const cards = document.querySelectorAll('.metadata-card');
          if (cards.length > 0) {
            cards[cards.length - 1].focus();
          }
        } else if (e.key === 'Escape') {
          e.preventDefault();
          // Volver al nodo
          const focusedNode = document.querySelector('.pyramid-node.focused');
          if (focusedNode) {
            focusedNode.focus();
          }
        }
      });
      
      container.appendChild(addButton);
    }
    
    // Función auxiliar para editar una tarjeta de definición
    function editMetadataCard(card, key, value) {
      // Abrir el editor con los valores de esta tarjeta
      document.getElementById('metadata-key').value = key;
      document.getElementById('metadata-value').value = value;
      document.getElementById('metadata-editor').classList.add('visible');
      document.getElementById('info-panel').classList.add('expanded');
      
      // Guardar la clave original para poder actualizarla
      document.getElementById('metadata-key').setAttribute('data-original-key', key);
      
      // Enfocar el campo de título
      setTimeout(() => {
        document.getElementById('metadata-key').focus();
      }, 100);
    }
    
    // Configurar eventos para los nodos
    function setupNodeEvents() {
      let currentFocusedNode = null;
      
      const nodes = document.querySelectorAll('.pyramid-node');
      
      nodes.forEach(node => {
        // Marcar nodos que tienen hijos
        const nodeId = node.getAttribute('data-id');
        const hasChildren = document.querySelector(`.pyramid-node[data-parent="${nodeId}"]`) !== null;
        const childrenContainer = document.getElementById(`children_${nodeId}`);
        
        if (hasChildren) {
          node.classList.add('collapsed');
        }
        
        // Evento de clic simple
        node.addEventListener('click', function() {
          if (currentFocusedNode) {
            currentFocusedNode.classList.remove('focused');
          }
          
          this.classList.add('focused');
          currentFocusedNode = this;
          
          updateNodesVisualState(this.getAttribute('data-id'));
          updateNodeInfo(this);
          
          // Modificar el comportamiento de scrollIntoView para que sea menos restrictivo
          this.scrollIntoView({ 
            block: 'nearest', // Cambiar de 'center' a 'nearest'
            inline: 'nearest', 
            behavior: 'smooth' 
          });
          
          // Mostrar brevemente un indicador de que se puede hacer scroll libremente
          showScrollFreedomIndicator();
        });

        // Añadir evento de doble clic
        node.addEventListener('dblclick', function(e) {
          e.preventDefault();
          
          const nodeId = this.getAttribute('data-id');
          const childrenContainer = document.getElementById(`children_${nodeId}`);
          
          if (childrenContainer) {
            // Alternar visibilidad del contenedor de hijos
            childrenContainer.classList.toggle('visible');
            
            // Actualizar clase del nodo
            if (childrenContainer.classList.contains('visible')) {
              this.classList.remove('collapsed');
              this.classList.add('expanded');
              
              // Si se expande, hacer visibles los nodos hijos para la navegación
              const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
              childNodes.forEach(child => {
                child.classList.remove('minimized');
                child.classList.add('active-child');
              });

              // Seleccionar el primer ejemplo visible
              const firstExample = childrenContainer.querySelector('.pyramid-node:not(.hidden)');
              if (firstExample) {
                firstExample.click();
              }
            } else {
              this.classList.remove('expanded');
              this.classList.add('collapsed');
              
              // Si estamos cerrando un contenedor y el nodo enfocado está dentro de él,
              // devolver el foco al nodo padre
              const focusedNodeContainer = document.querySelector('.pyramid-node.focused').closest('.children-container');
              if (focusedNodeContainer && focusedNodeContainer.id === `children_${nodeId}`) {
                this.click(); // Seleccionar el nodo padre
              }
            }
          }
        });
        
        // Añadir evento de teclado para expandir/colapsar con la barra espaciadora
        // Ya no usamos Enter para fijar la información
        node.addEventListener('keydown', function(e) {
          if (e.key === ' ' || e.key === 'Spacebar') {
            e.preventDefault(); // Prevenir el desplazamiento de la página
            
            const nodeId = this.getAttribute('data-id');
            const childrenContainer = document.getElementById(`children_${nodeId}`);
            
            if (childrenContainer) {
              // Alternar visibilidad del contenedor de hijos
              childrenContainer.classList.toggle('visible');
              
              // Actualizar clase del nodo
              if (childrenContainer.classList.contains('visible')) {
                this.classList.remove('collapsed');
                this.classList.add('expanded');
                
                // Si se expande, hacer visibles los nodos hijos para la navegación
                const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
                childNodes.forEach(child => {
                  child.classList.remove('minimized');
                  child.classList.add('active-child');
                });
              } else {
                this.classList.remove('expanded');
                this.classList.add('collapsed');
              }
            } else {
              // Verificar si este nodo es hijo de otro nodo
              const parentId = this.getAttribute('data-parent');
              if (parentId && parentId !== 'null') {
                // Buscar el contenedor de hijos del padre
                const parentContainer = document.getElementById(`children_${parentId}`);
                if (parentContainer && parentContainer.classList.contains('visible')) {
                  // Colapsar el contenedor del padre
                  parentContainer.classList.remove('visible');
                  
                  // Actualizar la clase del nodo padre
                  const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
                  if (parentNode) {
                    parentNode.classList.remove('expanded');
                    parentNode.classList.add('collapsed');
                    
                    // Enfocar el nodo padre
                    parentNode.click();
                  }
                }
              }
            }
          }
          // Eliminar el bloque de código para Enter que fijaba el nodo
        });

        // Añadir evento de teclado para Enter
        node.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            e.stopPropagation();
            
            // Enfocar el editor de definiciones
            document.getElementById('toggle-metadata').click();
            
            // Enfocar el campo de título después de un breve retraso
            setTimeout(() => {
              const metadataKey = document.getElementById('metadata-key');
              if (metadataKey) {
                metadataKey.focus();
              }
            }, 100);
          } else if (e.key === ' ' || e.key === 'Spacebar') {
            e.preventDefault();
            
            const nodeId = this.getAttribute('data-id');
            const childrenContainer = document.getElementById(`children_${nodeId}`);
            
            if (childrenContainer) {
              // Alternar visibilidad del contenedor de hijos
              childrenContainer.classList.toggle('visible');
              
              // Actualizar clase del nodo
              if (childrenContainer.classList.contains('visible')) {
                this.classList.remove('collapsed');
                this.classList.add('expanded');
                
                // Si se expande, hacer visibles los nodos hijos para la navegación
                const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
                childNodes.forEach(child => {
                  child.classList.remove('minimized');
                  child.classList.add('active-child');
                });
              } else {
                this.classList.remove('expanded');
                this.classList.add('collapsed');
                
                // Si estamos cerrando un contenedor y el nodo enfocado está dentro de él,
                // devolver el foco al nodo padre
                const focusedNodeContainer = document.querySelector('.pyramid-node.focused').closest('.children-container');
                if (focusedNodeContainer && focusedNodeContainer.id === `children_${nodeId}`) {
                  this.click(); // Seleccionar el nodo padre
                }
              }
            }
          }
        });

        // Configurar eventos de arrastre
        node.setAttribute('draggable', 'true');
        
        node.addEventListener('dragstart', (e) => {
          e.stopPropagation();
          node.classList.add('dragging');
          console.log('Iniciando arrastre del nodo:', node.getAttribute('data-id')); // Debug
          e.dataTransfer.setData('text/plain', node.getAttribute('data-id'));
          e.dataTransfer.effectAllowed = 'copy';
        });

        node.addEventListener('dragend', () => {
          node.classList.remove('dragging');
          // Remover la clase drop-target de todos los nodos
          document.querySelectorAll('.drop-target').forEach(n => {
            n.classList.remove('drop-target');
          });
        });

        node.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (!node.classList.contains('dragging')) {
            node.classList.add('drop-target');
          }
        });

        node.addEventListener('dragleave', (e) => {
          e.preventDefault();
          e.stopPropagation();
          node.classList.remove('drop-target');
        });

        node.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const draggedId = e.dataTransfer.getData('text/plain');
          const targetId = node.getAttribute('data-id');
          
          if (draggedId !== targetId) {
            const draggedNode = document.querySelector(`[data-id="${draggedId}"]`);
            
            if (!isDescendant(draggedNode, node)) {
              draggedNode.setAttribute('data-parent', targetId);
              updateNodeVisualization(getCurrentData());
              
              // Mostrar información de ambos nodos
              showSplitNodeInfo(draggedNode, node);
            }
          }
          
          node.classList.remove('drop-target');
        });
      });
    }
    
    // Configurar navegación con teclado
    function setupKeyboardNavigation() {
      let currentFocusedNode = null;
      const nodes = document.querySelectorAll('.pyramid-node');
      const rootNodeId = "node_0_0_0"; // Usar el mismo ID consistente
      
      document.addEventListener('keydown', function(e) {
        if (document.activeElement === document.getElementById('data-display')) {
          return;
        }

        currentFocusedNode = document.querySelector('.pyramid-node.focused');
        
        if (!currentFocusedNode) {
          if (nodes.length > 0 && (e.key === 'ArrowDown' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowLeft')) {
            nodes[0].click();
            e.preventDefault();
          }
          return;
        }

        const isInChildrenContainer = currentFocusedNode.closest('.children-container') !== null;
        const nodeId = currentFocusedNode.getAttribute('data-id');
        const parentId = currentFocusedNode.getAttribute('data-parent');
        const childrenContainer = document.getElementById(`children_${nodeId}`);
        const hasChildren = childrenContainer !== null;
        
        // Añadir tecla Home para volver al nodo raíz desde cualquier lugar
        if (e.key === 'Home') {
          e.preventDefault();
          const rootNode = document.querySelector(`.pyramid-node[data-id="${rootNodeId}"]`);
          if (rootNode) {
            rootNode.click();
          }
          return;
        }
        
        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            if (isInChildrenContainer) {
              // Navegación dentro del contenedor de ejemplos
              const container = currentFocusedNode.closest('.children-container');
              const examples = Array.from(container.querySelectorAll('.pyramid-node:not(.hidden)'));
              const currentIndex = examples.indexOf(currentFocusedNode);
              
              if (currentIndex < examples.length - 1) {
                examples[currentIndex + 1].click();
              }
            } else if (hasChildren && !childrenContainer.classList.contains('visible')) {
              // Si tiene hijos y están ocultos, mostrarlos y seleccionar el primero
              childrenContainer.classList.add('visible');
              currentFocusedNode.classList.remove('collapsed');
              currentFocusedNode.classList.add('expanded');
              
              const firstExample = childrenContainer.querySelector('.pyramid-node:not(.hidden)');
              if (firstExample) {
                firstExample.click();
              }
            } else {
              // Buscar hijos directos del nodo actual
              const children = Array.from(nodes).filter(node => 
                node.getAttribute('data-parent') === nodeId &&
                !node.classList.contains('hidden')
              );
              
              if (children.length > 0) {
                children[0].click();
              }
            }
            break;

          case 'ArrowUp':
            e.preventDefault();
            if (isInChildrenContainer) {
              const container = currentFocusedNode.closest('.children-container');
              const examples = Array.from(container.querySelectorAll('.pyramid-node:not(.hidden)'));
              const currentIndex = examples.indexOf(currentFocusedNode);
              
              if (currentIndex > 0) {
                examples[currentIndex - 1].click();
              } else {
                // Volver al nodo padre
                const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
                if (parentNode) {
                  parentNode.click();
                }
              }
            } else {
              // Ir al padre del nodo actual
              if (parentId && parentId !== 'null') {
                const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
                if (parentNode) {
                  parentNode.click();
                }
              }
            }
            break;

          case 'ArrowRight':
            e.preventDefault();
            if (isInChildrenContainer) {
              return; // No hacer nada si estamos en ejemplos
            }
            
            // Buscar hermanos del nodo actual
            const siblings = Array.from(nodes).filter(node => 
              node.getAttribute('data-parent') === parentId &&
              !node.classList.contains('hidden') &&
              !node.closest('.children-container')
            );
            
            const currentIndex = siblings.indexOf(currentFocusedNode);
            if (currentIndex < siblings.length - 1) {
              siblings[currentIndex + 1].click();
            }
            break;

          case 'ArrowLeft':
            e.preventDefault();
            if (isInChildrenContainer) {
              // Volver al nodo padre desde los ejemplos
              const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
              if (parentNode) {
                parentNode.click();
              }
            } else {
              // Buscar hermanos del nodo actual
              const siblings = Array.from(nodes).filter(node => 
                node.getAttribute('data-parent') === parentId &&
                !node.classList.contains('hidden') &&
                !node.closest('.children-container')
              );
              
              const currentIndex = siblings.indexOf(currentFocusedNode);
              if (currentIndex > 0) {
                siblings[currentIndex - 1].click();
              }
            }
            break;

          case ' ':
          case 'Spacebar':
            e.preventDefault();
            if (hasChildren) {
              childrenContainer.classList.toggle('visible');
              if (childrenContainer.classList.contains('visible')) {
                currentFocusedNode.classList.remove('collapsed');
                currentFocusedNode.classList.add('expanded');
              } else {
                currentFocusedNode.classList.remove('expanded');
                currentFocusedNode.classList.add('collapsed');
                
                // Si estamos cerrando un contenedor y el nodo enfocado está dentro de él,
                // devolver el foco al nodo padre
                const focusedNodeContainer = document.querySelector('.pyramid-node.focused').closest('.children-container');
                if (focusedNodeContainer && focusedNodeContainer.id === `children_${nodeId}`) {
                  currentFocusedNode.click(); // Seleccionar el nodo padre
                }
              }
            }
            break;
        }
      });
    }
    
    // Función para alternar la visibilidad del panel YAML-JSON
    document.getElementById('toggle-panel').addEventListener('click', function() {
      const panel = document.getElementById('yaml-json-panel');
      const mainContent = document.querySelector('.main-content');
      const nodesContainer = document.getElementById('nodes-container');
      
      panel.classList.toggle('visible');
      mainContent.classList.toggle('panel-visible');
      
      // Si el panel está visible, desplazar el contenedor de nodos a la derecha
      if (panel.classList.contains('visible')) {
        this.textContent = '×'; // Cambiar el ícono del botón a una X
      } else {
        this.textContent = '≡'; // Cambiar el ícono del botón a barras
      }
      
      // Actualizar los indicadores de navegación después de un breve retraso
      // para permitir que la animación de desplazamiento termine
      setTimeout(checkForOverflow, 300);
      
      // Forzar un reflow para que el contenedor de nodos se ajuste correctamente
      setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
      }, 350);
    });
    
    // Evento para cambiar entre formatos
    document.getElementById('format-selector').addEventListener('change', function() {
      const format = this.value;
      document.getElementById('current-format').textContent = format.toUpperCase();
      
      if (format === 'json') {
        // Convertir YAML a JSON
        try {
          const jsonData = yamlToJson(document.getElementById('data-display').value);
          document.getElementById('data-display').value = JSON.stringify(jsonData, null, 2);
        } catch (e) {
          console.error("Error al convertir a JSON:", e);
          document.getElementById('data-display').value = "Error al convertir a JSON. Verifica el formato YAML.";
        }
      } else {
        // Convertir JSON a YAML
        try {
          const jsonText = document.getElementById('data-display').value;
          const jsonObj = JSON.parse(jsonText);
          const yamlData = jsonToYaml(jsonObj);
          document.getElementById('data-display').value = yamlData;
        } catch (e) {
          console.error("Error al convertir a YAML:", e);
          document.getElementById('data-display').value = "# Error al convertir a YAML. Verifica el formato JSON.";
        }
      }
    });
    
    // Evento para actualizar la visualización
    document.getElementById('update-visualization').addEventListener('click', function() {
      const format = document.getElementById('format-selector').value;
      const dataText = document.getElementById('data-display').value;
      
      if (format === 'json') {
        try {
          const jsonObj = JSON.parse(dataText);
          updateNodeVisualization(jsonObj);
        } catch (e) {
          console.error("Error al parsear JSON:", e);
          alert("Error al parsear JSON. Verifica el formato.");
        }
      } else {
        updateNodeVisualization(dataText);
      }
    });
    
    // Función para verificar si hay desbordamiento y mostrar indicadores
    function checkForOverflow() {
      const container = document.querySelector('.nodes-container');
      const content = document.querySelector('.pyramid-container');
      
      if (!container || !content) return;
      
      // Eliminar indicadores existentes
      document.querySelectorAll('.navigation-indicator').forEach(el => el.remove());
      
      // Verificar desbordamiento horizontal
      if (content.scrollWidth > container.clientWidth) {
        // Hay contenido fuera de la vista a la derecha
        const rightIndicator = document.createElement('div');
        rightIndicator.className = 'navigation-indicator indicator-right';
        rightIndicator.textContent = '→';
        container.appendChild(rightIndicator);
        
        // Hay contenido fuera de la vista a la izquierda
        const leftIndicator = document.createElement('div');
        leftIndicator.className = 'navigation-indicator indicator-left';
        leftIndicator.textContent = '←';
        container.appendChild(leftIndicator);
      }
      
      // Verificar desbordamiento vertical
      if (content.scrollHeight > container.clientHeight) {
        // Hay contenido fuera de la vista abajo
        const downIndicator = document.createElement('div');
        downIndicator.className = 'navigation-indicator indicator-down';
        downIndicator.textContent = '↓';
        container.appendChild(downIndicator);
        
        // Hay contenido fuera de la vista arriba
        const upIndicator = document.createElement('div');
        upIndicator.className = 'navigation-indicator indicator-up';
        upIndicator.textContent = '↑';
        container.appendChild(upIndicator);
      }
    }
    
    // Función para alternar la visibilidad del panel de propiedades
    document.getElementById('toggle-props-panel').addEventListener('click', function() {
      const panel = document.getElementById('props-panel');
      const mainContent = document.querySelector('.main-content');
      
      panel.classList.toggle('visible');
      mainContent.classList.toggle('props-panel-visible');
      
      // Si el panel está visible, cambiar el ícono del botón
      if (panel.classList.contains('visible')) {
        this.textContent = '×'; // Cambiar el ícono del botón a una X
      } else {
        this.textContent = '⚙'; // Cambiar el ícono del botón a engranaje
      }
      
      // Actualizar los indicadores de navegación después de un breve retraso
      setTimeout(checkForOverflow, 300);
      
      // Forzar un reflow para que el contenedor de nodos se ajuste correctamente
      setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
      }, 350);
    });
    
    // Función para cargar y mostrar la jerarquía de propiedades
    async function loadPropertiesHierarchy() {
      try {
        // Usar los datos cargados desde el archivo externo
        // En lugar de usar datos hardcodeados
        console.log("Cargando propiedades desde archivo externo");
        
        // Si ya tenemos las propiedades cargadas, usarlas
        if (window.emotionalProperties) {
          console.log("Usando propiedades previamente cargadas:", window.emotionalProperties);
          renderPropertiesTree(window.emotionalProperties);
          return;
        }
        
        // Si no, cargarlas ahora
        const propsData = await loadPropertiesFile();
        console.log("Propiedades cargadas dinámicamente:", propsData);
        
        // Guardar para uso futuro
        window.emotionalProperties = propsData;
        
        // Renderizar el árbol con los datos cargados
        renderPropertiesTree(propsData);
      } catch (error) {
        console.error('Error loading properties hierarchy:', error);
        document.getElementById('props-tree').innerHTML = '<p>Error al cargar la jerarquía de propiedades.</p>';
      }
    }
    
    // Eliminar completamente los datos hardcodeados de propiedades
    // No debe haber ninguna definición de propsData aquí
    
    // Modificar la función renderPropertiesTree para depurar mejor
    function renderPropertiesTree(data, parentElement = null, parentPath = '') {
      console.log("Renderizando árbol de propiedades con datos:", data);
      
      const container = parentElement || document.getElementById('props-tree');
      
      if (!parentElement) {
        container.innerHTML = '';
      }
      
      Object.entries(data).forEach(([key, value]) => {
        if (key === 'id' || key === 'value') return;
        
        const currentPath = parentPath ? `${parentPath} > ${key}` : key;
        
        const itemDiv = document.createElement('div');
        itemDiv.className = 'prop-item';
        
        const headerDiv = document.createElement('div');
        headerDiv.className = 'prop-item-header';
        headerDiv.draggable = true; // Hacer draggable el header en lugar del contenedor
        
        // Agregar los datos al header en lugar del contenedor
        headerDiv.dataset.key = key;
        headerDiv.dataset.fullPath = currentPath;
        if (value && value.id) {
          headerDiv.dataset.id = value.id;
        }
        
        const hasChildren = typeof value === 'object' && value !== null && 
                            Object.keys(value).some(k => k !== 'id' && k !== 'value');
        
        let headerContent = '';
        if (hasChildren) {
          headerContent += '<span class="prop-toggle">▶</span>';
        } else {
          headerContent += '<span class="prop-toggle" style="visibility:hidden">▶</span>';
        }
        
        headerContent += `<span class="prop-label">${key}</span>`;
        
        if (value && value.id) {
          headerContent += `<span class="prop-id">(ID: ${value.id})</span>`;
        }
        
        headerDiv.innerHTML = headerContent;
        itemDiv.appendChild(headerDiv);
        
        // Agregar eventos de arrastre al header
        headerDiv.addEventListener('dragstart', handleDragStart);
        headerDiv.addEventListener('dragend', handleDragEnd);
        
        if (hasChildren) {
          const childrenDiv = document.createElement('div');
          childrenDiv.className = 'prop-children';
          itemDiv.appendChild(childrenDiv);
          
          // Mover el evento de clic al toggle
          headerDiv.querySelector('.prop-toggle').addEventListener('click', function(e) {
            e.stopPropagation();
            childrenDiv.classList.toggle('visible');
            this.textContent = childrenDiv.classList.contains('visible') ? '▼' : '▶';
            
            if (childrenDiv.classList.contains('visible') && childrenDiv.children.length === 0) {
              renderPropertiesTree(value, childrenDiv, currentPath);
            }
          });
        }
        
        container.appendChild(itemDiv);
      });
    }
    
    // Asegurarse de que loadPropertiesFile se llame primero y solo una vez
    document.addEventListener('DOMContentLoaded', async function() {
      console.log("DOM cargado, iniciando carga de archivos");
      
      try {
        // Cargar primero el archivo de propiedades
        console.log("Cargando archivo de propiedades...");
        const properties = await loadPropertiesFile();
        console.log("Propiedades cargadas exitosamente:", properties);
        
        // Guardar para uso global
        window.emotionalProperties = properties;
        
        // Ahora cargar el YAML
        console.log("Cargando archivo YAML...");
        await loadYamlFile();
        
        // Cargar la jerarquía de propiedades con los datos ya cargados
        console.log("Inicializando jerarquía de propiedades...");
        await loadPropertiesHierarchy();
        
        console.log("Inicialización completa");
      } catch (error) {
        console.error("Error durante la inicialización:", error);
      }
    });
    
    // Funciones para manejar el arrastre
    let draggedItem = null;
    let dragIndicator = null;
    
    // Modificar handleDragStart para asegurar que captura el elemento correcto
    function handleDragStart(e) {
      e.stopPropagation(); // Evitar que el evento se propague al padre
      draggedItem = this;
      this.classList.add('dragging');
      
      console.log('Elemento arrastrado:', {
        key: this.dataset.key,
        fullPath: this.dataset.fullPath,
        id: this.dataset.id
      });
      
      const dragData = {
        key: this.dataset.key,
        fullPath: this.dataset.fullPath,
        id: this.dataset.id,
        type: 'property'
      };
      
      e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
      e.dataTransfer.effectAllowed = 'copy';
    }
    
    function handleDragEnd(e) {
      this.classList.remove('dragging');
      if (dragIndicator) {
        dragIndicator.remove();
        dragIndicator = null;
      }
      
      // Limpiar clases de destino en todos los elementos
      document.querySelectorAll('.prop-item').forEach(item => {
        item.classList.remove('drag-over');
      });
    }
    
    function handleDragOver(e) {
      e.preventDefault();
      
      if (draggedItem === this) return;
      
      // Actualizar posición del indicador
      const rect = this.getBoundingClientRect();
      const y = e.clientY - rect.top;
      const height = rect.height;
      
      if (dragIndicator) {
        dragIndicator.style.position = 'absolute';
        dragIndicator.style.width = `${rect.width}px`;
        dragIndicator.style.left = `${rect.left}px`;
        dragIndicator.style.display = 'block';
        
        if (y < height / 2) {
          dragIndicator.style.top = `${rect.top}px`;
        } else {
          dragIndicator.style.top = `${rect.bottom}px`;
        }
      }
    }
    
    function handleDragEnter(e) {
      e.preventDefault();
      if (draggedItem !== this) {
        this.classList.add('drag-over');
      }
    }
    
    function handleDragLeave(e) {
      this.classList.remove('drag-over');
    }
    
    // Modificar handlePropertiesDrop para verificar los datos recibidos
    function handlePropertiesDrop(e) {
      e.preventDefault();
      this.classList.remove('drag-over');
      
      try {
        const rawData = e.dataTransfer.getData('text/plain');
        console.log('Datos recibidos en drop (raw):', rawData);
        
        const data = JSON.parse(rawData);
        console.log('Datos procesados en drop:', data);
        
        const nodeId = document.getElementById('node-id').textContent;
        console.log('ID del nodo destino:', nodeId);
        
        if (nodeId && nodeId !== '-') {
          if (!nodeProperties[nodeId]) {
            nodeProperties[nodeId] = [];
          }
          
          const propertyExists = nodeProperties[nodeId].some(prop => prop.id === data.id);
          console.log('¿La propiedad ya existe?:', propertyExists);
          
          if (!propertyExists) {
            const newProperty = {
              key: data.key,
              fullPath: data.fullPath,
              id: data.id
            };
            
            console.log('Añadiendo nueva propiedad:', newProperty);
            nodeProperties[nodeId].push(newProperty);
            
            addPropertyToList(data.fullPath || data.key, data.id, nodeId);
            console.log('Estado actual de nodeProperties:', nodeProperties);
          }
        }
      } catch (error) {
        console.error('Error al procesar el drop:', error);
      }
    }
    
    // Función para actualizar el modelo de datos después del arrastre
    function updateDataModel(draggedElement, targetElement, insertBefore) {
      // Aquí implementarías la lógica para actualizar el modelo de datos
      // según tus necesidades específicas
      console.log('Actualizando modelo de datos:', {
        dragged: draggedElement.dataset.key,
        target: targetElement.dataset.key,
        insertBefore: insertBefore
      });
    }
    
    // Modificar la sección de datos YAML
    // En lugar de tener los datos hardcodeados, los cargaremos desde un archivo externo
    // Usar la variable yamlData existente en lugar de declararla nuevamente
    
    // Función para cargar el archivo YAML
    async function loadYamlFile() {
      try {
        console.log("Intentando cargar clases.yml...");
        const response = await fetch('/SEMINARIO/V6/data/clases.yml');
        
        if (!response.ok) {
          throw new Error(`Error al cargar el archivo: ${response.status}`);
        }
        
        const loadedYamlData = await response.text();
        console.log("Datos YAML cargados:", loadedYamlData.substring(0, 100) + "..."); // Mostrar primeros 100 caracteres
        
        // Actualizar la visualización
        document.getElementById('data-display').value = loadedYamlData;
        
        // Forzar la actualización de la visualización
        console.log("Actualizando visualización con datos cargados");
        updateNodeVisualization(loadedYamlData);
        
        // Guardar en variable global para referencia
        window.yamlData = loadedYamlData;
        
        // Forzar actualización después de un breve retraso
        setTimeout(() => {
          console.log("Actualizando visualización después de retraso");
          updateNodeVisualization(window.yamlData);
          
          // Seleccionar el nodo raíz por defecto
          setTimeout(() => {
            const rootNode = document.querySelector('.pyramid-node[data-id="root"]');
            if (rootNode) {
              rootNode.click();
            }
          }, 500);
        }, 1000);
        
        return loadedYamlData;
      } catch (error) {
        console.error("Error al cargar el archivo YAML:", error);
        // Usar datos de respaldo específicos para clases.yml
        const fallbackData = "Los nombres de la música:\n  - Error al cargar datos";
        document.getElementById('data-display').value = fallbackData;
        updateNodeVisualization(fallbackData);
        return fallbackData;
      }
    }
    
    // Función para cargar el archivo JSON de propiedades
    async function loadPropertiesFile() {
      try {
        const response = await fetch('/SEMINARIO/V6/data/propiedades.json');
        if (!response.ok) {
          throw new Error(`Error al cargar el archivo de propiedades: ${response.status}`);
        }
        const propertiesData = await response.json();
        console.log("Datos JSON de propiedades cargados correctamente");
        
        // Actualizar la visualización o almacenar los datos para su uso posterior
        // Dependiendo de cómo se utilicen las propiedades en tu aplicación
        return propertiesData;
      } catch (error) {
        console.error("Error al cargar el archivo JSON de propiedades:", error);
        // Proporcionar datos de respaldo en caso de error
        return {
          "id": "root-props-fallback",
          "PropiedadesEmocionales": {
            "id": "emotional-props-fallback",
            "Mensaje": "Error al cargar las propiedades"
          }
        };
      }
    }
    
    // Inicializar la carga de datos al cargar la página
    document.addEventListener('DOMContentLoaded', async function() {
      // Verificar que las bibliotecas necesarias estén cargadas
      if (typeof jsyaml === 'undefined') {
        console.error("Error: jsyaml no está cargado");
        document.getElementById('node-visualization').innerHTML = 
          '<p>Error: No se pudo cargar la biblioteca js-yaml. Verifica las dependencias.</p>';
        return;
      }
      
      // Cargar datos desde los archivos externos
      loadYamlFile(); // Cargar pasiones.yml
      
      // Cargar propiedades.json y almacenar el resultado
      const properties = await loadPropertiesFile();
      
      // Hacer disponible las propiedades para su uso en la aplicación
      window.emotionalProperties = properties;
      
      // Cargar la jerarquía de propiedades con los datos cargados
      loadPropertiesHierarchy();
      
      // Si hay alguna función que necesite usar las propiedades, llámala aquí
      // Por ejemplo: initializePropertiesPanel(properties);
      
      // ... existing code ...
    });
    
    // Inicializar la visualización al cargar la página
    document.addEventListener('DOMContentLoaded', function() {
      // Verificar que jsyaml esté cargado
      if (typeof jsyaml === 'undefined') {
        console.error("Error: jsyaml no está cargado");
        document.getElementById('node-visualization').innerHTML = 
          '<p>Error: No se pudo cargar la biblioteca js-yaml. Verifica las dependencias.</p>';
        return;
      }
      
      // Cargar datos desde el archivo YAML
      loadYamlFile();
      
      // Generar visualización inicial
      updateNodeVisualization(yamlData);
      
      // Añadir evento de redimensionamiento para actualizar indicadores
      window.addEventListener('resize', checkForOverflow);
      
      // Añadir eventos de desplazamiento para actualizar indicadores
      document.querySelector('.nodes-container').addEventListener('scroll', function() {
        // Actualizar visibilidad de indicadores según la posición de desplazamiento
        const indicators = document.querySelectorAll('.navigation-indicator');
        indicators.forEach(indicator => {
          indicator.style.opacity = '0.7';
          setTimeout(() => {
            indicator.style.opacity = '0';
          }, 1500);
        });
      });
      
      // Inicializar el estado visual de los nodos
      setTimeout(() => {
        updateNodesVisualState();
        
        // Seleccionar el nodo raíz por defecto
        const rootNode = document.querySelector('.pyramid-node[data-id="root"]');
        if (rootNode) {
          rootNode.click();
        }
      }, config.autoScrollDelay);
      
      // Añadir estilos CSS para el desplazamiento del contenedor de nodos
      const style = document.createElement('style');
      style.textContent = `
        /* Estilos existentes para nodos fijados... */
        
        /* Ajustar el diseño para evitar superposiciones */
        .main-content {
          display: flex;
          flex-direction: row;
          align-items: stretch;
          overflow: hidden;
        }
        
        .YAML-JSON {
          width: 0;
          overflow: hidden;
          transition: width 0.3s ease;
          flex-shrink: 0;
        }
        
        .YAML-JSON.visible {
          width: 40%; /* Ancho del panel cuando está visible */
          min-width: 300px;
          max-width: 500px;
        }
        
        .nodes-container {
          flex-grow: 1;
          overflow: auto;
          transition: margin-left 0.3s ease, width 0.3s ease;
          width: 100%;
        }
        
        .main-content.panel-visible .nodes-container {
          margin-left: 40%; /* Debe coincidir con el ancho del panel */
          width: 60%; /* El ancho restante */
        }
        
        @media (max-width: 1200px) {
          .YAML-JSON.visible {
            width: 350px;
            min-width: 300px;
          }
          
          .main-content.panel-visible .nodes-container {
            margin-left: 350px;
            width: calc(100% - 350px);
          }
        }
        
        /* Asegurar que el botón de alternar siempre esté visible */
        .toggle-panel {
          position: fixed;
          left: 10px;
          top: 10px;
          z-index: 1001;
          background-color: #333;
          color: white;
          border: none;
          border-radius: 4px;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          font-size: 18px;
          box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .toggle-panel:hover {
          background-color: #555;
        }
        
        /* Asegurar que el contenido de la visualización se ajuste correctamente */
        .pyramid-container {
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          transition: transform 0.3s ease;
        }
      `;
      document.head.appendChild(style);
      
      // Asegurarse de que el contenedor de nodos se ajuste cuando cambia el tamaño de la ventana
      window.addEventListener('resize', function() {
        checkForOverflow();
        
        // Ajustar el tamaño del contenedor de nodos si el panel está visible
        const panel = document.getElementById('yaml-json-panel');
        const nodesContainer = document.getElementById('nodes-container');
        
        if (panel && panel.classList.contains('visible') && nodesContainer) {
          // Forzar un reflow para que el contenedor se ajuste correctamente
          nodesContainer.style.display = 'none';
          setTimeout(() => {
            nodesContainer.style.display = '';
          }, 10);
        }
      });
      
      // Cargar la jerarquía de propiedades
      loadPropertiesHierarchy();
      
      // Añadir estilos CSS adicionales para manejar ambos paneles
      const additionalStyle = document.createElement('style');
      additionalStyle.textContent = `
        /* Ajustes para cuando ambos paneles están visibles */
        .main-content.panel-visible.props-panel-visible .nodes-container {
          margin-left: 40%;
          margin-right: 40%;
          width: 20%;
        }
        
        @media (max-width: 1200px) {
          .main-content.panel-visible.props-panel-visible .nodes-container {
            margin-left: 350px;
            margin-right: 350px;
            width: calc(100% - 700px);
          }
        }
      `;
      document.head.appendChild(additionalStyle);
      
      // Configurar el botón de edición de definiciones
      document.getElementById('toggle-metadata').addEventListener('click', function() {
        const metadataEditor = document.getElementById('metadata-editor');
        const infoPanel = document.getElementById('info-panel');
        
        // Limpiar los campos del formulario
        document.getElementById('metadata-key').value = '';
        document.getElementById('metadata-value').value = '';
        document.getElementById('metadata-key').removeAttribute('data-original-key');
        
        metadataEditor.classList.add('visible');
        infoPanel.classList.add('expanded');
        
        // Enfocar el campo de título
        document.getElementById('metadata-key').focus();
      });
      
      // Configurar el botón de guardar definiciones
      document.getElementById('save-metadata').addEventListener('click', function() {
        const nodeId = document.getElementById('node-id').textContent;
        if (nodeId && nodeId !== '-') {
          const key = document.getElementById('metadata-key').value.trim();
          const value = document.getElementById('metadata-value').value.trim();
          const originalKey = document.getElementById('metadata-key').getAttribute('data-original-key');
          
          if (key && value) {
            // Inicializar el objeto de definiciones para este nodo si no existe
            if (!nodeMetadata[nodeId]) {
              nodeMetadata[nodeId] = {};
            }
            
            // Si estamos editando una definición existente, eliminar la clave anterior
            if (originalKey && originalKey !== key) {
              delete nodeMetadata[nodeId][originalKey];
            }
            
            // Guardar el nuevo valor
            nodeMetadata[nodeId][key] = value;
            
            // Actualizar la visualización
            renderMetadataCards(nodeId);
            
            // Ocultar el editor
            document.getElementById('metadata-editor').classList.remove('visible');
          }
        }
      });
      
      // Configurar el botón de cancelar
      document.getElementById('cancel-metadata').addEventListener('click', function() {
        document.getElementById('metadata-editor').classList.remove('visible');
      });
    });
    
    // En la sección donde se configura el editor de definiciones
    function setupMetadataEditor() {
      const metadataKeyInput = document.getElementById('metadata-key');
      const metadataValueInput = document.getElementById('metadata-value');
      const saveButton = document.getElementById('save-metadata');
      const cancelButton = document.getElementById('cancel-metadata');
      const metadataEditor = document.getElementById('metadata-editor');
      
      // Añadir el event listener para atrapar el foco a nivel del documento
      document.addEventListener('keydown', trapFocusInMetadataEditor, true);
      
      // Cuando se abre el editor, enfocar el primer campo
      document.getElementById('toggle-metadata').addEventListener('click', function() {
        metadataEditor.classList.add('visible');
        setTimeout(() => {
          metadataKeyInput.focus();
        }, 0);
      });
      
      // Resto del código de configuración del editor...
      metadataKeyInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          metadataValueInput.focus();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelMetadataEdit();
        }
      });
      
      metadataValueInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          saveButton.click();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelMetadataEdit();
        }
      });
      
      saveButton.addEventListener('click', function() {
        saveMetadata();
      });
      
      cancelButton.addEventListener('click', function() {
        cancelMetadataEdit();
      });
    }
    
    // Función para editar una tarjeta de definición
    function editMetadataCard(card, key, value) {
      const metadataEditor = document.getElementById('metadata-editor');
      const metadataKeyInput = document.getElementById('metadata-key');
      const metadataValueInput = document.getElementById('metadata-value');
      
      metadataKeyInput.value = key;
      metadataValueInput.value = value;
      metadataEditor.classList.add('visible');
      document.getElementById('info-panel').classList.add('expanded');
      
      metadataKeyInput.setAttribute('data-original-key', key);
      
      // Asegurar que el foco se establezca en el campo de título
      setTimeout(() => {
        metadataKeyInput.focus();
      }, 100);
    }
    
    // Función para cancelar la edición
    function cancelMetadataEdit() {
      const metadataEditor = document.getElementById('metadata-editor');
      const metadataKeyInput = document.getElementById('metadata-key');
      const metadataValueInput = document.getElementById('metadata-value');
      
      metadataEditor.classList.remove('visible');
      metadataKeyInput.value = '';
      metadataValueInput.value = '';
      metadataKeyInput.removeAttribute('data-original-key');
      
      // Volver a enfocar el nodo activo
      const focusedNode = document.querySelector('.pyramid-node.focused');
      if (focusedNode) {
        focusedNode.focus();
      }
    }
    
    // Función para atrapar el foco dentro del editor de definiciones
    function trapFocusInMetadataEditor(e) {
      const metadataEditor = document.getElementById('metadata-editor');
      
      // Solo proceder si el editor está visible
      if (!metadataEditor.classList.contains('visible')) {
        return;
      }
      
      // Si la tecla presionada es Tab
      if (e.key === 'Tab') {
        // Obtener todos los elementos focusables dentro del editor
        const focusableElements = Array.from(metadataEditor.querySelectorAll(
          'input, button, [href], select, textarea, [tabindex]:not([tabindex="-1"])'
        )).filter(el => !el.disabled && el.offsetParent !== null);
        
        const firstFocusableElement = focusableElements[0];
        const lastFocusableElement = focusableElements[focusableElements.length - 1];
        
        // Si no hay elementos focusables, no hacer nada
        if (!firstFocusableElement) return;
        
        // Verificar si el elemento activo está dentro del editor
        const isInEditor = metadataEditor.contains(document.activeElement);
        
        if (!isInEditor) {
          // Si el foco está fuera del editor, forzar el foco al primer elemento
          e.preventDefault();
          firstFocusableElement.focus();
          return;
        }
        
        // Si se presiona Shift + Tab
        if (e.shiftKey) {
          // Si el foco está en el primer elemento, ir al último
          if (document.activeElement === firstFocusableElement) {
            e.preventDefault();
            lastFocusableElement.focus();
          }
        } 
        // Si solo se presiona Tab
        else {
          // Si el foco está en el último elemento, ir al primero
          if (document.activeElement === lastFocusableElement) {
            e.preventDefault();
            firstFocusableElement.focus();
          }
        }
      }
    }
    
    // En el evento DOMContentLoaded, asegurarse de configurar el editor
    document.addEventListener('DOMContentLoaded', function() {
      // ... código existente ...
      
      // Configurar el editor de definiciones
      setupMetadataEditor();
      
      // ... código existente ...
    });
    
    // Configurar el manejo de teclas en el área de texto
    document.getElementById('data-display').addEventListener('keydown', function(e) {
      // Si estamos en el editor YAML, detener la propagación de teclas especiales
      if (e.key === 'Tab' || e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
        e.stopPropagation(); // Detener la propagación del evento
      }

      // Manejar la tecla Tab
      if (e.key === 'Tab') {
        e.preventDefault();
        
        const start = this.selectionStart;
        const end = this.selectionEnd;
        
        // Insertar dos espacios en la posición del cursor
        this.value = this.value.substring(0, start) + '  ' + this.value.substring(end);
        
        // Mover el cursor después de los espacios insertados
        this.selectionStart = this.selectionEnd = start + 2;
      }
      
      // Manejar la tecla Enter
      if (e.key === 'Enter') {
        e.preventDefault();
        
        const start = this.selectionStart;
        const end = this.selectionEnd;
        const value = this.value;
        
        // Obtener la línea actual
        const currentLine = value.substring(0, start).split('\n').pop();
        
        // Contar los espacios iniciales de la línea actual
        const indentation = currentLine.match(/^\s*/)[0];
        
        // Insertar nueva línea con la misma indentación
        this.value = value.substring(0, start) + '\n' + indentation + value.substring(end);
        
        // Mover el cursor después de la indentación
        const newPosition = start + 1 + indentation.length;
        this.selectionStart = this.selectionEnd = newPosition;
      }

      // Para la barra espaciadora, no necesitamos hacer nada especial
      // Solo detenemos su propagación y dejamos que funcione normalmente
      
    }, { capture: true }); // Capturar el evento en la fase de captura

    // Función para guardar definiciones
    function saveMetadata() {
      const key = document.getElementById('metadata-key').value.trim();
      const value = document.getElementById('metadata-value').value.trim();
      const originalKey = document.getElementById('metadata-key').getAttribute('data-original-key');
      
      // Obtener el nodo actualmente seleccionado
      const focusedNode = document.querySelector('.pyramid-node.focused');
      if (!focusedNode) return;
      
      const nodeId = focusedNode.getAttribute('data-id');
      
      // Inicializar el objeto de definiciones para este nodo si no existe
      if (!nodeMetadata[nodeId]) {
        nodeMetadata[nodeId] = {};
      }
      
      // Si hay una clave original y es diferente a la nueva, eliminar la antigua
      if (originalKey && originalKey !== key) {
        delete nodeMetadata[nodeId][originalKey];
      }
      
      // Guardar la nueva definición
      if (key && value) {
        nodeMetadata[nodeId][key] = value;
      }
      
      // Limpiar el formulario
      document.getElementById('metadata-key').value = '';
      document.getElementById('metadata-value').value = '';
      document.getElementById('metadata-key').removeAttribute('data-original-key');
      
      // Ocultar el editor
      document.getElementById('metadata-editor').classList.remove('visible');
      
      // Actualizar la visualización de las tarjetas de definiciones
      renderMetadataCards(nodeId);
      
      // Devolver el foco al nodo
      if (focusedNode) {
        focusedNode.focus();
      }
    }

    // Añadir el evento al botón de guardar
    document.getElementById('save-metadata').addEventListener('click', saveMetadata);

    // Añadir eventos de teclado para el formulario de definiciones
    document.getElementById('metadata-key').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('metadata-value').focus();
      }
    });

    document.getElementById('metadata-value').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveMetadata();
      }
    });

    // Funciones para manejar el drag and drop en la sección de propiedades
    function handlePropertiesDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy'; // Indicar que se está copiando el elemento
    }

    function handlePropertiesDragEnter(e) {
      e.preventDefault();
      this.classList.add('drag-over');
    }

    function handlePropertiesDragLeave(e) {
      this.classList.remove('drag-over');
    }

    // Modificar addPropertyToList para verificar los datos
    function addPropertyToList(fullPath, id, nodeId) {
      console.log('Añadiendo a la lista visual:', { fullPath, id, nodeId });
      
      const propertiesList = document.getElementById('properties-list');
      if (!propertiesList) {
        console.error('No se encontró el elemento properties-list');
        return;
      }
      
      const propertyItem = document.createElement('div');
      propertyItem.className = 'property-item';
      propertyItem.innerHTML = `
        <span class="property-key">${fullPath}</span>
        <span class="remove-property" title="Eliminar propiedad">×</span>
      `;
      
      propertyItem.querySelector('.remove-property').addEventListener('click', () => {
        console.log('Eliminando propiedad:', { id, nodeId });
        nodeProperties[nodeId] = nodeProperties[nodeId].filter(prop => prop.id !== id);
        propertyItem.remove();
      });
      
      propertiesList.appendChild(propertyItem);
    }

    // Función para manejar el drop dentro de la jerarquía de propiedades
    function handleDrop(e) {
      e.preventDefault();
      this.classList.remove('drag-over');
      
      if (draggedItem === this) return;
      
      try {
        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
        const rect = this.getBoundingClientRect();
        const y = e.clientY - rect.top;
        
        // Solo permitir reordenamiento si es un elemento de propiedad
        if (data.type === 'property') {
          // Determinar si insertar antes o después del elemento destino
          if (y < rect.height / 2) {
            this.parentNode.insertBefore(draggedItem, this);
          } else {
            this.parentNode.insertBefore(draggedItem, this.nextSibling);
          }
          
          // Actualizar el modelo de datos
          updateDataModel(draggedItem, this, y < rect.height / 2);
        }
      } catch (error) {
        console.error('Error al procesar el drop:', error);
      }
    }

    // Añadir un evento de redimensionamiento para ajustar el layout cuando cambia el tamaño de la ventana
    window.addEventListener('resize', function() {
      // Ajustar el ancho del contenedor de nodos
      const nodesContainer = document.getElementById('nodes-container');
      if (nodesContainer) {
        nodesContainer.style.width = '100%';
      }
      
      // Ajustar la cantidad de nodos visibles
      adjustVisibleNodesCount();
    });

    // Función para añadir una propiedad a la lista
    function addPropertyToList(propertyKey, propertyId, nodeId) {
      const propertiesList = document.getElementById('properties-list');
      
      // Obtener la ruta jerárquica completa de la propiedad
      const hierarchy = getPropertyHierarchy(propertyId);
      
      // Crear el elemento de la propiedad con la ruta jerárquica
      const propertyElement = document.createElement('div');
      propertyElement.className = 'property-item';
      propertyElement.setAttribute('data-property-id', propertyId);
      
      // Construir la ruta jerárquica como texto
      let hierarchyPath = propertyKey;
      if (hierarchy.length > 0) {
        hierarchyPath = hierarchy.join(' > ') + ' > ' + propertyKey;
      }
      
      propertyElement.innerHTML = `
        <div class="property-hierarchy">${hierarchyPath}</div>
        <div class="property-content">
          <span class="property-key">${propertyKey}</span>
          <button class="remove-property">×</button>
        </div>
      `;
      
      // Añadir evento para eliminar la propiedad
      const removeButton = propertyElement.querySelector('.remove-property');
      removeButton.addEventListener('click', () => {
        removePropertyFromNode(nodeId, propertyId);
        propertyElement.remove();
      });
      
      propertiesList.appendChild(propertyElement);
    }

    // Función para obtener la jerarquía completa de una propiedad
    function getPropertyHierarchy(propertyId) {
      const hierarchy = [];
      
      // Buscar el elemento de propiedad en el DOM
      const propItem = document.querySelector(`.prop-item[data-id="${propertyId}"]`);
      if (!propItem) return hierarchy;
      
      // Obtener todos los elementos padres
      let parent = propItem.parentElement;
      while (parent && parent.classList.contains('prop-children')) {
        const parentPropItem = parent.closest('.prop-item');
        if (parentPropItem) {
          const parentLabel = parentPropItem.querySelector('.prop-label');
          if (parentLabel) {
            hierarchy.unshift(parentLabel.textContent.trim());
          }
          parent = parentPropItem.parentElement;
        } else {
          break;
        }
      }
      
      return hierarchy;
    }

    // Función para eliminar una propiedad de un nodo
    function removePropertyFromNode(nodeId, propertyId) {
      if (nodeProperties[nodeId]) {
        nodeProperties[nodeId] = nodeProperties[nodeId].filter(prop => prop.id !== propertyId);
        
        // Si no quedan propiedades, eliminar la entrada
        if (nodeProperties[nodeId].length === 0) {
          delete nodeProperties[nodeId];
        }
      }
    }

    // ... existing code ...

    // Función para manejar el drop de propiedades
    function handlePropertiesDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      
      try {
        const propData = e.dataTransfer.getData('text/plain');
        const nodeId = document.getElementById('node-id').textContent;
        
        if (!nodeId || nodeId === '-') return;
        
        // Parsear los datos de la propiedad
        let propInfo;
        try {
          propInfo = JSON.parse(propData);
        } catch (err) {
          console.error('Error al parsear los datos de la propiedad:', err);
          return;
        }
        
        if (!propInfo || !propInfo.key) {
          console.error('Datos de propiedad inválidos');
          return;
        }
        
        // Añadir campo de valor por defecto
        propInfo.value = '';
        
        // Verificar si la propiedad ya está asignada al nodo
        if (!nodeProperties[nodeId]) {
          nodeProperties[nodeId] = [];
        } else if (nodeProperties[nodeId].some(prop => prop.id === propInfo.id)) {
          console.log('Esta propiedad ya está asignada a este nodo');
          return;
        }
        
        // Añadir la propiedad al nodo
        nodeProperties[nodeId].push(propInfo);
        
        // Añadir la propiedad a la lista visual
        addPropertyToList(propInfo.key, propInfo, nodeId);
        
        this.classList.remove('drop-target');
      } catch (error) {
        console.error('Error al procesar el drop:', error);
      }
    }

    // Función para añadir una propiedad a la lista
    function addPropertyToList(propertyKey, propInfo, nodeId) {
      const propertiesList = document.getElementById('properties-list');
      
      // Normalizar propInfo para manejar tanto objetos como IDs simples
      if (typeof propInfo !== 'object') {
        propInfo = {
          id: propInfo,
          key: propertyKey,
          fullPath: propertyKey,
          value: '' // Valor por defecto vacío
        };
      }
      
      // Asegurar que siempre tengamos una propiedad value
      if (!propInfo.hasOwnProperty('value')) {
        propInfo.value = '';
      }
      
      // Crear el elemento de la propiedad con la ruta jerárquica
      const propertyElement = document.createElement('div');
      propertyElement.className = 'property-item';
      propertyElement.setAttribute('data-property-id', JSON.stringify(propInfo.id));
      
      // Asegurar que siempre tengamos una ruta jerárquica
      let hierarchyPath = propInfo.fullPath || propertyKey;
      
      // Estructura HTML con la ruta jerárquica completa y el campo de valor
      propertyElement.innerHTML = `
        <div class="property-hierarchy">${hierarchyPath}</div>
        <div class="property-content">
          <span class="property-key">${propertyKey}</span>
          <div class="property-value-container">
            <input type="text" class="property-value-input" placeholder="Valor" value="${propInfo.value || ''}" 
                   aria-label="Valor de la propiedad ${propertyKey}">
          </div>
          <button class="remove-property" aria-label="Eliminar propiedad">×</button>
        </div>
      `;
      
      // Añadir evento para guardar el valor cuando cambia
      const valueInput = propertyElement.querySelector('.property-value-input');
      valueInput.addEventListener('change', (e) => {
        // Actualizar el valor en el objeto de propiedades
        const propId = propInfo.id;
        const newValue = e.target.value;
        
        // Encontrar y actualizar la propiedad en nodeProperties
        if (nodeProperties[nodeId]) {
          const propIndex = nodeProperties[nodeId].findIndex(p => 
            JSON.stringify(p.id) === JSON.stringify(propId)
          );
          
          if (propIndex !== -1) {
            nodeProperties[nodeId][propIndex].value = newValue;
            console.log(`Valor actualizado para propiedad ${propertyKey}: ${newValue}`);
          }
        }
      });
      
      // Añadir evento para eliminar la propiedad
      const removeButton = propertyElement.querySelector('.remove-property');
      removeButton.addEventListener('click', (e) => {
        e.stopPropagation(); // Evitar que el clic se propague al elemento padre
        removePropertyFromNode(nodeId, propInfo.id);
        propertyElement.remove();
      });
      
      // Añadir evento de clic para resaltar la propiedad en el árbol
      propertyElement.addEventListener('click', (e) => {
        // No activar al hacer clic en el input o en el botón de eliminar
        if (e.target !== valueInput && e.target !== removeButton) {
          // Usar la nueva función que abre el panel si está cerrado
          highlightPropertyInTree(propInfo.id);
        }
      });
      
      propertiesList.appendChild(propertyElement);
      
      // Guardar la ruta completa en los datos de la propiedad para futuras referencias
      if (!propInfo.fullPath) {
        propInfo.fullPath = propertyKey;
      }
    }

    // Función para eliminar una propiedad de un nodo
    function removePropertyFromNode(nodeId, propertyId) {
      if (nodeProperties[nodeId]) {
        nodeProperties[nodeId] = nodeProperties[nodeId].filter(prop => {
          // Comparar como strings para manejar objetos
          return JSON.stringify(prop.id) !== JSON.stringify(propertyId);
        });
        
        // Si no quedan propiedades, eliminar la entrada
        if (nodeProperties[nodeId].length === 0) {
          delete nodeProperties[nodeId];
        }
      }
    }

    // ... existing code ...

    // Actualizar los estilos CSS para las propiedades
    const propertyStyles = `
      .property-item {
        margin-bottom: 8px;
        padding: 8px;
        background-color: var(--surface);
        border: 1px solid var(--border);
        border-radius: 4px;
      }
      
      .property-hierarchy {
        font-size: 0.8em;
        color: var(--text-light);
        margin-bottom: 4px;
      }
      
      .property-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
      }
      
      .property-key {
        font-weight: bold;
        color: var(--primary);
        margin-right: 8px;
        flex: 0 0 auto;
      }
      
      .property-value-container {
        flex: 1;
        min-width: 80px;
        margin-right: 8px;
      }
      
      .property-value-input {
        width: 100%;
        padding: 4px 8px;
        border: 1px solid var(--border);
        border-radius: 4px;
        background-color: rgba(255, 255, 255, 0.05);
        color: var(--text);
        font-size: 0.9em;
      }
      
      .property-value-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 2px rgba(101, 184, 196, 0.2);
      }
      
      .remove-property {
        background: none;
        border: none;
        color: var(--text-light);
        cursor: pointer;
        padding: 2px 6px;
        border-radius: 50%;
        flex: 0 0 auto;
      }
      
      .remove-property:hover {
        background-color: var(--error);
        color: white;
      }
    `;

    // Aplicar los estilos
    function applyPropertyStyles() {
      let styleElement = document.getElementById('property-styles');
      if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = 'property-styles';
        styleElement.textContent = propertyStyles;
        document.head.appendChild(styleElement);
      }
    }

    // Llamar a esta función al inicio
    document.addEventListener('DOMContentLoaded', function() {
      applyPropertyStyles();
    });

    // ... existing code ...

    // Modificar la función highlightPropertyInTree para abrir el panel de propiedades si está cerrado
    function highlightPropertyInTree(propertyId) {
      // Primero, verificar si el panel de propiedades está visible
      const propsPanel = document.getElementById('props-panel');
      const isVisible = propsPanel.classList.contains('visible');
      
      // Si el panel no está visible, abrirlo primero
      if (!isVisible) {
        document.getElementById('toggle-props-panel').click();
        
        // Pequeña pausa para permitir que la animación de apertura comience
        setTimeout(() => {
          // Continuar con el resaltado después de abrir el panel
          performPropertyHighlight(propertyId);
        }, 300); // Tiempo suficiente para que comience la animación de apertura
      } else {
        // Si ya está visible, resaltar inmediatamente
        performPropertyHighlight(propertyId);
      }
    }

    // Función auxiliar que realiza el resaltado real
    function performPropertyHighlight(propertyId) {
      // Primero, eliminar cualquier resaltado previo
      document.querySelectorAll('.prop-item-header.highlighted').forEach(item => {
        item.classList.remove('highlighted');
      });
      
      // Buscar el elemento de la propiedad en el árbol
      let propHeader;
      
      // Si el propertyId es un objeto, convertirlo a string para comparar
      const propIdStr = typeof propertyId === 'object' ? JSON.stringify(propertyId) : propertyId;
      
      // Buscar por el atributo data-id
      document.querySelectorAll('.prop-item-header').forEach(header => {
        const headerId = header.dataset.id;
        if (headerId === propIdStr || JSON.stringify(headerId) === propIdStr) {
          propHeader = header;
        }
      });
      
      if (propHeader) {
        // Resaltar la propiedad
        propHeader.classList.add('highlighted');
        
        // Expandir los padres si están colapsados
        let parent = propHeader.closest('.prop-children');
        while (parent) {
          if (!parent.classList.contains('visible')) {
            // Encontrar el toggle del padre y hacer clic en él
            const parentItem = parent.closest('.prop-item');
            if (parentItem) {
              const toggle = parentItem.querySelector('.prop-toggle');
              if (toggle && toggle.textContent === '▶') {
                toggle.click();
              }
            }
          }
          parent = parent.parentElement ? parent.parentElement.closest('.prop-children') : null;
        }
        
        // Desplazarse hasta la propiedad
        propHeader.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // Añadir un efecto de parpadeo para llamar la atención
        propHeader.style.animation = 'highlight-pulse 1.5s ease-in-out';
        setTimeout(() => {
          propHeader.style.animation = '';
        }, 1500);
      }
    }

    // ... existing code ...

    // Añadir estilos CSS para el resaltado
    const highlightStyles = `
      .prop-item-header.highlighted {
        background-color: rgba(101, 184, 196, 0.3);
        border-left: 3px solid var(--primary);
      }
      
      @keyframes highlight-pulse {
        0% { background-color: rgba(101, 184, 196, 0.3); }
        50% { background-color: rgba(101, 184, 196, 0.6); }
        100% { background-color: rgba(101, 184, 196, 0.3); }
      }
      
      .property-item {
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      
      .property-item:hover {
        transform: translateX(3px);
        background-color: var(--surface-hover);
      }
      
      .property-item:active {
        transform: translateX(1px);
      }
    `;

    // Aplicar los estilos
    function applyPropertyStyles() {
      let styleElement = document.getElementById('property-styles');
      if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = 'property-styles';
        styleElement.textContent = propertyStyles + highlightStyles;
        document.head.appendChild(styleElement);
      }
    }

    // ... existing code ...
  </script>

  <script>
    // Este script se ejecutará cuando la página se haya cargado completamente
    document.addEventListener('DOMContentLoaded', function() {
      const asciiArt = `
                                                                  ###
                                                                  ###    
                                                                   
#############               #####       ##########  ########   ########  #######                 ######  ######    ########       #####  #  
    #####                 #########        #####      ##          ###       #####               ####       ####       ####      ##########  
    #####               ###     #####        ####   ##            ###       ######             #####       ####       ####     ###      ##  
    #####              #####     ###          #####               ###       #######           ######       ####       ####     ########    
    #####              ###########             #####              ###       ## #####         ## ####       ####       ####       ##########  
    #####              ##### ###              ########            ###       ##  #####       ##  ####       ####       ####    ##   #########   
    #####              #####       ##        ##    #####          ###       ##   #####     ##   ####       ####       ####    ###        ##   
    #####               #####     ###      ###       #####        ###       ##    #####   ##    ####        ###############   #####     ###    
    #####                 #########    ########   ##########   ########     ##     ##### ##     ####         #######  ######  ## #########  
    #####            ##      ###                                            ##      ######      #### 
    #####            ##                                                     ##       ####       ####  
    #####           ###                                                     ##        ##        #### 
    #####          ####                                                     ##                  #### 
######################                                                   #########           ##########
 
`;

      const container = document.getElementById('ascii-container');
      const customCursor = document.getElementById('custom-cursor');
      
      // Asegurarnos de que el contenedor puede recibir drops
      container.setAttribute('droppable', 'true');
      
      // Eventos de arrastre mejorados
      container.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        container.classList.add('drop-target');
      });

      container.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        container.classList.remove('drop-target');
      });

      container.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        container.classList.remove('drop-target');
        
        console.log('Drop detectado en el logo'); // Debug
        
        const nodeId = e.dataTransfer.getData('text/plain');
        console.log('Node ID recibido:', nodeId); // Debug
        
        if (nodeId) {
          showTaxonomyButton(nodeId);
        }
      });
      
      // Actualizar el contenido del cursor personalizado con espacios adecuados
      customCursor.innerHTML = `
              @@@@@@@      
                 @         
                 @         
                 @         
               @@@@@       
                 @         
                 @         
                 @                 
              @@@@@@@`;
    
      // Procesar cada carácter del logo ASCII
      let htmlContent = '';
      for (let i = 0; i < asciiArt.length; i++) {
        const char = asciiArt[i];
        if (char === '\n') {
          htmlContent += '<br>';
        } else {
          htmlContent += `<span class="ascii-char" data-original="${char}">${char}</span>`;
        }
      }
      
      container.innerHTML = htmlContent;
      
      // Obtener todos los caracteres
      const chars = document.querySelectorAll('.ascii-char');
      const charPositions = []; // Pre-calcular las posiciones iniciales
      const containerRect = container.getBoundingClientRect();
      
      // Almacenar las posiciones iniciales para mejorar el rendimiento
      chars.forEach(char => {
        const rect = char.getBoundingClientRect();
        charPositions.push({
          x: rect.left + rect.width/2 - containerRect.left,
          y: rect.top + rect.height/2 - containerRect.top,
          elem: char
        });
      });
      
      // Configuración
      // const effectRadius = 40;   // Radio de influencia del cursor - ELIMINADO
      let ticking = false;       // Para limitar las actualizaciones de renderizado
      let lastMoveEvent = null;  // Almacenar el último evento de movimiento
      
      // Configuración del cursor parpadeante
      let cursorVisible = true;
      setInterval(() => {
        if (lastMoveEvent) { // Solo parpadea cuando el mouse está dentro
          cursorVisible = !cursorVisible;
          customCursor.style.opacity = cursorVisible ? 1 : 0.6;
        }
      }, 700); // Intervalo de parpadeo (700ms)
      
      // Función para actualizar el efecto visual (sin movimiento de imán)
      function updateVisualEffect() {
        if (!lastMoveEvent) return;
        
        // Calcular la posición relativa del cursor dentro del contenedor
        const containerRect = container.getBoundingClientRect();
        const mouseX = lastMoveEvent.clientX - containerRect.left;
        const mouseY = lastMoveEvent.clientY - containerRect.top;
        
        // Mostrar y posicionar el cursor personalizado
        customCursor.style.display = 'block';
        customCursor.style.left = `${mouseX}px`;
        customCursor.style.top = `${mouseY}px`;
        
        // Actualizar solo el color y el contenido de los caracteres cercanos
        charPositions.forEach(charPos => {
          const char = charPos.elem;
          
          // Calcular distancia entre el carácter y el cursor
          const distX = mouseX - charPos.x;
          const distY = mouseY - charPos.y;
          
          // Quitar la lógica basada en el radio de efecto
          // Cambiar el carácter a @ o % aleatoriamente (sin condición de distancia)
          char.textContent = Math.random() > 0.5 ? '@' : '%';
          
          // Aplicar un color fijo sin depender de la distancia
          char.style.color = '#65b8c4';
        });
        
        ticking = false;
      }
      
      // Manejar el movimiento del mouse de manera eficiente
      container.addEventListener('mousemove', function(e) {
        lastMoveEvent = e;
        
        if (!ticking) {
          window.requestAnimationFrame(updateVisualEffect);
          ticking = true;
        }
      });
      
      // Restaurar cuando el cursor sale del contenedor
      container.addEventListener('mouseleave', function() {
        lastMoveEvent = null;
        customCursor.style.display = 'none';
        
        chars.forEach(char => {
          // Restaurar el carácter original
          const originalChar = char.getAttribute('data-original');
          char.textContent = originalChar;
          char.style.color = '#65b8c4';
        });
      });

      // Variables para el contador de clics y el estado del color
      let clickCount = 0;
      let isComplementaryColor = false;
      const originalColor = '#65b8c4';
      const complementaryColor = '#c4715b'; // Color complementario del azul original

      // Función para cambiar el color de todo el ASCII art
      function toggleComplementaryColor() {
        const chars = document.querySelectorAll('.ascii-char');
        chars.forEach(char => {
          char.style.color = isComplementaryColor ? originalColor : complementaryColor;
        });
        isComplementaryColor = !isComplementaryColor;
      }

      // Agregar el evento de clic al contenedor
      container.addEventListener('click', function() {
        clickCount++;
        
        // Si alcanzamos 4 clics
        if (clickCount === 4) {
          toggleComplementaryColor();
          clickCount = 0; // Reiniciar el contador
        }

        // Agregar un pequeño efecto visual para feedback
        container.style.transform = 'scale(0.98)';
        setTimeout(() => {
          container.style.transform = 'scale(1)';
        }, 100);
      });

      // Modificar la función updateVisualEffect para mantener el color complementario
      function updateVisualEffect() {
        if (!lastMoveEvent) return;
        
        const containerRect = container.getBoundingClientRect();
        const mouseX = lastMoveEvent.clientX - containerRect.left;
        const mouseY = lastMoveEvent.clientY - containerRect.top;
        
        customCursor.style.display = 'block';
        customCursor.style.left = `${mouseX}px`;
        customCursor.style.top = `${mouseY}px`;
        
        charPositions.forEach(charPos => {
          const char = charPos.elem;
          char.textContent = Math.random() > 0.5 ? '@' : '%';
          
          // Usar el color actual según el estado
          char.style.color = isComplementaryColor ? complementaryColor : originalColor;
        });
        
        ticking = false;
      }

      // Modificar el evento mouseleave para respetar el color actual
      container.addEventListener('mouseleave', function() {
        lastMoveEvent = null;
        customCursor.style.display = 'none';
        
        chars.forEach(char => {
          const originalChar = char.getAttribute('data-original');
          char.textContent = originalChar;
          // Mantener el color según el estado actual
          char.style.color = isComplementaryColor ? complementaryColor : originalColor;
        });
      });
    });
  </script>

  <style>
    /* Estilos adicionales para el logo ASCII */
    .ascii-logo pre {
      margin: 0;
      font-family: monospace;
      font-size: 5px;  /* Cambiado de 10px a 8px */
      color: #008a9b;
      line-height: 0.8;  /* Ajustado para mejor espaciado vertical */
      white-space: pre;
      letter-spacing: 0;
      cursor: pointer;
    }

    .ascii-logo pre:hover {
      background-image: linear-gradient(to right, 
        #008a9b, #3a7b8c, #5f8a93, #009b8a, #008a9b, 
        #3a7b8c, #5f8a93, #009b8a);
      background-size: 800% 100%;
      color: transparent;
      -webkit-background-clip: text;
      background-clip: text;
      animation: rainbow 3s linear infinite;
    }

    @keyframes rainbow { 
      0% { background-position: 0% 50%; } 
      100% { background-position: 100% 50%; }
    }
  </style>

  <script>
  document.addEventListener('DOMContentLoaded', function() {
    // Cambiar logoElement por container
    const container = document.getElementById('ascii-container');
    
    if (container) { // Verificar que el elemento existe
        container.addEventListener('mouseenter', function() {
            console.log('Mouse entered the logo');
        });
    } else {
        console.error('ASCII container not found');
    }
  });
  </script>

  <script>
  // ... existing code ...

  // Añadir evento para abrir la ventana de ontología
  document.getElementById('open-ontology').addEventListener('click', function() {
    // Guardar el YAML actual en localStorage
    const currentYaml = document.getElementById('data-display').value;
    localStorage.setItem('currentYaml', currentYaml);
    
    // Abrir la ventana de ontología
    window.open('ontology.html', '_blank', 'width=900,height=600');
  });

  // ... existing code ...
  </script>

  <script>
  document.addEventListener('DOMContentLoaded', function() {
    // Mover el contenedor de la lista después del contenedor ASCII
    const asciiContainer = document.getElementById('ascii-container');
    const droppedNodesList = document.createElement('div');
    droppedNodesList.className = 'dropped-nodes-list';
    asciiContainer.after(droppedNodesList);

    // Configurar eventos de drag and drop para el logo
    asciiContainer.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
      asciiContainer.style.backgroundColor = 'rgba(0, 138, 155, 0.2)';
    });

    asciiContainer.addEventListener('dragleave', (e) => {
      e.preventDefault();
      e.stopPropagation();
      asciiContainer.style.backgroundColor = '';
    });

    asciiContainer.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      const draggedId = e.dataTransfer.getData('text/plain');
      const draggedNode = document.querySelector(`[data-id="${draggedId}"]`);
      
      if (draggedNode) {
        // Evitar duplicados
        const existingNode = Array.from(droppedNodesList.children).find(
          item => item.querySelector('.dropped-node-text').textContent === draggedNode.textContent.trim()
        );
        
        if (!existingNode) {
          // Mostrar la lista si está oculta
          droppedNodesList.classList.add('visible');
          
          // Crear el elemento de la lista
          const nodeItem = document.createElement('div');
          nodeItem.className = 'dropped-node-item';
          nodeItem.innerHTML = `
            <div class="dropped-node-text">${draggedNode.textContent.trim()}</div>
            <div class="remove-node">×</div>
          `;
          
          // Añadir evento para remover el nodo de la lista
          nodeItem.querySelector('.remove-node').addEventListener('click', () => {
            nodeItem.style.opacity = '0';
            nodeItem.style.transform = 'scale(0.9)';
            setTimeout(() => {
              nodeItem.remove();
              // Ocultar la lista si está vacía
              if (droppedNodesList.children.length === 0) {
                droppedNodesList.classList.remove('visible');
              }
            }, 200);
          });
          
          droppedNodesList.appendChild(nodeItem);
        }
      }
      
      asciiContainer.style.backgroundColor = '';
    });
  });
  </script>

  </script>

  <script>
  // ... existing code ...

  // Función auxiliar para verificar si un nodo es descendiente de otro
  function isDescendant(draggedNode, targetNode) {
    let current = targetNode;
    while (current) {
      if (current === draggedNode) return true;
      const parentId = current.getAttribute('data-parent');
      if (!parentId || parentId === 'null') break;
      current = document.querySelector(`[data-id="${parentId}"]`);
    }
    return false;
  }

  // ... existing code ...
  </script>

  <style>
  /* Estilos para el ASCII art */
  .ascii-art {
    font-family: monospace;
    white-space: pre;
    line-height: 1;
    font-size: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 3rem;  /* Añadido espacio inferior */
    padding-bottom: 2rem; /* Padding adicional */
    border-bottom: 1px solid rgba(101, 184, 196, 0.2); /* Línea separadora sutil */
  }

  .ascii-line {
    display: inline-block;
  }

  /* Paleta de colores basada en el tema principal */
  .color-1 { color: #65b8c4; }         /* Color principal */
  .color-2 { color: #4a9ba7; }         /* Variación más oscura */
  .color-3 { color: #80c5cf; }         /* Variación más clara */
  .color-4 { color: #3d8591; }         /* Variación aún más oscura */
  .color-5 { color: #9ad2da; }         /* Variación aún más clara */
  </style>

  <div class="ascii-art">

    <p>
      <span class="color-4">#############              #####       ##########  ########   ########  #######                 ######  ######    ########       #####  #</span>
      <span class="color-1">   #####                 #########        #####      ##          ###       #####               ####       ####       ####      ##########</span>
      <span class="color-2">   #####               ###     #####        ####   ##            ###       ######             #####       ####       ####     ###      ##</span>
      <span class="color-3">   #####              #####     ###          #####               ###       #######           ######       ####       ####     ########</span>
      <span class="color-4">   #####              ###########             #####              ###       ## #####         ## ####       ####       ####       ##########</span>
      <span class="color-5">   #####              ##### ###              ########            ###       ##  #####       ##  ####       ####       ####    ##   #########</span>
      <span class="color-1">   #####              #####       ##        ##    #####          ###       ##   #####     ##   ####       ####       ####    ###        ##</span>
      <span class="color-2">   #####               #####     ###      ###       #####        ###       ##    #####   ##    ####        ###############   #####     ###</span>
      <span class="color-3">   #####                 #########    ########   ##########   ########     ##     ##### ##     ####         #######  ######  ## #########</span>
      <span class="color-4">   #####                    ###                                            ##      ######      ####</span>
      <span class="color-5">   #####             ##                                                    ##       ####       ####</span>
      <span class="color-1">   #####             ##                                                    ##        ##        ####</span>
      <span class="color-2">   #####           ####                                                    ##                  ####</span>
      <span class="color-2">   #####          #####                                                  ######               ######</span>
      <span class="color-3">######################</span>
    </p>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', function() {
    // Función para asignar colores aleatorios a las líneas del ASCII art
    function randomizeColors() {
      const colors = ['color-1', 'color-2', 'color-3', 'color-4', 'color-5'];
      const lines = document.querySelectorAll('.ascii-art span');
      
      lines.forEach(line => {
        // Remover clases de color existentes
        colors.forEach(color => line.classList.remove(color));
        // Asignar color aleatorio
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        line.classList.add(randomColor);
      });
    }

    // Cambiar colores cada 3 segundos
    setInterval(randomizeColors, 3000);
  });
  </script>

  <script>
  // ... existing code ...

  // Nueva función para mostrar un indicador breve de libertad de scroll
  function showScrollFreedomIndicator() {
    // Crear el indicador si no existe
    let indicator = document.querySelector('.scroll-indicator');
    if (!indicator) {
      indicator = document.createElement('div');
      indicator.className = 'scroll-indicator';
      indicator.textContent = 'Cargando...';
      document.body.appendChild(indicator);
    }
    
    // Mostrar el indicador
    indicator.classList.add('visible');
    
    // Ocultar después de 3 segundos
    setTimeout(() => {
      indicator.classList.remove('visible');
    }, 3000);
  }

  // Asegurar que no haya eventos que bloqueen el scroll natural
  document.addEventListener('DOMContentLoaded', function() {
    // Remover cualquier evento de rueda que pudiera interferir
    const nodesContainer = document.getElementById('nodes-container');
    if (nodesContainer) {
      // Garantizar que el scroll de la rueda no sea cancelado
      nodesContainer.addEventListener('wheel', function(e) {
        // Permitir que el evento de la rueda se propague naturalmente
        e.stopPropagation();
      }, { passive: true });
    }
  });
  </script>

  <script>
  // ... existing code ...

  document.addEventListener('DOMContentLoaded', function() {
    // Añadir evento de drop al contenedor del logo
    const logoContainer = document.getElementById('ascii-container');
    
    logoContainer.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
      logoContainer.classList.add('drop-target');
    });

    logoContainer.addEventListener('dragleave', () => {
      logoContainer.classList.remove('drop-target');
    });

    logoContainer.addEventListener('drop', (e) => {
      e.preventDefault();
      logoContainer.classList.remove('drop-target');
      
      const nodeId = e.dataTransfer.getData('text/plain');
      if (nodeId) {
        showTaxonomyButton(nodeId);
      }
    });
  });

  // Función para mostrar el botón de visualización
  function showTaxonomyButton(nodeId) {
    console.log('Mostrando botón para nodo:', nodeId); // Debug
    
    // Eliminar botón existente si hay uno
    const existingButton = document.getElementById('view-taxonomy-btn');
    if (existingButton) {
      existingButton.remove();
    }

    // Crear y mostrar el botón
    const button = document.createElement('button');
    button.id = 'view-taxonomy-btn';
    button.textContent = 'Visualizar taxonomía';
    button.className = 'taxonomy-button';
    
    // Posicionar el botón cerca del logo
    const logoContainer = document.getElementById('ascii-container');
    logoContainer.appendChild(button);

    // Añadir evento de clic
    button.addEventListener('click', () => {
      console.log('Botón clickeado para nodo:', nodeId); // Debug
      generateAndShowTaxonomy(nodeId);
    });

    // Animar entrada del botón
    requestAnimationFrame(() => {
      button.classList.add('visible');
    });
  }

  // Función para generar y mostrar el YAML
  function generateAndShowTaxonomy(nodeId) {
    console.log('Generando taxonomía para nodo:', nodeId); // Debug
    
    const node = document.querySelector(`.pyramid-node[data-id="${nodeId}"]`);
    if (!node) {
      console.error('No se encontró el nodo:', nodeId);
      return;
    }

    // Generar el YAML desde el nodo
    const yamlData = generateYamlFromNode(node);
    console.log('YAML generado:', yamlData); // Debug

    // Actualizar el panel YAML
    const dataDisplay = document.getElementById('data-display');
    const formatSelector = document.getElementById('format-selector');
    
    // Asegurar que estamos en formato YAML
    formatSelector.value = 'yaml';
    dataDisplay.value = yamlData;

    // Mostrar el panel si está oculto
    const panel = document.getElementById('yaml-json-panel');
    if (!panel.classList.contains('visible')) {
      document.getElementById('toggle-panel').click();
    }
  }

  // Función mejorada para generar YAML desde un nodo
  function generateYamlFromNode(node, level = 0) {
    const indent = '  '.repeat(level);
    const nodeName = node.textContent.trim();
    const nodeId = node.getAttribute('data-id');
    let yaml = '';

    // Si es el primer nivel, añadir el título principal
    if (level === 0) {
      yaml += `${nodeName}:\n`;
    } else {
      // Para los demás niveles, usar formato de lista
      yaml += `${indent}- ${nodeName}`;
    }

    // Verificar si tiene hijos
    const children = document.querySelectorAll(`.pyramid-node[data-parent="${nodeId}"]`);
    
    // Si tiene metadatos, propiedades o hijos, añadir dos puntos y nueva línea
    const hasMetadata = nodeMetadata[nodeId] && Object.keys(nodeMetadata[nodeId]).length > 0;
    const hasProperties = nodeProperties[nodeId] && nodeProperties[nodeId].length > 0;
    
    if ((hasMetadata || hasProperties || children.length > 0) && level > 0) {
      yaml += ':\n';
    } else if (level > 0) {
      yaml += '\n';
    }

    // Añadir metadatos si existen
    if (hasMetadata) {
      yaml += `${indent}  metadata:\n`;
      for (const [key, value] of Object.entries(nodeMetadata[nodeId])) {
        yaml += `${indent}    ${key}: ${value}\n`;
      }
    }

    // Añadir propiedades si existen
    if (hasProperties) {
      yaml += `${indent}  properties:\n`;
      nodeProperties[nodeId].forEach(prop => {
        yaml += `${indent}    - ${prop.fullPath}: ${prop.value || ''}\n`;
      });
    }

    // Procesar nodos hijos
    if (children.length > 0) {
      // No añadir "children:" explícitamente, los hijos van directamente como lista
      children.forEach(child => {
        yaml += generateYamlFromNode(child, level + 1);
      });
    }

    return yaml;
  }

  // Estilos CSS mejorados
  const taxonomyStyles = `
    .taxonomy-button {
      position: absolute;
      bottom: -50px;
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      padding: 10px 20px;
      background-color: #65b8c4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
      font-size: 14px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .taxonomy-button.visible {
      opacity: 1;
      transform: translateX(-50%) scale(1);
    }

    .taxonomy-button:hover {
      background-color: #4a8f99;
      transform: translateX(-50%) scale(1.05);
    }

    #ascii-container {
      position: relative;
      min-height: 100px;
    }

    #ascii-container.drop-target {
      outline: 2px dashed #65b8c4;
      outline-offset: 4px;
      background-color: rgba(101, 184, 196, 0.1);
    }
  `;

  // Asegurarnos de que los estilos se aplican
  if (!document.getElementById('taxonomy-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'taxonomy-styles';
    styleElement.textContent = taxonomyStyles;
    document.head.appendChild(styleElement);
  }

  // ... existing code ...
  </script>

  <script>
  document.addEventListener('click', function(e) {
    // Verificar si el clic fue fuera del nodo y del panel de información
    const clickedNode = e.target.closest('.pyramid-node');
    const clickedInfoPanel = e.target.closest('#info-panel');
    const clickedMetadataEditor = e.target.closest('#metadata-editor');
    
    // Si no se hizo clic en un nodo, en el panel de información o en el editor de metadatos
    if (!clickedNode && !clickedInfoPanel && !clickedMetadataEditor) {
      // Obtener el panel de información
      const infoPanel = document.getElementById('info-panel');
      
      // Si el panel está expandido, retraerlo
      if (infoPanel && infoPanel.classList.contains('expanded')) {
        // Remover la clase focused del nodo actualmente seleccionado
        const focusedNode = document.querySelector('.pyramid-node.focused');
        if (focusedNode) {
          focusedNode.classList.remove('focused');
        }
        
        // Retraer el panel
        infoPanel.classList.remove('expanded');
        
        // Limpiar el contenido del panel
        document.getElementById('node-id').textContent = '-';
        document.getElementById('node-text').textContent = '-';
        document.getElementById('node-parent').textContent = '-';
        document.getElementById('properties-list').innerHTML = '';
        document.getElementById('metadata-cards').innerHTML = '';
        
        // Si el editor de metadatos está visible, ocultarlo
        const metadataEditor = document.getElementById('metadata-editor');
        if (metadataEditor && metadataEditor.classList.contains('visible')) {
          metadataEditor.classList.remove('visible');
        }
      }
    }
  });
  </script>

</body>
</html>