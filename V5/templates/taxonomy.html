<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualizador de Taxonomía</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    
    .container {
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .top-bar {
      background-color: #333;
      color: white;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 60px;
      box-sizing: border-box;
    }
    
    .top-bar h1 {
      margin: 0;
      font-size: 1.5rem;
    }
    
    .controls {
      display: flex;
      gap: 10px;
    }
    
    .controls button, .controls select {
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
    }
    
    .main-content {
      display: flex;
      flex-direction: row;
      align-items: stretch;
      overflow: hidden;
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    .YAML-JSON {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      overflow: hidden;
      transition: width 0.3s ease;
      flex-shrink: 0;
      background-color: white;
      z-index: 10;
    }
    
    .YAML-JSON.visible {
      width: 40%;
      min-width: 300px;
      max-width: 500px;
    }
    
    .nodes-container {
      flex-grow: 1;
      overflow: auto;
      transition: margin-left 0.3s ease;
      width: 100%;
      position: relative;
    }
    
    .toggle-panel {
      position: fixed;
      top: 50%;
      left: 10px;
      width: 40px;
      height: 40px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .toggle-props-panel {
      position: fixed;
      top: 50%;
      right: 10px;
      width: 40px;
      height: 40px;
      background-color: #333;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .toggle-panel:hover, .toggle-props-panel:hover {
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      transition: all 0.2s ease;
    }
    
    /* Estilos para la visualización de nodos */
    .pyramid-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
      padding: 40px 20px;
      width: 100%;
      box-sizing: border-box;
    }
    
    .pyramid-level {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 20px;
      width: 100%;
      padding: 0 10px;
    }
    
    /* Contenedor para un nodo y sus hijos */
    .node-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }
    
    /* Contenedor para los hijos de un nodo */
    .children-container {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(0,0,0,0.05);
      border-radius: 8px;
      max-width: 300px;
      overflow-y: auto;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    .children-container.visible {
      display: flex;
      animation: fadeIn 0.3s ease;
    }
    
    /* Estilos para nodos colapsados/expandidos */
    .pyramid-node.collapsed::after {
      content: "▶";
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    .pyramid-node.expanded::after {
      content: "▼";
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    .pyramid-node {
      padding: 12px 20px;
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      min-width: 100px;
      max-width: 150px;
      word-wrap: break-word;
      flex-shrink: 0;
      position: relative;
      /* Eliminar tabindex para evitar que los nodos reciban foco con Tab */
      outline: none;
    }
    
    /* Nodos minimizados (subnodos cuando su padre no está activo) */
    .pyramid-node.minimized {
      transform: scale(0.8);
      opacity: 0.7;
      filter: saturate(0.7);
    }
    
    /* Estilos para los diferentes tipos de nodos */
    .pyramid-node.main {
      background-color: #2196F3; /* Azul para el nodo principal */
      color: white;
    }
    
    .pyramid-node.category {
      background-color: #4CAF50; /* Verde para categorías */
      color: white;
    }
    
    .pyramid-node.subcategory {
      background-color: #FF9800; /* Naranja para subcategorías */
      color: white;
    }
    
    .pyramid-node.example {
      background-color: #9C27B0; /* Púrpura para ejemplos */
      color: white;
    }
    
    /* Nodo actualmente seleccionado/enfocado */
    .pyramid-node.focused {
      transform: scale(1.1);
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 5;
      background-color: #1976D2; /* Azul más oscuro para el nodo enfocado */
      border: 3px solid #0D47A1; /* Borde azul oscuro */
      color: white;
      font-weight: bold;
    }
    
    /* Efecto de brillo para el nodo enfocado */
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(25, 118, 210, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(25, 118, 210, 0); }
      100% { box-shadow: 0 0 0 0 rgba(25, 118, 210, 0); }
    }
    
    .pyramid-node.focused {
      animation: pulse 2s infinite;
    }
    
    /* Hijos directos del nodo activo */
    .pyramid-node.active-child {
      transform: scale(1);
      opacity: 1;
      filter: saturate(1);
      box-shadow: 0 3px 7px rgba(0,0,0,0.25);
    }
    
    /* Indicador visual para nodos con hijos */
    .pyramid-node.has-children::after {
      content: "▼";
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    textarea {
      width: 100%;
      height: 70%;
      font-family: monospace;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
      resize: none;
    }
    
    #update-visualization {
      margin-top: 10px;
      padding: 8px 15px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    /* Estilos para pantallas pequeñas */
    @media (max-width: 768px) {
      .pyramid-node {
        min-width: 80px;
        padding: 10px 15px;
        font-size: 14px;
      }
      
      .pyramid-level {
        gap: 15px;
      }
    }
    
    /* Indicadores de navegación */
    .navigation-indicator {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0.7;
    }
    
    .indicator-left {
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .indicator-right {
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .indicator-up {
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .indicator-down {
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    /* Estilos para el indicador de más nodos */
    .more-nodes-indicator {
      background-color: #607D8B;
      color: white;
      padding: 8px 15px;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 10px;
      display: inline-block;
      font-size: 0.9em;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .more-nodes-indicator:hover {
      background-color: #455A64;
      transform: scale(1.05);
    }
    
    /* Contenedor para los nodos ocultos */
    .hidden-nodes-container {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(0,0,0,0.05);
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .hidden-nodes-container.visible {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .pyramid-node.hidden {
      display: none;
    }
    
    .children-navigation {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      gap: 5px;
    }
    
    .nav-prev, .nav-next {
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .nav-prev:disabled, .nav-next:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .nav-indicator {
      font-size: 12px;
      color: #666;
    }
    
    /* Estilos para el panel de información con tarjetas de metadatos */
    .info-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #333;
      color: white;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      height: 40px;
      box-sizing: border-box;
      z-index: 30;
      font-size: 14px;
      transition: height 0.3s ease, left 0.3s ease, width 0.3s ease;
      overflow: hidden;
    }
    
    .info-panel.expanded {
      height: 250px; /* Aumentado para dar más espacio */
      overflow-y: auto; /* Permitir scroll cuando está expandido */
      align-items: flex-start; /* Asegurar que el contenido comience desde arriba */
    }
    
    .info-panel-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      padding-bottom: 15px; /* Añadir espacio en la parte inferior */
    }
    
    .info-basic {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap; /* Permitir que los elementos se envuelvan en pantallas pequeñas */
      margin-bottom: 5px; /* Espacio antes de las tarjetas */
    }
    
    .info-label {
      font-weight: bold;
      color: #4CAF50;
    }
    
    /* Estilos para las tarjetas de metadatos */
    .metadata-cards-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
      overflow-y: visible; /* Cambiar a visible para evitar cortes */
      max-height: 160px; /* Aumentar altura máxima */
      padding-bottom: 10px; /* Espacio adicional en la parte inferior */
    }
    
    .metadata-card {
      background-color: #444;
      border-radius: 5px;
      padding: 8px 12px;
      min-width: 150px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
    }
    
    .metadata-card-title {
      font-weight: bold;
      color: #4CAF50;
      margin-bottom: 5px;
      font-size: 12px;
    }
    
    .metadata-card-content {
      font-size: 13px;
      color: #fff;
    }
    
    .add-metadata-card {
      background-color: #555;
      border: 2px dashed #777;
      border-radius: 5px;
      padding: 8px 12px;
      min-width: 150px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #aaa;
    }
    
    .add-metadata-card:hover {
      background-color: #666;
      color: white;
    }
    
    .metadata-editor {
      width: 100%;
      display: none;
    }
    
    .metadata-editor.visible {
      display: block;
    }
    
    .metadata-form {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .metadata-input-group {
      display: flex;
      gap: 10px;
    }
    
    .metadata-input {
      flex: 1;
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    
    .metadata-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    
    .edit-button, .save-button, .cancel-button {
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 5px 10px;
      cursor: pointer;
    }
    
    .cancel-button {
      background-color: #f44336;
    }
    
    .edit-button:hover, .save-button:hover {
      background-color: #45a049;
    }
    
    .cancel-button:hover {
      background-color: #d32f2f;
    }
    
    .pyramid-node.pinned {
      border: 3px solid #FFD700 !important; /* Borde dorado para el nodo fijado */
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.7) !important; /* Sombra dorada */
      z-index: 10 !important; /* Asegurar que esté por encima de otros nodos */
    }
    
    .pyramid-node.pinned::before {
      content: "📌";
      position: absolute;
      top: -10px;
      right: -10px;
      font-size: 12px;
      background-color: #FFD700;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    
    .pyramid-node.secondary-pinned::before {
      content: "📌";
      position: absolute;
      top: -10px;
      right: -10px;
      font-size: 12px;
      background-color: #1E90FF;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    
    /* Estilos para el desplazamiento del contenedor de nodos */
    .nodes-container {
      transition: margin-left 0.3s ease;
    }
    
    .nodes-container.shifted {
      margin-left: 0; /* El panel YAML-JSON tiene su propio espacio */
    }
    
    /* Ajustar el diseño para evitar superposiciones */
    .main-content {
      display: flex;
      flex-direction: row;
      align-items: stretch;
      overflow: hidden;
    }
    
    .YAML-JSON {
      width: 0;
      overflow: hidden;
      transition: width 0.3s ease;
      flex-shrink: 0;
    }
    
    .YAML-JSON.visible {
      width: 40%; /* Ancho del panel cuando está visible */
      min-width: 300px;
      max-width: 500px;
    }
    
    .nodes-container {
      flex-grow: 1;
      overflow: auto;
      transition: margin-left 0.3s ease;
    }
    
    /* Asegurar que el botón de alternar siempre esté visible */
    .toggle-panel {
      position: absolute;
      left: 10px;
      top: 10px;
      z-index: 1000;
    }
    
    /* Estilos para el panel de propiedades */
    .props-panel {
      width: 0;
      overflow: hidden;
      transition: width 0.3s ease;
      flex-shrink: 0;
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      background-color: #f5f5f5;
      z-index: 100;
      box-shadow: -2px 0 10px rgba(0,0,0,0.1);
      padding: 0;
      box-sizing: border-box;
    }
    
    .props-panel.visible {
      width: 40%;
      min-width: 300px;
      max-width: 500px;
      padding: 20px;
    }
    
    .toggle-props-panel {
      position: fixed;
      right: 10px;
      top: 10px;
      z-index: 1001;
      background-color: #333;
      color: white;
      border: none;
      border-radius: 4px;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .toggle-props-panel:hover {
      background-color: #555;
    }
    
    .main-content.props-panel-visible .nodes-container {
      margin-right: 40%;
      width: 60%;
    }
    
    /* Cuando ambos paneles están visibles */
    .main-content.panel-visible.props-panel-visible .nodes-container {
      margin-left: 40%;
      margin-right: 40%;
      width: 20%;
    }
    
    /* Estilos para la visualización del árbol de propiedades */
    #props-tree {
      overflow: auto;
      max-height: calc(100% - 50px);
    }
    
    .prop-item {
      margin-bottom: 8px;
      padding: 8px;
      border-radius: 4px;
      background-color: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .prop-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      font-weight: bold;
    }
    
    .prop-children {
      margin-left: 20px;
      padding-left: 10px;
      border-left: 2px solid #ddd;
      margin-top: 8px;
      display: none;
    }
    
    .prop-children.visible {
      display: block;
    }
    
    .prop-toggle {
      margin-right: 5px;
      display: inline-block;
      width: 12px;
      height: 12px;
      text-align: center;
      line-height: 12px;
    }
    
    .prop-id {
      color: #666;
      font-size: 0.8em;
      margin-left: 10px;
    }
    
    .prop-value {
      color: #28a745;
      font-style: italic;
    }
    
    @media (max-width: 1200px) {
      .props-panel.visible {
        width: 350px;
        min-width: 300px;
      }
      
      .main-content.props-panel-visible .nodes-container {
        margin-right: 350px;
        width: calc(100% - 350px);
      }
      
      .main-content.panel-visible.props-panel-visible .nodes-container {
        margin-left: 350px;
        margin-right: 350px;
        width: calc(100% - 700px);
      }
    }
    
    .metadata-card.focused-card {
      transform: scale(1.05);
      box-shadow: 0 0 0 2px #4CAF50, 0 4px 8px rgba(0,0,0,0.3) !important;
      transition: all 0.2s ease;
    }
    
    /* Añadir navegación con teclado entre tarjetas */
    .metadata-card:focus {
      outline: none;
      box-shadow: 0 0 0 2px #4CAF50, 0 4px 8px rgba(0,0,0,0.3);
    }
    
    /* Ajustar el panel de información cuando el panel YAML está visible */
    .main-content.panel-visible + .info-panel {
      left: 40%; /* Debe coincidir con el ancho del panel YAML */
      width: 60%; /* El resto del espacio disponible */
    }
    
    /* Ajustar para pantallas más pequeñas */
    @media (max-width: 1200px) {
      .main-content.panel-visible + .info-panel {
        left: 350px;
        width: calc(100% - 350px);
      }
    }
    
    /* Ajustar cuando ambos paneles laterales están visibles */
    .main-content.panel-visible.props-panel-visible + .info-panel {
      left: 40%;
      width: 20%;
    }
    
    @media (max-width: 1200px) {
      .main-content.panel-visible.props-panel-visible + .info-panel {
        left: 350px;
        width: calc(100% - 700px);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <h1>Visualizador de Taxonomía</h1>
      <div class="controls">
        <button id="load-data">Cargar Datos</button>
        <select id="format-selector">
          <option value="yaml">YAML</option>
          <option value="json">JSON</option>
        </select>
      </div>
    </div>
    
    <div class="main-content">
      <button class="toggle-panel" id="toggle-panel">≡</button>
      <button class="toggle-props-panel" id="toggle-props-panel">⚙</button>
      
      <div class="YAML-JSON" id="yaml-json-panel">
        <h2>Datos en formato <span id="current-format">YAML</span></h2>
        <textarea id="data-display"></textarea>
        <button id="update-visualization">Actualizar Visualización</button>
      </div>
      
      <div class="nodes-container" id="nodes-container">
        <div id="node-visualization">
          <!-- La visualización se generará aquí dinámicamente -->
        </div>
      </div>
      
      <div class="props-panel" id="props-panel">
        <h2>Jerarquía de Propiedades</h2>
        <div id="props-tree"></div>
      </div>
    </div>
    
    <!-- Panel de información del nodo -->
    <div class="info-panel" id="info-panel">
      <div class="info-panel-content">
        <div class="info-basic">
          <div><span class="info-label">Nodo:</span> <span id="node-name">Ninguno seleccionado</span></div>
          <div><span class="info-label">ID:</span> <span id="node-id">-</span></div>
          <button class="edit-button" id="toggle-metadata">Añadir Metadato</button>
        </div>
        <div class="metadata-editor" id="metadata-editor">
          <div class="metadata-form">
            <div class="metadata-input-group">
              <input type="text" class="metadata-input" id="metadata-key" placeholder="Título (ej: Descripción, Autor, etc.)">
              <input type="text" class="metadata-input" id="metadata-value" placeholder="Valor">
            </div>
            <div class="metadata-actions">
              <button class="save-button" id="save-metadata">Guardar</button>
              <button class="cancel-button" id="cancel-metadata">Cancelar</button>
            </div>
          </div>
        </div>
        <div class="metadata-cards-container" id="metadata-cards-container">
          <!-- Las tarjetas de metadatos se generarán aquí dinámicamente -->
        </div>
      </div>
    </div>
  </div>

  <!-- Incluir la biblioteca js-yaml para procesar YAML -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
  
  <script>
    // Configuración personalizable
    const config = {
      maxVisibleChildren: 6,  // Número máximo de nodos hijos visibles inicialmente
      animationDuration: 300, // Duración de las animaciones en milisegundos
      autoScrollDelay: 100,   // Retraso para el desplazamiento automático
      collapseByDefault: true // Colapsar nodos hijos por defecto
    };
    
    // Datos de ejemplo en formato YAML
    const yamlData = `# Ejemplo de taxonomía en YAML
taxonomia:
  - categoria: Animales
    subcategorias:
      - nombre: Mamíferos
        ejemplos:
          - Perro
          - Gato
          - Elefante
          - León
          - Tigre
          - Oso
          - Jirafa
          - Cebra
          - Rinoceronte
          - Hipopótamo
      - nombre: Aves
        ejemplos:
          - Águila
          - Pingüino
          - Colibrí
          - Búho
          - Pato
          - Gallina
          - Pavo
          - Flamenco
  - categoria: Plantas
    subcategorias:
      - nombre: Árboles
        ejemplos:
          - Roble
          - Pino
          - Sauce
          - Abeto
          - Cedro
          - Arce
          - Olmo
      - nombre: Flores
        ejemplos:
          - Rosa
          - Tulipán
          - Girasol
          - Margarita
          - Orquídea
          - Lirio
          - Clavel
          - Violeta`;

    // Variables globales
    let currentFocusedNode = null;
    // let pinnedNode = null; // Eliminar esta variable
    
    // Objeto para almacenar metadatos de nodos
    const nodeMetadata = {};
    
    // Función para convertir YAML a JSON
    function yamlToJson(yamlString) {
      return jsyaml.load(yamlString);
    }
    
    // Función para convertir JSON a YAML
    function jsonToYaml(jsonObj) {
      return jsyaml.dump(jsonObj);
    }
    
    // Función para generar la visualización de nodos
    function updateNodeVisualization(data) {
      const nodeVisualization = document.getElementById('node-visualization');
      
      try {
        if (typeof data === 'string') {
          // Si es YAML, convertir a JSON
          data = yamlToJson(data);
        }
        
        console.log("Datos procesados:", data);
        
        // Estructura para organizar los nodos por niveles
        const levels = [
          [{ text: 'Taxonomía', type: 'main', parent: null, id: 'root' }], // Nivel 0: Raíz
          [], // Nivel 1: Categorías
          [], // Nivel 2: Subcategorías
          []  // Nivel 3: Ejemplos
        ];
        
        // Procesar categorías (nivel 1)
        if (data.taxonomia && Array.isArray(data.taxonomia)) {
          data.taxonomia.forEach((categoria, catIndex) => {
            levels[1].push({
              text: categoria.categoria,
              type: 'category',
              parent: 'root',
              id: `cat_${catIndex}`
            });
            
            // Procesar subcategorías (nivel 2)
            if (categoria.subcategorias && Array.isArray(categoria.subcategorias)) {
              categoria.subcategorias.forEach((subcategoria, subIndex) => {
                levels[2].push({
                  text: subcategoria.nombre,
                  type: 'subcategory',
                  parent: `cat_${catIndex}`,
                  id: `subcat_${catIndex}_${subIndex}`
                });
                
                // Procesar ejemplos (nivel 3)
                if (subcategoria.ejemplos && Array.isArray(subcategoria.ejemplos)) {
                  subcategoria.ejemplos.forEach((ejemplo, ejIndex) => {
                    levels[3].push({
                      text: ejemplo,
                      type: 'example',
                      parent: `subcat_${catIndex}_${subIndex}`,
                      id: `example_${catIndex}_${subIndex}_${ejIndex}`
                    });
                  });
                }
              });
            }
          });
        }
        
        console.log("Niveles generados:", levels);
        
        // Generar HTML para la visualización
        let html = '<div class="pyramid-container">';
        
        // Para cada nivel (excepto el último que se manejará de forma especial)
        for (let levelIndex = 0; levelIndex < levels.length - 1; levelIndex++) {
          const level = levels[levelIndex];
          
          if (level.length > 0) {
            html += `<div class="pyramid-level" data-level="${levelIndex}">`;
            
            // Agrupar nodos por padre
            const nodesByParent = {};
            level.forEach(node => {
              const parentId = node.parent || 'null';
              if (!nodesByParent[parentId]) {
                nodesByParent[parentId] = [];
              }
              nodesByParent[parentId].push(node);
            });
            
            // Para cada grupo de nodos con el mismo padre
            const possibleParents = Object.keys(nodesByParent);
            possibleParents.forEach(parentId => {
              const children = nodesByParent[parentId] || [];
              
              children.forEach((node, nodeIndex) => {
                const nodeType = node.type;
                const parentAttr = node.parent ? `data-parent="${node.parent}"` : 'data-parent="null"';
                const hasChildren = levels[levelIndex + 1].some(child => child.parent === node.id);
                const collapseClass = hasChildren ? 'collapsed' : '';
                
                // Crear un grupo para el nodo y sus posibles hijos
                html += `<div class="node-group" data-node-id="${node.id}">`;
                
                // El nodo principal
                html += `<div class="pyramid-node ${nodeType} ${collapseClass}" tabindex="0" 
                             data-row="${levelIndex}" data-col="${nodeIndex}" 
                             ${parentAttr} data-id="${node.id}">
                          ${node.text}
                        </div>`;
                
                // Si es el último nivel antes de los ejemplos, añadir contenedor para ejemplos
                if (levelIndex === levels.length - 2) {
                  // Obtener los ejemplos para este nodo
                  const examples = levels[levelIndex + 1].filter(example => example.parent === node.id);
                  
                  if (examples.length > 0) {
                    // Contenedor para ejemplos (inicialmente oculto)
                    html += `<div class="children-container" id="children_${node.id}" data-total-children="${examples.length}" data-visible-start="0">`;
                    
                    // Mostrar todos los ejemplos, pero solo los primeros N visibles inicialmente
                    examples.forEach((example, exIndex) => {
                      const isVisible = exIndex < config.maxVisibleChildren;
                      html += `<div class="pyramid-node ${example.type} ${isVisible ? '' : 'hidden'}" tabindex="0" 
                                   data-row="${levelIndex + 1}" data-col="${exIndex}" 
                                   data-parent="${node.id}" data-id="${example.id}" data-index="${exIndex}">
                                ${example.text}
                              </div>`;
                    });
                    
                    // Añadir controles de navegación si hay más de maxVisibleChildren
                    if (examples.length > config.maxVisibleChildren) {
                      html += `<div class="children-navigation">
                                <button class="nav-prev" disabled>▲</button>
                                <span class="nav-indicator">1-${config.maxVisibleChildren} de ${examples.length}</span>
                                <button class="nav-next">▼</button>
                              </div>`;
                    }
                    
                    html += '</div>'; // Cerrar contenedor de ejemplos
                  }
                }
                
                html += '</div>'; // Cerrar grupo de nodo
              });
            });
            
            html += '</div>'; // Cerrar nivel
          }
        }
        
        html += '</div>'; // Cerrar contenedor principal
        nodeVisualization.innerHTML = html;
        
        console.log("HTML generado:", html);
        
        // Configurar eventos para los nodos
        setupNodeEvents();
        
        // Configurar navegación con teclado
        setupKeyboardNavigation();
        
        // Configurar controles de navegación para contenedores de hijos
        setupChildrenNavigation();
        
        // Mostrar indicadores de navegación si es necesario
        checkForOverflow();
        
      } catch (e) {
        console.error("Error al actualizar la visualización:", e);
        nodeVisualization.innerHTML = '<p>Error al generar la visualización. Verifica el formato de los datos.</p>';
      }
    }
    
    // Función para configurar los controles de navegación en contenedores de hijos
    function setupChildrenNavigation() {
      // Configurar botones de navegación
      document.querySelectorAll('.nav-next').forEach(button => {
        button.addEventListener('click', function() {
          const container = this.closest('.children-container');
          const totalChildren = parseInt(container.getAttribute('data-total-children'));
          let visibleStart = parseInt(container.getAttribute('data-visible-start'));
          
          // Calcular el nuevo índice de inicio
          if (visibleStart + config.maxVisibleChildren < totalChildren) {
            visibleStart++;
            container.setAttribute('data-visible-start', visibleStart);
            
            // Actualizar visibilidad de los nodos
            updateVisibleChildren(container, visibleStart);
            
            // Actualizar estado de los botones
            updateNavigationButtons(container, visibleStart, totalChildren);
          }
        });
      });
      
      document.querySelectorAll('.nav-prev').forEach(button => {
        button.addEventListener('click', function() {
          const container = this.closest('.children-container');
          let visibleStart = parseInt(container.getAttribute('data-visible-start'));
          
          // Calcular el nuevo índice de inicio
          if (visibleStart > 0) {
            visibleStart--;
            container.setAttribute('data-visible-start', visibleStart);
            
            // Actualizar visibilidad de los nodos
            updateVisibleChildren(container, visibleStart);
            
            // Actualizar estado de los botones
            updateNavigationButtons(container, visibleStart, parseInt(container.getAttribute('data-total-children')));
          }
        });
      });
    }
    
    // Función para actualizar la visibilidad de los nodos hijos
    function updateVisibleChildren(container, startIndex) {
      const children = container.querySelectorAll('.pyramid-node');
      const totalChildren = children.length;
      
      // Ocultar todos los nodos
      children.forEach(child => {
        child.classList.add('hidden');
      });
      
      // Mostrar solo los nodos en el rango visible
      for (let i = startIndex; i < Math.min(startIndex + config.maxVisibleChildren, totalChildren); i++) {
        children[i].classList.remove('hidden');
      }
      
      // Actualizar el indicador de navegación
      const endIndex = Math.min(startIndex + config.maxVisibleChildren, totalChildren);
      const indicator = container.querySelector('.nav-indicator');
      if (indicator) {
        indicator.textContent = `${startIndex + 1}-${endIndex} de ${totalChildren}`;
      }
    }
    
    // Función para actualizar el estado de los botones de navegación
    function updateNavigationButtons(container, startIndex, totalChildren) {
      const prevButton = container.querySelector('.nav-prev');
      const nextButton = container.querySelector('.nav-next');
      
      if (prevButton) {
        prevButton.disabled = startIndex === 0;
      }
      
      if (nextButton) {
        nextButton.disabled = startIndex + config.maxVisibleChildren >= totalChildren;
      }
    }
    
    // Función para actualizar el estado visual de los nodos
    function updateNodesVisualState(focusedNodeId = null) {
      // Obtener todos los nodos
      const allNodes = document.querySelectorAll('.pyramid-node');
      
      // Primero, restablecer todos los nodos a su estado minimizado
      allNodes.forEach(node => {
        node.classList.remove('focused', 'active-child', 'pinned', 'secondary-pinned');
        node.classList.add('minimized');
        
        // Restaurar colores originales según el tipo de nodo
        const nodeType = node.classList.contains('main') ? 'main' : 
                         node.classList.contains('category') ? 'category' :
                         node.classList.contains('subcategory') ? 'subcategory' : 'example';
        
        // Marcar nodos que tienen hijos
        const nodeId = node.getAttribute('data-id');
        const hasChildren = document.querySelector(`.pyramid-node[data-parent="${nodeId}"]`) !== null;
        
        if (hasChildren) {
          node.classList.add('has-children');
        } else {
          node.classList.remove('has-children');
        }
      });
      
      // Ya no necesitamos el código para nodos fijados
      /* 
      if (pinnedNode) {
        pinnedNode.classList.add('pinned');
        pinnedNode.classList.remove('minimized');
      }
      */
      
      if (focusedNodeId) {
        // Obtener el nodo enfocado
        const focusedNode = document.querySelector(`.pyramid-node[data-id="${focusedNodeId}"]`);
        
        if (focusedNode) {
          // Activar el nodo enfocado
          focusedNode.classList.add('focused');
          focusedNode.classList.remove('minimized');
          
          // Mostrar información del nodo enfocado en la consola (para depuración)
          console.log('Nodo enfocado:', focusedNode.textContent, 'ID:', focusedNodeId);
          
          // Activar el padre del nodo enfocado
          const parentId = focusedNode.getAttribute('data-parent');
          if (parentId && parentId !== 'null') {
            const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
            if (parentNode) {
              parentNode.classList.remove('minimized');
            }
            
            // Activar los hermanos del nodo enfocado
            const siblings = document.querySelectorAll(`.pyramid-node[data-parent="${parentId}"]`);
            siblings.forEach(sibling => {
              sibling.classList.remove('minimized');
              sibling.classList.add('active-child');
            });
          }
          
          // Activar los hijos del nodo enfocado
          const childrenNodes = document.querySelectorAll(`.pyramid-node[data-parent="${focusedNodeId}"]`);
          childrenNodes.forEach(child => {
            child.classList.remove('minimized');
            child.classList.add('active-child');
          });
          
          // Si el nodo enfocado es un hijo, activar sus hermanos
          const focusedParentId = focusedNode.getAttribute('data-parent');
          if (focusedParentId && focusedParentId !== 'null') {
            const siblings = document.querySelectorAll(`.pyramid-node[data-parent="${focusedParentId}"]`);
            siblings.forEach(sibling => {
              sibling.classList.remove('minimized');
              sibling.classList.add('active-child');
            });
          }
        }
      } else {
        // Si no hay nodo enfocado, mostrar el nodo raíz y sus hijos normalmente
        const rootNode = document.querySelector('.pyramid-node[data-id="root"]');
        if (rootNode) {
          rootNode.classList.remove('minimized');
          rootNode.classList.add('focused');
          
          // Mostrar los hijos del nodo raíz normalmente
          const rootChildren = document.querySelectorAll('.pyramid-node[data-parent="root"]');
          rootChildren.forEach(child => {
            child.classList.remove('minimized');
            child.classList.add('active-child');
          });
        }
      }
    }
    
    // Función para actualizar la información del nodo en el panel inferior
    function updateNodeInfo(node) {
      const infoPanel = document.getElementById('info-panel');
      const metadataEditor = document.getElementById('metadata-editor');
      const metadataCardsContainer = document.getElementById('metadata-cards-container');
      
      // Ya no necesitamos verificar si el panel está fijado
      /* 
      if (infoPanel.classList.contains('fixed')) {
        return;
      }
      */
      
      if (!node) {
        document.getElementById('node-name').textContent = 'Ninguno seleccionado';
        document.getElementById('node-id').textContent = '-';
        metadataEditor.classList.remove('visible');
        infoPanel.classList.remove('expanded');
        metadataCardsContainer.innerHTML = '';
        return;
      }
      
      const nodeName = node.textContent.trim();
      const nodeId = node.getAttribute('data-id');
      
      document.getElementById('node-name').textContent = nodeName;
      document.getElementById('node-id').textContent = nodeId;
      
      // Ocultar el editor de metadatos
      metadataEditor.classList.remove('visible');
      
      // Mostrar las tarjetas de metadatos existentes
      renderMetadataCards(nodeId);
      
      // Siempre expandir el panel cuando se selecciona un nodo
      infoPanel.classList.add('expanded');
    }
    
    // Función para renderizar las tarjetas de metadatos
    function renderMetadataCards(nodeId) {
      const container = document.getElementById('metadata-cards-container');
      container.innerHTML = '';
      
      // Si no hay metadatos para este nodo, mostrar solo el botón de añadir
      if (!nodeMetadata[nodeId] || Object.keys(nodeMetadata[nodeId]).length === 0) {
        container.innerHTML = '<div class="add-metadata-card" id="add-metadata-card" tabindex="0">+ Añadir metadato</div>';
        
        // Añadir evento al botón de añadir
        setTimeout(() => {
          const addButton = document.getElementById('add-metadata-card');
          if (addButton) {
            addButton.addEventListener('click', function() {
              document.getElementById('toggle-metadata').click();
            });
            
            // Añadir navegación con teclado
            addButton.addEventListener('keydown', function(e) {
              if (e.key === 'Enter') {
                e.preventDefault();
                document.getElementById('toggle-metadata').click();
              }
            });
          }
        }, 0);
        
        return;
      }
      
      // Crear tarjetas para cada metadato
      let index = 0;
      for (const [key, value] of Object.entries(nodeMetadata[nodeId])) {
        const card = document.createElement('div');
        card.className = 'metadata-card';
        card.setAttribute('tabindex', '0'); // Hacer la tarjeta enfocable
        card.setAttribute('data-key', key);
        card.setAttribute('data-index', index++);
        card.innerHTML = `
          <div class="metadata-card-title">${key}</div>
          <div class="metadata-card-content">${value}</div>
        `;
        
        // Añadir evento para editar al hacer clic en la tarjeta
        card.addEventListener('click', function() {
          editMetadataCard(this, key, value);
        });
        
        // Añadir navegación con teclado
        card.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            editMetadataCard(this, key, value);
          } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
            e.preventDefault();
            const nextCard = this.nextElementSibling;
            if (nextCard && nextCard.classList.contains('metadata-card')) {
              nextCard.focus();
            } else if (document.getElementById('add-metadata-card')) {
              document.getElementById('add-metadata-card').focus();
            }
          } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
            e.preventDefault();
            const prevCard = this.previousElementSibling;
            if (prevCard && prevCard.classList.contains('metadata-card')) {
              prevCard.focus();
            }
          } else if (e.key === 'Escape') {
            e.preventDefault();
            // Volver al nodo
            const focusedNode = document.querySelector('.pyramid-node.focused');
            if (focusedNode) {
              focusedNode.focus();
            }
          }
        });
        
        container.appendChild(card);
      }
      
      // Añadir el botón para agregar nuevo metadato
      const addButton = document.createElement('div');
      addButton.className = 'add-metadata-card';
      addButton.setAttribute('tabindex', '0');
      addButton.textContent = '+ Añadir metadato';
      
      addButton.addEventListener('click', function() {
        document.getElementById('toggle-metadata').click();
      });
      
      // Añadir navegación con teclado
      addButton.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          document.getElementById('toggle-metadata').click();
        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
          e.preventDefault();
          const cards = document.querySelectorAll('.metadata-card');
          if (cards.length > 0) {
            cards[cards.length - 1].focus();
          }
        } else if (e.key === 'Escape') {
          e.preventDefault();
          // Volver al nodo
          const focusedNode = document.querySelector('.pyramid-node.focused');
          if (focusedNode) {
            focusedNode.focus();
          }
        }
      });
      
      container.appendChild(addButton);
    }
    
    // Función auxiliar para editar una tarjeta de metadatos
    function editMetadataCard(card, key, value) {
      // Abrir el editor con los valores de esta tarjeta
      document.getElementById('metadata-key').value = key;
      document.getElementById('metadata-value').value = value;
      document.getElementById('metadata-editor').classList.add('visible');
      document.getElementById('info-panel').classList.add('expanded');
      
      // Guardar la clave original para poder actualizarla
      document.getElementById('metadata-key').setAttribute('data-original-key', key);
      
      // Enfocar el campo de título
      setTimeout(() => {
        document.getElementById('metadata-key').focus();
      }, 100);
    }
    
    // Configurar eventos para los nodos
    function setupNodeEvents() {
      let currentFocusedNode = null;
      
      const nodes = document.querySelectorAll('.pyramid-node');
      
      nodes.forEach(node => {
        // Marcar nodos que tienen hijos
        const nodeId = node.getAttribute('data-id');
        const hasChildren = document.querySelector(`.pyramid-node[data-parent="${nodeId}"]`) !== null;
        const childrenContainer = document.getElementById(`children_${nodeId}`);
        
        if (hasChildren) {
          node.classList.add('collapsed');
        }
        
        // Evento de clic simple
        node.addEventListener('click', function() {
          if (currentFocusedNode) {
            currentFocusedNode.classList.remove('focused');
          }
          
          this.classList.add('focused');
          currentFocusedNode = this;
          
          updateNodesVisualState(this.getAttribute('data-id'));
          updateNodeInfo(this);
          
          this.scrollIntoView({ block: 'center', inline: 'center', behavior: 'smooth' });
        });

        // Añadir evento de doble clic
        node.addEventListener('dblclick', function(e) {
          e.preventDefault();
          
          const nodeId = this.getAttribute('data-id');
          const childrenContainer = document.getElementById(`children_${nodeId}`);
          
          if (childrenContainer) {
            // Alternar visibilidad del contenedor de hijos
            childrenContainer.classList.toggle('visible');
            
            // Actualizar clase del nodo
            if (childrenContainer.classList.contains('visible')) {
              this.classList.remove('collapsed');
              this.classList.add('expanded');
              
              // Si se expande, hacer visibles los nodos hijos para la navegación
              const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
              childNodes.forEach(child => {
                child.classList.remove('minimized');
                child.classList.add('active-child');
              });

              // Seleccionar el primer ejemplo visible
              const firstExample = childrenContainer.querySelector('.pyramid-node:not(.hidden)');
              if (firstExample) {
                firstExample.click();
              }
            } else {
              this.classList.remove('expanded');
              this.classList.add('collapsed');
              
              // Si estamos cerrando un contenedor y el nodo enfocado está dentro de él,
              // devolver el foco al nodo padre
              const focusedNodeContainer = document.querySelector('.pyramid-node.focused').closest('.children-container');
              if (focusedNodeContainer && focusedNodeContainer.id === `children_${nodeId}`) {
                this.click(); // Seleccionar el nodo padre
              }
            }
          }
        });
        
        // Añadir evento de teclado para expandir/colapsar con la barra espaciadora
        // Ya no usamos Enter para fijar la información
        node.addEventListener('keydown', function(e) {
          if (e.key === ' ' || e.key === 'Spacebar') {
            e.preventDefault(); // Prevenir el desplazamiento de la página
            
            const nodeId = this.getAttribute('data-id');
            const childrenContainer = document.getElementById(`children_${nodeId}`);
            
            if (childrenContainer) {
              // Alternar visibilidad del contenedor de hijos
              childrenContainer.classList.toggle('visible');
              
              // Actualizar clase del nodo
              if (childrenContainer.classList.contains('visible')) {
                this.classList.remove('collapsed');
                this.classList.add('expanded');
                
                // Si se expande, hacer visibles los nodos hijos para la navegación
                const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
                childNodes.forEach(child => {
                  child.classList.remove('minimized');
                  child.classList.add('active-child');
                });
              } else {
                this.classList.remove('expanded');
                this.classList.add('collapsed');
              }
            } else {
              // Verificar si este nodo es hijo de otro nodo
              const parentId = this.getAttribute('data-parent');
              if (parentId && parentId !== 'null') {
                // Buscar el contenedor de hijos del padre
                const parentContainer = document.getElementById(`children_${parentId}`);
                if (parentContainer && parentContainer.classList.contains('visible')) {
                  // Colapsar el contenedor del padre
                  parentContainer.classList.remove('visible');
                  
                  // Actualizar la clase del nodo padre
                  const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
                  if (parentNode) {
                    parentNode.classList.remove('expanded');
                    parentNode.classList.add('collapsed');
                    
                    // Enfocar el nodo padre
                    parentNode.click();
                  }
                }
              }
            }
          }
          // Eliminar el bloque de código para Enter que fijaba el nodo
        });

        // Añadir evento de teclado para Enter
        node.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            e.stopPropagation();
            
            // Enfocar el editor de metadatos
            document.getElementById('toggle-metadata').click();
            
            // Enfocar el campo de título después de un breve retraso
            setTimeout(() => {
              const metadataKey = document.getElementById('metadata-key');
              if (metadataKey) {
                metadataKey.focus();
              }
            }, 100);
          } else if (e.key === ' ' || e.key === 'Spacebar') {
            e.preventDefault();
            
            const nodeId = this.getAttribute('data-id');
            const childrenContainer = document.getElementById(`children_${nodeId}`);
            
            if (childrenContainer) {
              // Alternar visibilidad del contenedor de hijos
              childrenContainer.classList.toggle('visible');
              
              // Actualizar clase del nodo
              if (childrenContainer.classList.contains('visible')) {
                this.classList.remove('collapsed');
                this.classList.add('expanded');
                
                // Si se expande, hacer visibles los nodos hijos para la navegación
                const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
                childNodes.forEach(child => {
                  child.classList.remove('minimized');
                  child.classList.add('active-child');
                });
              } else {
                this.classList.remove('expanded');
                this.classList.add('collapsed');
                
                // Si estamos cerrando un contenedor y el nodo enfocado está dentro de él,
                // devolver el foco al nodo padre
                const focusedNodeContainer = document.querySelector('.pyramid-node.focused').closest('.children-container');
                if (focusedNodeContainer && focusedNodeContainer.id === `children_${nodeId}`) {
                  this.click(); // Seleccionar el nodo padre
                }
              }
            }
          }
        });
      });
    }
    
    // Configurar navegación con teclado
    function setupKeyboardNavigation() {
      let currentFocusedNode = null;
      const nodes = document.querySelectorAll('.pyramid-node');
      
      document.addEventListener('keydown', function(e) {
        if (document.activeElement === document.getElementById('data-display')) {
          return;
        }

        currentFocusedNode = document.querySelector('.pyramid-node.focused');
        
        if (!currentFocusedNode) {
          if (nodes.length > 0 && (e.key === 'ArrowDown' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowLeft')) {
            nodes[0].click();
            e.preventDefault();
          }
          return;
        }

        const isInChildrenContainer = currentFocusedNode.closest('.children-container') !== null;
        const nodeId = currentFocusedNode.getAttribute('data-id');
        const parentId = currentFocusedNode.getAttribute('data-parent');
        const childrenContainer = document.getElementById(`children_${nodeId}`);
        const hasChildren = childrenContainer !== null;
        
        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            if (isInChildrenContainer) {
              // Navegación dentro del contenedor de ejemplos
              const container = currentFocusedNode.closest('.children-container');
              const examples = Array.from(container.querySelectorAll('.pyramid-node:not(.hidden)'));
              const currentIndex = examples.indexOf(currentFocusedNode);
              
              if (currentIndex < examples.length - 1) {
                examples[currentIndex + 1].click();
              }
            } else if (hasChildren && !childrenContainer.classList.contains('visible')) {
              // Si tiene hijos y están ocultos, mostrarlos y seleccionar el primero
              childrenContainer.classList.add('visible');
              currentFocusedNode.classList.remove('collapsed');
              currentFocusedNode.classList.add('expanded');
              
              const firstExample = childrenContainer.querySelector('.pyramid-node:not(.hidden)');
              if (firstExample) {
                firstExample.click();
              }
            } else {
              // Buscar hijos directos del nodo actual
              const children = Array.from(nodes).filter(node => 
                node.getAttribute('data-parent') === nodeId &&
                !node.classList.contains('hidden')
              );
              
              if (children.length > 0) {
                children[0].click();
              }
            }
            break;

          case 'ArrowUp':
            e.preventDefault();
            if (isInChildrenContainer) {
              const container = currentFocusedNode.closest('.children-container');
              const examples = Array.from(container.querySelectorAll('.pyramid-node:not(.hidden)'));
              const currentIndex = examples.indexOf(currentFocusedNode);
              
              if (currentIndex > 0) {
                examples[currentIndex - 1].click();
              } else {
                // Volver al nodo padre
                const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
                if (parentNode) {
                  parentNode.click();
                }
              }
            } else {
              // Ir al padre del nodo actual
              if (parentId && parentId !== 'null') {
                const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
                if (parentNode) {
                  parentNode.click();
                }
              }
            }
            break;

          case 'ArrowRight':
            e.preventDefault();
            if (isInChildrenContainer) {
              return; // No hacer nada si estamos en ejemplos
            }
            
            // Buscar hermanos del nodo actual
            const siblings = Array.from(nodes).filter(node => 
              node.getAttribute('data-parent') === parentId &&
              !node.classList.contains('hidden') &&
              !node.closest('.children-container')
            );
            
            const currentIndex = siblings.indexOf(currentFocusedNode);
            if (currentIndex < siblings.length - 1) {
              siblings[currentIndex + 1].click();
            }
            break;

          case 'ArrowLeft':
            e.preventDefault();
            if (isInChildrenContainer) {
              // Volver al nodo padre desde los ejemplos
              const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
              if (parentNode) {
                parentNode.click();
              }
            } else {
              // Buscar hermanos del nodo actual
              const siblings = Array.from(nodes).filter(node => 
                node.getAttribute('data-parent') === parentId &&
                !node.classList.contains('hidden') &&
                !node.closest('.children-container')
              );
              
              const currentIndex = siblings.indexOf(currentFocusedNode);
              if (currentIndex > 0) {
                siblings[currentIndex - 1].click();
              }
            }
            break;

          case ' ':
          case 'Spacebar':
            e.preventDefault();
            if (hasChildren) {
              childrenContainer.classList.toggle('visible');
              if (childrenContainer.classList.contains('visible')) {
                currentFocusedNode.classList.remove('collapsed');
                currentFocusedNode.classList.add('expanded');
              } else {
                currentFocusedNode.classList.remove('expanded');
                currentFocusedNode.classList.add('collapsed');
                
                // Si estamos cerrando un contenedor y el nodo enfocado está dentro de él,
                // devolver el foco al nodo padre
                const focusedNodeContainer = document.querySelector('.pyramid-node.focused').closest('.children-container');
                if (focusedNodeContainer && focusedNodeContainer.id === `children_${nodeId}`) {
                  currentFocusedNode.click(); // Seleccionar el nodo padre
                }
              }
            }
            break;
        }
      });
    }
    
    // Función para alternar la visibilidad del panel YAML-JSON
    document.getElementById('toggle-panel').addEventListener('click', function() {
      const panel = document.getElementById('yaml-json-panel');
      const mainContent = document.querySelector('.main-content');
      const nodesContainer = document.getElementById('nodes-container');
      
      panel.classList.toggle('visible');
      mainContent.classList.toggle('panel-visible');
      
      // Si el panel está visible, desplazar el contenedor de nodos a la derecha
      if (panel.classList.contains('visible')) {
        this.textContent = '×'; // Cambiar el ícono del botón a una X
      } else {
        this.textContent = '≡'; // Cambiar el ícono del botón a barras
      }
      
      // Actualizar los indicadores de navegación después de un breve retraso
      // para permitir que la animación de desplazamiento termine
      setTimeout(checkForOverflow, 300);
      
      // Forzar un reflow para que el contenedor de nodos se ajuste correctamente
      setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
      }, 350);
    });
    
    // Evento para cambiar entre formatos
    document.getElementById('format-selector').addEventListener('change', function() {
      const format = this.value;
      document.getElementById('current-format').textContent = format.toUpperCase();
      
      if (format === 'json') {
        // Convertir YAML a JSON
        try {
          const jsonData = yamlToJson(document.getElementById('data-display').value);
          document.getElementById('data-display').value = JSON.stringify(jsonData, null, 2);
        } catch (e) {
          console.error("Error al convertir a JSON:", e);
          document.getElementById('data-display').value = "Error al convertir a JSON. Verifica el formato YAML.";
        }
      } else {
        // Convertir JSON a YAML
        try {
          const jsonText = document.getElementById('data-display').value;
          const jsonObj = JSON.parse(jsonText);
          const yamlData = jsonToYaml(jsonObj);
          document.getElementById('data-display').value = yamlData;
        } catch (e) {
          console.error("Error al convertir a YAML:", e);
          document.getElementById('data-display').value = "# Error al convertir a YAML. Verifica el formato JSON.";
        }
      }
    });
    
    // Evento para actualizar la visualización
    document.getElementById('update-visualization').addEventListener('click', function() {
      const format = document.getElementById('format-selector').value;
      const dataText = document.getElementById('data-display').value;
      
      if (format === 'json') {
        try {
          const jsonObj = JSON.parse(dataText);
          updateNodeVisualization(jsonObj);
        } catch (e) {
          console.error("Error al parsear JSON:", e);
          alert("Error al parsear JSON. Verifica el formato.");
        }
      } else {
        updateNodeVisualization(dataText);
      }
    });
    
    // Función para verificar si hay desbordamiento y mostrar indicadores
    function checkForOverflow() {
      const container = document.querySelector('.nodes-container');
      const content = document.querySelector('.pyramid-container');
      
      if (!container || !content) return;
      
      // Eliminar indicadores existentes
      document.querySelectorAll('.navigation-indicator').forEach(el => el.remove());
      
      // Verificar desbordamiento horizontal
      if (content.scrollWidth > container.clientWidth) {
        // Hay contenido fuera de la vista a la derecha
        const rightIndicator = document.createElement('div');
        rightIndicator.className = 'navigation-indicator indicator-right';
        rightIndicator.textContent = '→';
        container.appendChild(rightIndicator);
        
        // Hay contenido fuera de la vista a la izquierda
        const leftIndicator = document.createElement('div');
        leftIndicator.className = 'navigation-indicator indicator-left';
        leftIndicator.textContent = '←';
        container.appendChild(leftIndicator);
      }
      
      // Verificar desbordamiento vertical
      if (content.scrollHeight > container.clientHeight) {
        // Hay contenido fuera de la vista abajo
        const downIndicator = document.createElement('div');
        downIndicator.className = 'navigation-indicator indicator-down';
        downIndicator.textContent = '↓';
        container.appendChild(downIndicator);
        
        // Hay contenido fuera de la vista arriba
        const upIndicator = document.createElement('div');
        upIndicator.className = 'navigation-indicator indicator-up';
        upIndicator.textContent = '↑';
        container.appendChild(upIndicator);
      }
    }
    
    // Función para alternar la visibilidad del panel de propiedades
    document.getElementById('toggle-props-panel').addEventListener('click', function() {
      const panel = document.getElementById('props-panel');
      const mainContent = document.querySelector('.main-content');
      
      panel.classList.toggle('visible');
      mainContent.classList.toggle('props-panel-visible');
      
      // Si el panel está visible, cambiar el ícono del botón
      if (panel.classList.contains('visible')) {
        this.textContent = '×'; // Cambiar el ícono del botón a una X
      } else {
        this.textContent = '⚙'; // Cambiar el ícono del botón a engranaje
      }
      
      // Actualizar los indicadores de navegación después de un breve retraso
      setTimeout(checkForOverflow, 300);
      
      // Forzar un reflow para que el contenedor de nodos se ajuste correctamente
      setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
      }, 350);
    });
    
    // Función para cargar y mostrar la jerarquía de propiedades
    async function loadPropertiesHierarchy() {
      try {
        // En un entorno real, esto sería una llamada a la API
        // Por ahora, usamos el ejemplo de props.json directamente
        const propsData = {
          "id": "root-game-123",
          "VideoJuego": {
            "id": "game-root-456",
            "Personajes": {
              "id": "characters-789",
              "Heroe": {
                "id": "hero-abc",
                "value": null
              },
              "Villano": {
                "id": "villain-def",
                "value": null
              }
            },
            "Items": {
              "id": "items-ghi",
              "Arma": {
                "id": "weapon-jkl",
                "value": null
              },
              "Pocion": {
                "id": "potion-mno",
                "value": null
              }
            },
            "Aliados": {
              "id": "allies-pqr",
              "Guerrero": {
                "id": "warrior-stu",
                "value": null
              },
              "Mago": {
                "id": "mage-vwx",
                "value": null
              }
            }
          }
        };
        
        renderPropertiesTree(propsData);
      } catch (error) {
        console.error('Error loading properties hierarchy:', error);
        document.getElementById('props-tree').innerHTML = '<p>Error al cargar la jerarquía de propiedades.</p>';
      }
    }
    
    // Función para renderizar el árbol de propiedades
    function renderPropertiesTree(data, parentElement = null) {
      const container = parentElement || document.getElementById('props-tree');
      
      // Limpiar el contenedor si es el contenedor principal
      if (!parentElement) {
        container.innerHTML = '';
      }
      
      // Recorrer las propiedades del objeto
      Object.entries(data).forEach(([key, value]) => {
        // Ignorar la propiedad "id" cuando está sola
        if (key === 'id' || key === 'value') return;
        
        const itemDiv = document.createElement('div');
        itemDiv.className = 'prop-item';
        
        const headerDiv = document.createElement('div');
        headerDiv.className = 'prop-item-header';
        
        // Determinar si este nodo tiene hijos
        const hasChildren = typeof value === 'object' && value !== null && 
                            Object.keys(value).some(k => k !== 'id' && k !== 'value');
        
        // Crear el contenido del encabezado
        let headerContent = '';
        if (hasChildren) {
          headerContent += '<span class="prop-toggle">▶</span>';
        } else {
          headerContent += '<span class="prop-toggle" style="visibility:hidden">▶</span>';
        }
        
        headerContent += key;
        
        // Añadir el ID si existe
        if (value && value.id) {
          headerContent += `<span class="prop-id">(ID: ${value.id})</span>`;
        }
        
        // Añadir el valor si existe y no es null
        if (value && value.value !== undefined && value.value !== null) {
          headerContent += `<span class="prop-value">${value.value}</span>`;
        }
        
        headerDiv.innerHTML = headerContent;
        itemDiv.appendChild(headerDiv);
        
        // Si tiene hijos, crear un contenedor para ellos
        if (hasChildren) {
          const childrenDiv = document.createElement('div');
          childrenDiv.className = 'prop-children';
          itemDiv.appendChild(childrenDiv);
          
          // Añadir evento para expandir/colapsar
          headerDiv.addEventListener('click', function() {
            childrenDiv.classList.toggle('visible');
            const toggle = this.querySelector('.prop-toggle');
            if (childrenDiv.classList.contains('visible')) {
              toggle.textContent = '▼';
              
              // Si aún no se han renderizado los hijos, hacerlo ahora
              if (childrenDiv.children.length === 0) {
                renderPropertiesTree(value, childrenDiv);
              }
            } else {
              toggle.textContent = '▶';
            }
          });
        }
        
        container.appendChild(itemDiv);
      });
    }
    
    // Inicializar la visualización al cargar la página
    document.addEventListener('DOMContentLoaded', function() {
      // Verificar que jsyaml esté cargado
      if (typeof jsyaml === 'undefined') {
        console.error("Error: jsyaml no está cargado");
        document.getElementById('node-visualization').innerHTML = 
          '<p>Error: No se pudo cargar la biblioteca js-yaml. Verifica las dependencias.</p>';
        return;
      }
      
      // Cargar datos iniciales
      document.getElementById('data-display').value = yamlData;
      
      // Generar visualización inicial
      updateNodeVisualization(yamlData);
      
      // Añadir evento de redimensionamiento para actualizar indicadores
      window.addEventListener('resize', checkForOverflow);
      
      // Añadir eventos de desplazamiento para actualizar indicadores
      document.querySelector('.nodes-container').addEventListener('scroll', function() {
        // Actualizar visibilidad de indicadores según la posición de desplazamiento
        const indicators = document.querySelectorAll('.navigation-indicator');
        indicators.forEach(indicator => {
          indicator.style.opacity = '0.7';
          setTimeout(() => {
            indicator.style.opacity = '0';
          }, 1500);
        });
      });
      
      // Inicializar el estado visual de los nodos
      setTimeout(() => {
        updateNodesVisualState();
        
        // Seleccionar el nodo raíz por defecto
        const rootNode = document.querySelector('.pyramid-node[data-id="root"]');
        if (rootNode) {
          rootNode.click();
        }
      }, config.autoScrollDelay);
      
      // Añadir estilos CSS para el desplazamiento del contenedor de nodos
      const style = document.createElement('style');
      style.textContent = `
        /* Estilos existentes para nodos fijados... */
        
        /* Ajustar el diseño para evitar superposiciones */
        .main-content {
          display: flex;
          flex-direction: row;
          align-items: stretch;
          overflow: hidden;
        }
        
        .YAML-JSON {
          width: 0;
          overflow: hidden;
          transition: width 0.3s ease;
          flex-shrink: 0;
        }
        
        .YAML-JSON.visible {
          width: 40%; /* Ancho del panel cuando está visible */
          min-width: 300px;
          max-width: 500px;
        }
        
        .nodes-container {
          flex-grow: 1;
          overflow: auto;
          transition: margin-left 0.3s ease, width 0.3s ease;
          width: 100%;
        }
        
        .main-content.panel-visible .nodes-container {
          margin-left: 40%; /* Debe coincidir con el ancho del panel */
          width: 60%; /* El ancho restante */
        }
        
        @media (max-width: 1200px) {
          .YAML-JSON.visible {
            width: 350px;
            min-width: 300px;
          }
          
          .main-content.panel-visible .nodes-container {
            margin-left: 350px;
            width: calc(100% - 350px);
          }
        }
        
        /* Asegurar que el botón de alternar siempre esté visible */
        .toggle-panel {
          position: fixed;
          left: 10px;
          top: 10px;
          z-index: 1001;
          background-color: #333;
          color: white;
          border: none;
          border-radius: 4px;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          font-size: 18px;
          box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .toggle-panel:hover {
          background-color: #555;
        }
        
        /* Asegurar que el contenido de la visualización se ajuste correctamente */
        .pyramid-container {
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          transition: transform 0.3s ease;
        }
      `;
      document.head.appendChild(style);
      
      // Asegurarse de que el contenedor de nodos se ajuste cuando cambia el tamaño de la ventana
      window.addEventListener('resize', function() {
        checkForOverflow();
        
        // Ajustar el tamaño del contenedor de nodos si el panel está visible
        const panel = document.getElementById('yaml-json-panel');
        const nodesContainer = document.getElementById('nodes-container');
        
        if (panel && panel.classList.contains('visible') && nodesContainer) {
          // Forzar un reflow para que el contenedor se ajuste correctamente
          nodesContainer.style.display = 'none';
          setTimeout(() => {
            nodesContainer.style.display = '';
          }, 10);
        }
      });
      
      // Cargar la jerarquía de propiedades
      loadPropertiesHierarchy();
      
      // Añadir estilos CSS adicionales para manejar ambos paneles
      const additionalStyle = document.createElement('style');
      additionalStyle.textContent = `
        /* Ajustes para cuando ambos paneles están visibles */
        .main-content.panel-visible.props-panel-visible .nodes-container {
          margin-left: 40%;
          margin-right: 40%;
          width: 20%;
        }
        
        @media (max-width: 1200px) {
          .main-content.panel-visible.props-panel-visible .nodes-container {
            margin-left: 350px;
            margin-right: 350px;
            width: calc(100% - 700px);
          }
        }
      `;
      document.head.appendChild(additionalStyle);
      
      // Configurar el botón de edición de metadatos
      document.getElementById('toggle-metadata').addEventListener('click', function() {
        const metadataEditor = document.getElementById('metadata-editor');
        const infoPanel = document.getElementById('info-panel');
        
        // Limpiar los campos del formulario
        document.getElementById('metadata-key').value = '';
        document.getElementById('metadata-value').value = '';
        document.getElementById('metadata-key').removeAttribute('data-original-key');
        
        metadataEditor.classList.add('visible');
        infoPanel.classList.add('expanded');
        
        // Enfocar el campo de título
        document.getElementById('metadata-key').focus();
      });
      
      // Configurar el botón de guardar metadatos
      document.getElementById('save-metadata').addEventListener('click', function() {
        const nodeId = document.getElementById('node-id').textContent;
        if (nodeId && nodeId !== '-') {
          const key = document.getElementById('metadata-key').value.trim();
          const value = document.getElementById('metadata-value').value.trim();
          const originalKey = document.getElementById('metadata-key').getAttribute('data-original-key');
          
          if (key && value) {
            // Inicializar el objeto de metadatos para este nodo si no existe
            if (!nodeMetadata[nodeId]) {
              nodeMetadata[nodeId] = {};
            }
            
            // Si estamos editando un metadato existente, eliminar la clave anterior
            if (originalKey && originalKey !== key) {
              delete nodeMetadata[nodeId][originalKey];
            }
            
            // Guardar el nuevo valor
            nodeMetadata[nodeId][key] = value;
            
            // Actualizar la visualización
            renderMetadataCards(nodeId);
            
            // Ocultar el editor
            document.getElementById('metadata-editor').classList.remove('visible');
          }
        }
      });
      
      // Configurar el botón de cancelar
      document.getElementById('cancel-metadata').addEventListener('click', function() {
        document.getElementById('metadata-editor').classList.remove('visible');
      });
    });
    
    // En la sección donde se configura el editor de metadatos
    function setupMetadataEditor() {
      const metadataKeyInput = document.getElementById('metadata-key');
      const metadataValueInput = document.getElementById('metadata-value');
      const saveButton = document.getElementById('save-metadata');
      const cancelButton = document.getElementById('cancel-metadata');
      const metadataEditor = document.getElementById('metadata-editor');
      
      // Añadir el event listener para atrapar el foco a nivel del documento
      document.addEventListener('keydown', trapFocusInMetadataEditor, true);
      
      // Cuando se abre el editor, enfocar el primer campo
      document.getElementById('toggle-metadata').addEventListener('click', function() {
        metadataEditor.classList.add('visible');
        setTimeout(() => {
          metadataKeyInput.focus();
        }, 0);
      });
      
      // Resto del código de configuración del editor...
      metadataKeyInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          metadataValueInput.focus();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelMetadataEdit();
        }
      });
      
      metadataValueInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          saveButton.click();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelMetadataEdit();
        }
      });
      
      saveButton.addEventListener('click', function() {
        saveMetadata();
      });
      
      cancelButton.addEventListener('click', function() {
        cancelMetadataEdit();
      });
    }
    
    // Función para editar una tarjeta de metadatos
    function editMetadataCard(card, key, value) {
      const metadataEditor = document.getElementById('metadata-editor');
      const metadataKeyInput = document.getElementById('metadata-key');
      const metadataValueInput = document.getElementById('metadata-value');
      
      metadataKeyInput.value = key;
      metadataValueInput.value = value;
      metadataEditor.classList.add('visible');
      document.getElementById('info-panel').classList.add('expanded');
      
      metadataKeyInput.setAttribute('data-original-key', key);
      
      // Asegurar que el foco se establezca en el campo de título
      setTimeout(() => {
        metadataKeyInput.focus();
      }, 100);
    }
    
    // Función para cancelar la edición
    function cancelMetadataEdit() {
      const metadataEditor = document.getElementById('metadata-editor');
      const metadataKeyInput = document.getElementById('metadata-key');
      const metadataValueInput = document.getElementById('metadata-value');
      
      metadataEditor.classList.remove('visible');
      metadataKeyInput.value = '';
      metadataValueInput.value = '';
      metadataKeyInput.removeAttribute('data-original-key');
      
      // Volver a enfocar el nodo activo
      const focusedNode = document.querySelector('.pyramid-node.focused');
      if (focusedNode) {
        focusedNode.focus();
      }
    }
    
    // Función para atrapar el foco dentro del editor de metadatos
    function trapFocusInMetadataEditor(e) {
      const metadataEditor = document.getElementById('metadata-editor');
      
      // Solo proceder si el editor está visible
      if (!metadataEditor.classList.contains('visible')) {
        return;
      }
      
      // Si la tecla presionada es Tab
      if (e.key === 'Tab') {
        // Obtener todos los elementos focusables dentro del editor
        const focusableElements = Array.from(metadataEditor.querySelectorAll(
          'input, button, [href], select, textarea, [tabindex]:not([tabindex="-1"])'
        )).filter(el => !el.disabled && el.offsetParent !== null);
        
        const firstFocusableElement = focusableElements[0];
        const lastFocusableElement = focusableElements[focusableElements.length - 1];
        
        // Si no hay elementos focusables, no hacer nada
        if (!firstFocusableElement) return;
        
        // Verificar si el elemento activo está dentro del editor
        const isInEditor = metadataEditor.contains(document.activeElement);
        
        if (!isInEditor) {
          // Si el foco está fuera del editor, forzar el foco al primer elemento
          e.preventDefault();
          firstFocusableElement.focus();
          return;
        }
        
        // Si se presiona Shift + Tab
        if (e.shiftKey) {
          // Si el foco está en el primer elemento, ir al último
          if (document.activeElement === firstFocusableElement) {
            e.preventDefault();
            lastFocusableElement.focus();
          }
        } 
        // Si solo se presiona Tab
        else {
          // Si el foco está en el último elemento, ir al primero
          if (document.activeElement === lastFocusableElement) {
            e.preventDefault();
            firstFocusableElement.focus();
          }
        }
      }
    }
    
    // En el evento DOMContentLoaded, asegurarse de configurar el editor
    document.addEventListener('DOMContentLoaded', function() {
      // ... código existente ...
      
      // Configurar el editor de metadatos
      setupMetadataEditor();
      
      // ... código existente ...
    });
    
    // Configurar el manejo de teclas en el área de texto
    document.getElementById('data-display').addEventListener('keydown', function(e) {
      // Si estamos en el editor YAML, detener la propagación de teclas especiales
      if (e.key === 'Tab' || e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
        e.stopPropagation(); // Detener la propagación del evento
      }

      // Manejar la tecla Tab
      if (e.key === 'Tab') {
        e.preventDefault();
        
        const start = this.selectionStart;
        const end = this.selectionEnd;
        
        // Insertar dos espacios en la posición del cursor
        this.value = this.value.substring(0, start) + '  ' + this.value.substring(end);
        
        // Mover el cursor después de los espacios insertados
        this.selectionStart = this.selectionEnd = start + 2;
      }
      
      // Manejar la tecla Enter
      if (e.key === 'Enter') {
        e.preventDefault();
        
        const start = this.selectionStart;
        const end = this.selectionEnd;
        const value = this.value;
        
        // Obtener la línea actual
        const currentLine = value.substring(0, start).split('\n').pop();
        
        // Contar los espacios iniciales de la línea actual
        const indentation = currentLine.match(/^\s*/)[0];
        
        // Insertar nueva línea con la misma indentación
        this.value = value.substring(0, start) + '\n' + indentation + value.substring(end);
        
        // Mover el cursor después de la indentación
        const newPosition = start + 1 + indentation.length;
        this.selectionStart = this.selectionEnd = newPosition;
      }

      // Para la barra espaciadora, no necesitamos hacer nada especial
      // Solo detenemos su propagación y dejamos que funcione normalmente
      
    }, { capture: true }); // Capturar el evento en la fase de captura

    // Función para guardar metadatos
    function saveMetadata() {
      const key = document.getElementById('metadata-key').value.trim();
      const value = document.getElementById('metadata-value').value.trim();
      const originalKey = document.getElementById('metadata-key').getAttribute('data-original-key');
      
      // Obtener el nodo actualmente seleccionado
      const focusedNode = document.querySelector('.pyramid-node.focused');
      if (!focusedNode) return;
      
      const nodeId = focusedNode.getAttribute('data-id');
      
      // Inicializar el objeto de metadatos para este nodo si no existe
      if (!nodeMetadata[nodeId]) {
        nodeMetadata[nodeId] = {};
      }
      
      // Si hay una clave original y es diferente a la nueva, eliminar la antigua
      if (originalKey && originalKey !== key) {
        delete nodeMetadata[nodeId][originalKey];
      }
      
      // Guardar el nuevo metadato
      if (key && value) {
        nodeMetadata[nodeId][key] = value;
      }
      
      // Limpiar el formulario
      document.getElementById('metadata-key').value = '';
      document.getElementById('metadata-value').value = '';
      document.getElementById('metadata-key').removeAttribute('data-original-key');
      
      // Ocultar el editor
      document.getElementById('metadata-editor').classList.remove('visible');
      
      // Actualizar la visualización de las tarjetas de metadatos
      renderMetadataCards(nodeId);
      
      // Devolver el foco al nodo
      if (focusedNode) {
        focusedNode.focus();
      }
    }

    // Añadir el evento al botón de guardar
    document.getElementById('save-metadata').addEventListener('click', saveMetadata);

    // Añadir eventos de teclado para el formulario de metadatos
    document.getElementById('metadata-key').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('metadata-value').focus();
      }
    });

    document.getElementById('metadata-value').addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveMetadata();
      }
    });
  </script>
</body>
</html>