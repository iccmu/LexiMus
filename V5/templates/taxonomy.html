<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualizador de Taxonomía</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    
    .container {
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .top-bar {
      background-color: #333;
      color: white;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 60px;
      box-sizing: border-box;
    }
    
    .top-bar h1 {
      margin: 0;
      font-size: 1.5rem;
    }
    
    .controls {
      display: flex;
      gap: 10px;
    }
    
    .controls button, .controls select {
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
    }
    
    .main-content {
      display: flex;
      height: calc(100vh - 60px);
      position: relative;
    }
    
    .YAML-JSON {
      width: 30%;
      background-color: #f5f5f5;
      padding: 20px;
      box-sizing: border-box;
      overflow: auto;
      transform: translateX(-100%);
      position: absolute;
      height: 100%;
      transition: transform 0.3s ease;
      z-index: 10;
    }
    
    .YAML-JSON.visible {
      transform: translateX(0);
    }
    
    .nodes-container {
      width: 100%;
      height: 100%;
      overflow: auto;
      padding: 20px;
      box-sizing: border-box;
    }
    
    .toggle-panel {
      position: fixed;
      top: 70px;
      left: 10px;
      width: 40px;
      height: 40px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    
    /* Estilos para la visualización de nodos */
    .pyramid-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
      padding: 40px 20px;
      width: 100%;
      box-sizing: border-box;
    }
    
    .pyramid-level {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 20px;
      width: 100%;
      padding: 0 10px;
    }
    
    /* Contenedor para un nodo y sus hijos */
    .node-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }
    
    /* Contenedor para los hijos de un nodo */
    .children-container {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(0,0,0,0.05);
      border-radius: 8px;
      max-width: 300px;
      overflow-y: auto;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    .children-container.visible {
      display: flex;
      animation: fadeIn 0.3s ease;
    }
    
    /* Estilos para nodos colapsados/expandidos */
    .pyramid-node.collapsed::after {
      content: "▶";
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    .pyramid-node.expanded::after {
      content: "▼";
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    .pyramid-node {
      padding: 12px 20px;
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      min-width: 100px;
      max-width: 150px;
      word-wrap: break-word;
      flex-shrink: 0;
      position: relative;
    }
    
    /* Nodos minimizados (subnodos cuando su padre no está activo) */
    .pyramid-node.minimized {
      transform: scale(0.8);
      opacity: 0.7;
      filter: saturate(0.7);
    }
    
    /* Estilos para los diferentes tipos de nodos */
    .pyramid-node.main {
      background-color: #2196F3; /* Azul para el nodo principal */
      color: white;
    }
    
    .pyramid-node.category {
      background-color: #4CAF50; /* Verde para categorías */
      color: white;
    }
    
    .pyramid-node.subcategory {
      background-color: #FF9800; /* Naranja para subcategorías */
      color: white;
    }
    
    .pyramid-node.example {
      background-color: #9C27B0; /* Púrpura para ejemplos */
      color: white;
    }
    
    /* Nodo actualmente seleccionado/enfocado */
    .pyramid-node.focused {
      transform: scale(1.1);
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 5;
      background-color: #1976D2; /* Azul más oscuro para el nodo enfocado */
      border: 3px solid #0D47A1; /* Borde azul oscuro */
      color: white;
      font-weight: bold;
    }
    
    /* Efecto de brillo para el nodo enfocado */
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(25, 118, 210, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(25, 118, 210, 0); }
      100% { box-shadow: 0 0 0 0 rgba(25, 118, 210, 0); }
    }
    
    .pyramid-node.focused {
      animation: pulse 2s infinite;
    }
    
    /* Hijos directos del nodo activo */
    .pyramid-node.active-child {
      transform: scale(1);
      opacity: 1;
      filter: saturate(1);
      box-shadow: 0 3px 7px rgba(0,0,0,0.25);
    }
    
    /* Indicador visual para nodos con hijos */
    .pyramid-node.has-children::after {
      content: "▼";
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    textarea {
      width: 100%;
      height: 70%;
      font-family: monospace;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
      resize: none;
    }
    
    #update-visualization {
      margin-top: 10px;
      padding: 8px 15px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    /* Estilos para pantallas pequeñas */
    @media (max-width: 768px) {
      .pyramid-node {
        min-width: 80px;
        padding: 10px 15px;
        font-size: 14px;
      }
      
      .pyramid-level {
        gap: 15px;
      }
    }
    
    /* Indicadores de navegación */
    .navigation-indicator {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0.7;
    }
    
    .indicator-left {
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .indicator-right {
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .indicator-up {
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .indicator-down {
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    /* Estilos para el indicador de más nodos */
    .more-nodes-indicator {
      background-color: #607D8B;
      color: white;
      padding: 8px 15px;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 10px;
      display: inline-block;
      font-size: 0.9em;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .more-nodes-indicator:hover {
      background-color: #455A64;
      transform: scale(1.05);
    }
    
    /* Contenedor para los nodos ocultos */
    .hidden-nodes-container {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(0,0,0,0.05);
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .hidden-nodes-container.visible {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .pyramid-node.hidden {
      display: none;
    }
    
    .children-navigation {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      gap: 5px;
    }
    
    .nav-prev, .nav-next {
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .nav-prev:disabled, .nav-next:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .nav-indicator {
      font-size: 12px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <h1>Visualizador de Taxonomía</h1>
      <div class="controls">
        <button id="load-data">Cargar Datos</button>
        <select id="format-selector">
          <option value="yaml">YAML</option>
          <option value="json">JSON</option>
        </select>
      </div>
    </div>
    
    <div class="main-content">
      <button class="toggle-panel" id="toggle-panel">≡</button>
      
      <div class="YAML-JSON" id="yaml-json-panel">
        <h2>Datos en formato <span id="current-format">YAML</span></h2>
        <textarea id="data-display"></textarea>
        <button id="update-visualization">Actualizar Visualización</button>
      </div>
      
      <div class="nodes-container" id="nodes-container">
        <div id="node-visualization">
          <!-- La visualización se generará aquí dinámicamente -->
        </div>
      </div>
    </div>
  </div>

  <!-- Incluir la biblioteca js-yaml para procesar YAML -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
  
  <script>
    // Configuración personalizable
    const config = {
      maxVisibleChildren: 6,  // Número máximo de nodos hijos visibles inicialmente
      animationDuration: 300, // Duración de las animaciones en milisegundos
      autoScrollDelay: 100,   // Retraso para el desplazamiento automático
      collapseByDefault: true // Colapsar nodos hijos por defecto
    };
    
    // Datos de ejemplo en formato YAML
    const yamlData = `# Ejemplo de taxonomía en YAML
taxonomia:
  - categoria: Animales
    subcategorias:
      - nombre: Mamíferos
        ejemplos:
          - Perro
          - Gato
          - Elefante
          - León
          - Tigre
          - Oso
          - Jirafa
          - Cebra
          - Rinoceronte
          - Hipopótamo
      - nombre: Aves
        ejemplos:
          - Águila
          - Pingüino
          - Colibrí
          - Búho
          - Pato
          - Gallina
          - Pavo
          - Flamenco
  - categoria: Plantas
    subcategorias:
      - nombre: Árboles
        ejemplos:
          - Roble
          - Pino
          - Sauce
          - Abeto
          - Cedro
          - Arce
          - Olmo
      - nombre: Flores
        ejemplos:
          - Rosa
          - Tulipán
          - Girasol
          - Margarita
          - Orquídea
          - Lirio
          - Clavel
          - Violeta`;

    // Variables globales
    let currentFocusedNode = null;
    
    // Función para convertir YAML a JSON
    function yamlToJson(yamlString) {
      return jsyaml.load(yamlString);
    }
    
    // Función para convertir JSON a YAML
    function jsonToYaml(jsonObj) {
      return jsyaml.dump(jsonObj);
    }
    
    // Función para generar la visualización de nodos
    function updateNodeVisualization(data) {
      const nodeVisualization = document.getElementById('node-visualization');
      
      try {
        if (typeof data === 'string') {
          // Si es YAML, convertir a JSON
          data = yamlToJson(data);
        }
        
        console.log("Datos procesados:", data);
        
        // Estructura para organizar los nodos por niveles
        const levels = [
          [{ text: 'Taxonomía', type: 'main', parent: null, id: 'root' }], // Nivel 0: Raíz
          [], // Nivel 1: Categorías
          [], // Nivel 2: Subcategorías
          []  // Nivel 3: Ejemplos
        ];
        
        // Procesar categorías (nivel 1)
        if (data.taxonomia && Array.isArray(data.taxonomia)) {
          data.taxonomia.forEach((categoria, catIndex) => {
            levels[1].push({
              text: categoria.categoria,
              type: 'category',
              parent: 'root',
              id: `cat_${catIndex}`
            });
            
            // Procesar subcategorías (nivel 2)
            if (categoria.subcategorias && Array.isArray(categoria.subcategorias)) {
              categoria.subcategorias.forEach((subcategoria, subIndex) => {
                levels[2].push({
                  text: subcategoria.nombre,
                  type: 'subcategory',
                  parent: `cat_${catIndex}`,
                  id: `subcat_${catIndex}_${subIndex}`
                });
                
                // Procesar ejemplos (nivel 3)
                if (subcategoria.ejemplos && Array.isArray(subcategoria.ejemplos)) {
                  subcategoria.ejemplos.forEach((ejemplo, ejIndex) => {
                    levels[3].push({
                      text: ejemplo,
                      type: 'example',
                      parent: `subcat_${catIndex}_${subIndex}`,
                      id: `example_${catIndex}_${subIndex}_${ejIndex}`
                    });
                  });
                }
              });
            }
          });
        }
        
        console.log("Niveles generados:", levels);
        
        // Generar HTML para la visualización
        let html = '<div class="pyramid-container">';
        
        // Para cada nivel (excepto el último que se manejará de forma especial)
        for (let levelIndex = 0; levelIndex < levels.length - 1; levelIndex++) {
          const level = levels[levelIndex];
          
          if (level.length > 0) {
            html += `<div class="pyramid-level" data-level="${levelIndex}">`;
            
            // Agrupar nodos por padre
            const nodesByParent = {};
            level.forEach(node => {
              const parentId = node.parent || 'null';
              if (!nodesByParent[parentId]) {
                nodesByParent[parentId] = [];
              }
              nodesByParent[parentId].push(node);
            });
            
            // Para cada grupo de nodos con el mismo padre
            const possibleParents = Object.keys(nodesByParent);
            possibleParents.forEach(parentId => {
              const children = nodesByParent[parentId] || [];
              
              children.forEach((node, nodeIndex) => {
                const nodeType = node.type;
                const parentAttr = node.parent ? `data-parent="${node.parent}"` : 'data-parent="null"';
                const hasChildren = levels[levelIndex + 1].some(child => child.parent === node.id);
                const collapseClass = hasChildren ? 'collapsed' : '';
                
                // Crear un grupo para el nodo y sus posibles hijos
                html += `<div class="node-group" data-node-id="${node.id}">`;
                
                // El nodo principal
                html += `<div class="pyramid-node ${nodeType} ${collapseClass}" tabindex="0" 
                             data-row="${levelIndex}" data-col="${nodeIndex}" 
                             ${parentAttr} data-id="${node.id}">
                          ${node.text}
                        </div>`;
                
                // Si es el último nivel antes de los ejemplos, añadir contenedor para ejemplos
                if (levelIndex === levels.length - 2) {
                  // Obtener los ejemplos para este nodo
                  const examples = levels[levelIndex + 1].filter(example => example.parent === node.id);
                  
                  if (examples.length > 0) {
                    // Contenedor para ejemplos (inicialmente oculto)
                    html += `<div class="children-container" id="children_${node.id}" data-total-children="${examples.length}" data-visible-start="0">`;
                    
                    // Mostrar todos los ejemplos, pero solo los primeros N visibles inicialmente
                    examples.forEach((example, exIndex) => {
                      const isVisible = exIndex < config.maxVisibleChildren;
                      html += `<div class="pyramid-node ${example.type} ${isVisible ? '' : 'hidden'}" tabindex="0" 
                                   data-row="${levelIndex + 1}" data-col="${exIndex}" 
                                   data-parent="${node.id}" data-id="${example.id}" data-index="${exIndex}">
                                ${example.text}
                              </div>`;
                    });
                    
                    // Añadir controles de navegación si hay más de maxVisibleChildren
                    if (examples.length > config.maxVisibleChildren) {
                      html += `<div class="children-navigation">
                                <button class="nav-prev" disabled>▲</button>
                                <span class="nav-indicator">1-${config.maxVisibleChildren} de ${examples.length}</span>
                                <button class="nav-next">▼</button>
                              </div>`;
                    }
                    
                    html += '</div>'; // Cerrar contenedor de ejemplos
                  }
                }
                
                html += '</div>'; // Cerrar grupo de nodo
              });
            });
            
            html += '</div>'; // Cerrar nivel
          }
        }
        
        html += '</div>'; // Cerrar contenedor principal
        nodeVisualization.innerHTML = html;
        
        console.log("HTML generado:", html);
        
        // Configurar eventos para los nodos
        setupNodeEvents();
        
        // Configurar navegación con teclado
        setupKeyboardNavigation();
        
        // Configurar controles de navegación para contenedores de hijos
        setupChildrenNavigation();
        
        // Mostrar indicadores de navegación si es necesario
        checkForOverflow();
        
      } catch (e) {
        console.error("Error al actualizar la visualización:", e);
        nodeVisualization.innerHTML = '<p>Error al generar la visualización. Verifica el formato de los datos.</p>';
      }
    }
    
    // Función para configurar los controles de navegación en contenedores de hijos
    function setupChildrenNavigation() {
      // Configurar botones de navegación
      document.querySelectorAll('.nav-next').forEach(button => {
        button.addEventListener('click', function() {
          const container = this.closest('.children-container');
          const totalChildren = parseInt(container.getAttribute('data-total-children'));
          let visibleStart = parseInt(container.getAttribute('data-visible-start'));
          
          // Calcular el nuevo índice de inicio
          if (visibleStart + config.maxVisibleChildren < totalChildren) {
            visibleStart++;
            container.setAttribute('data-visible-start', visibleStart);
            
            // Actualizar visibilidad de los nodos
            updateVisibleChildren(container, visibleStart);
            
            // Actualizar estado de los botones
            updateNavigationButtons(container, visibleStart, totalChildren);
          }
        });
      });
      
      document.querySelectorAll('.nav-prev').forEach(button => {
        button.addEventListener('click', function() {
          const container = this.closest('.children-container');
          let visibleStart = parseInt(container.getAttribute('data-visible-start'));
          
          // Calcular el nuevo índice de inicio
          if (visibleStart > 0) {
            visibleStart--;
            container.setAttribute('data-visible-start', visibleStart);
            
            // Actualizar visibilidad de los nodos
            updateVisibleChildren(container, visibleStart);
            
            // Actualizar estado de los botones
            updateNavigationButtons(container, visibleStart, parseInt(container.getAttribute('data-total-children')));
          }
        });
      });
    }
    
    // Función para actualizar la visibilidad de los nodos hijos
    function updateVisibleChildren(container, startIndex) {
      const children = container.querySelectorAll('.pyramid-node');
      const totalChildren = children.length;
      
      // Ocultar todos los nodos
      children.forEach(child => {
        child.classList.add('hidden');
      });
      
      // Mostrar solo los nodos en el rango visible
      for (let i = startIndex; i < Math.min(startIndex + config.maxVisibleChildren, totalChildren); i++) {
        children[i].classList.remove('hidden');
      }
      
      // Actualizar el indicador de navegación
      const endIndex = Math.min(startIndex + config.maxVisibleChildren, totalChildren);
      const indicator = container.querySelector('.nav-indicator');
      if (indicator) {
        indicator.textContent = `${startIndex + 1}-${endIndex} de ${totalChildren}`;
      }
    }
    
    // Función para actualizar el estado de los botones de navegación
    function updateNavigationButtons(container, startIndex, totalChildren) {
      const prevButton = container.querySelector('.nav-prev');
      const nextButton = container.querySelector('.nav-next');
      
      if (prevButton) {
        prevButton.disabled = startIndex === 0;
      }
      
      if (nextButton) {
        nextButton.disabled = startIndex + config.maxVisibleChildren >= totalChildren;
      }
    }
    
    // Función para actualizar el estado visual de los nodos
    function updateNodesVisualState(focusedNodeId = null) {
      // Obtener todos los nodos
      const allNodes = document.querySelectorAll('.pyramid-node');
      
      // Primero, restablecer todos los nodos a su estado minimizado
      allNodes.forEach(node => {
        node.classList.remove('focused', 'active-child');
        node.classList.add('minimized');
        
        // Restaurar colores originales según el tipo de nodo
        const nodeType = node.classList.contains('main') ? 'main' : 
                         node.classList.contains('category') ? 'category' :
                         node.classList.contains('subcategory') ? 'subcategory' : 'example';
        
        // Marcar nodos que tienen hijos
        const nodeId = node.getAttribute('data-id');
        const hasChildren = document.querySelector(`.pyramid-node[data-parent="${nodeId}"]`) !== null;
        
        if (hasChildren) {
          node.classList.add('has-children');
        } else {
          node.classList.remove('has-children');
        }
      });
      
      if (focusedNodeId) {
        // Obtener el nodo enfocado
        const focusedNode = document.querySelector(`.pyramid-node[data-id="${focusedNodeId}"]`);
        
        if (focusedNode) {
          // Activar el nodo enfocado
          focusedNode.classList.add('focused');
          focusedNode.classList.remove('minimized');
          
          // Mostrar información del nodo enfocado en la consola (para depuración)
          console.log('Nodo enfocado:', focusedNode.textContent, 'ID:', focusedNodeId);
          
          // Activar el padre del nodo enfocado
          const parentId = focusedNode.getAttribute('data-parent');
          if (parentId && parentId !== 'null') {
            const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
            if (parentNode) {
              parentNode.classList.remove('minimized');
            }
            
            // Activar los hermanos del nodo enfocado
            const siblings = document.querySelectorAll(`.pyramid-node[data-parent="${parentId}"]`);
            siblings.forEach(sibling => {
              sibling.classList.remove('minimized');
              sibling.classList.add('active-child');
            });
          }
          
          // Activar los hijos del nodo enfocado
          const childrenNodes = document.querySelectorAll(`.pyramid-node[data-parent="${focusedNodeId}"]`);
          childrenNodes.forEach(child => {
            child.classList.remove('minimized');
            child.classList.add('active-child');
          });
          
          // Si el nodo enfocado es un hijo, activar sus hermanos
          const focusedParentId = focusedNode.getAttribute('data-parent');
          if (focusedParentId && focusedParentId !== 'null') {
            const siblings = document.querySelectorAll(`.pyramid-node[data-parent="${focusedParentId}"]`);
            siblings.forEach(sibling => {
              sibling.classList.remove('minimized');
              sibling.classList.add('active-child');
            });
          }
        }
      } else {
        // Si no hay nodo enfocado, mostrar el nodo raíz y sus hijos normalmente
        const rootNode = document.querySelector('.pyramid-node[data-id="root"]');
        if (rootNode) {
          rootNode.classList.remove('minimized');
          rootNode.classList.add('focused');
          
          // Mostrar los hijos del nodo raíz normalmente
          const rootChildren = document.querySelectorAll('.pyramid-node[data-parent="root"]');
          rootChildren.forEach(child => {
            child.classList.remove('minimized');
            child.classList.add('active-child');
          });
        }
      }
    }
    
    // Configurar eventos para los nodos
    function setupNodeEvents() {
      let currentFocusedNode = null;
      
      const nodes = document.querySelectorAll('.pyramid-node');
      
      nodes.forEach(node => {
        // Marcar nodos que tienen hijos
        const nodeId = node.getAttribute('data-id');
        const hasChildren = document.querySelector(`.pyramid-node[data-parent="${nodeId}"]`) !== null;
        const childrenContainer = document.getElementById(`children_${nodeId}`);
        
        if (hasChildren) {
          node.classList.add('collapsed');
        }
        
        node.addEventListener('click', function() {
          // Quitar el foco del nodo anterior
          if (currentFocusedNode) {
            currentFocusedNode.classList.remove('focused');
          }
          
          // Establecer el foco en el nodo actual
          this.classList.add('focused');
          currentFocusedNode = this;
          
          // Actualizar el estado visual de todos los nodos
          updateNodesVisualState(this.getAttribute('data-id'));
          
          // Hacer scroll para asegurar que el nodo está visible
          this.scrollIntoView({ block: 'center', inline: 'center', behavior: 'smooth' });
        });
        
        // Añadir evento de teclado para expandir/colapsar con la barra espaciadora
        node.addEventListener('keydown', function(e) {
          if (e.key === ' ' || e.key === 'Spacebar') {
            e.preventDefault(); // Prevenir el desplazamiento de la página
            
            const nodeId = this.getAttribute('data-id');
            const childrenContainer = document.getElementById(`children_${nodeId}`);
            
            if (childrenContainer) {
              // Alternar visibilidad del contenedor de hijos
              childrenContainer.classList.toggle('visible');
              
              // Actualizar clase del nodo
              if (childrenContainer.classList.contains('visible')) {
                this.classList.remove('collapsed');
                this.classList.add('expanded');
              } else {
                this.classList.remove('expanded');
                this.classList.add('collapsed');
              }
            }
          }
        });
      });
    }
    
    // Configurar navegación con teclado
    function setupKeyboardNavigation() {
      let currentFocusedNode = null;
      
      // Primero, añadir evento de clic a todos los nodos
      const nodes = document.querySelectorAll('.pyramid-node');
      nodes.forEach(node => {
        node.addEventListener('click', function() {
          // Quitar el foco del nodo anterior
          if (currentFocusedNode) {
            currentFocusedNode.classList.remove('focused');
          }
          
          // Establecer el foco en el nodo actual
          this.classList.add('focused');
          currentFocusedNode = this;
          
          // Actualizar el estado visual de todos los nodos
          updateNodesVisualState(this.getAttribute('data-id'));
          
          // Hacer scroll para asegurar que el nodo está visible
          this.scrollIntoView({ block: 'center', inline: 'center', behavior: 'smooth' });
        });
      });
      
      // Añadir evento de teclado para navegación
      document.addEventListener('keydown', function(e) {
        if (!currentFocusedNode) {
          // Si no hay nodo seleccionado, seleccionar el primero
          if (nodes.length > 0 && (e.key === 'ArrowDown' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowLeft')) {
            nodes[0].click();
            e.preventDefault();
          }
          return;
        }
        
        // Expandir/colapsar con la barra espaciadora
        if (e.key === ' ' || e.key === 'Spacebar') {
          e.preventDefault(); // Prevenir el desplazamiento de la página
          
          const nodeId = currentFocusedNode.getAttribute('data-id');
          const childrenContainer = document.getElementById(`children_${nodeId}`);
          
          if (childrenContainer) {
            // Alternar visibilidad del contenedor de hijos
            childrenContainer.classList.toggle('visible');
            
            // Actualizar clase del nodo
            if (childrenContainer.classList.contains('visible')) {
              currentFocusedNode.classList.remove('collapsed');
              currentFocusedNode.classList.add('expanded');
              
              // Si se expande, hacer visibles los nodos hijos para la navegación
              const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
              childNodes.forEach(child => {
                child.classList.remove('minimized');
                child.classList.add('active-child');
              });
            } else {
              currentFocusedNode.classList.remove('expanded');
              currentFocusedNode.classList.add('collapsed');
            }
          }
          
          return;
        }
        
        // Obtener información del nodo actual
        const currentRow = parseInt(currentFocusedNode.getAttribute('data-row'));
        const currentId = currentFocusedNode.getAttribute('data-id');
        const currentParent = currentFocusedNode.getAttribute('data-parent');
        
        let nextNode = null;
        
        switch (e.key) {
          case 'ArrowUp':
            // Verificar si estamos en un contenedor de hijos
            const isInChildrenContainerUp = currentFocusedNode.closest('.children-container') !== null;
            
            if (isInChildrenContainerUp) {
              // Si estamos en un contenedor de hijos, buscar el nodo anterior en el mismo contenedor
              const container = currentFocusedNode.closest('.children-container');
              const nodesInContainer = Array.from(container.querySelectorAll('.pyramid-node'));
              const currentIndex = nodesInContainer.indexOf(currentFocusedNode);
              
              if (currentIndex > 0) {
                // Ir al nodo anterior en el contenedor
                nextNode = nodesInContainer[currentIndex - 1];
                
                // Si el nodo anterior está oculto, ajustar la visualización
                if (nextNode.classList.contains('hidden')) {
                  let visibleStart = parseInt(container.getAttribute('data-visible-start'));
                  visibleStart--;
                  container.setAttribute('data-visible-start', visibleStart);
                  updateVisibleChildren(container, visibleStart);
                  updateNavigationButtons(container, visibleStart, nodesInContainer.length);
                }
              } else {
                // Si es el primer nodo del contenedor, ir al padre
                const parentId = container.id.replace('children_', '');
                nextNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
              }
            } else {
              // Navegar al nivel superior (padre)
              if (currentParent && currentParent !== 'null') {
                nextNode = document.querySelector(`.pyramid-node[data-id="${currentParent}"]`);
              } else {
                // Si no hay padre, intentar navegar al nivel anterior en la pirámide
                const prevLevel = document.querySelector(`.pyramid-level[data-level="${currentRow - 1}"]`);
                if (prevLevel) {
                  // Encontrar el nodo más cercano horizontalmente en el nivel anterior
                  const currentRect = currentFocusedNode.getBoundingClientRect();
                  const nodesInPrevLevel = prevLevel.querySelectorAll('.pyramid-node');
                  
                  if (nodesInPrevLevel.length > 0) {
                    let closestNode = nodesInPrevLevel[0];
                    let minDistance = Infinity;
                    
                    nodesInPrevLevel.forEach(node => {
                      const nodeRect = node.getBoundingClientRect();
                      const distance = Math.abs(nodeRect.left - currentRect.left);
                      if (distance < minDistance) {
                        minDistance = distance;
                        closestNode = node;
                      }
                    });
                    
                    nextNode = closestNode;
                  }
                }
              }
            }
            break;
            
          case 'ArrowDown':
            // Verificar si estamos en un contenedor de hijos
            const isInChildrenContainerDown = currentFocusedNode.closest('.children-container') !== null;
            
            if (isInChildrenContainerDown) {
              // Si estamos en un contenedor de hijos, buscar el nodo siguiente en el mismo contenedor
              const container = currentFocusedNode.closest('.children-container');
              const nodesInContainer = Array.from(container.querySelectorAll('.pyramid-node'));
              const currentIndex = nodesInContainer.indexOf(currentFocusedNode);
              
              if (currentIndex < nodesInContainer.length - 1) {
                // Ir al siguiente nodo en el contenedor
                nextNode = nodesInContainer[currentIndex + 1];
                
                // Si el siguiente nodo está oculto, ajustar la visualización
                if (nextNode.classList.contains('hidden')) {
                  let visibleStart = parseInt(container.getAttribute('data-visible-start'));
                  visibleStart++;
                  container.setAttribute('data-visible-start', visibleStart);
                  updateVisibleChildren(container, visibleStart);
                  updateNavigationButtons(container, visibleStart, nodesInContainer.length);
                }
              } else {
                // Si es el último nodo, intentar navegar al siguiente nivel o hermano
                // Código existente para navegación fuera de contenedores
                // ...
              }
            } else {
              // Navegar al nivel inferior (primer hijo)
              // Primero verificar si hay un contenedor de hijos visible
              const childrenContainer = document.getElementById(`children_${currentId}`);
              if (childrenContainer && childrenContainer.classList.contains('visible')) {
                // Si el contenedor está visible, seleccionar el primer hijo dentro del contenedor
                const visibleChildren = childrenContainer.querySelectorAll('.pyramid-node');
                if (visibleChildren.length > 0) {
                  nextNode = visibleChildren[0];
                  break;
                }
              }
              
              // Si no hay contenedor visible o está vacío, buscar hijos en el DOM general
              const children = document.querySelectorAll(`.pyramid-node[data-parent="${currentId}"]`);
              
              if (children.length > 0) {
                // Ordenar los hijos por su posición visual (izquierda a derecha)
                const sortedChildren = Array.from(children).sort((a, b) => {
                  const rectA = a.getBoundingClientRect();
                  const rectB = b.getBoundingClientRect();
                  return rectA.left - rectB.left;
                });
                
                // Seleccionar el primer hijo (el más a la izquierda)
                nextNode = sortedChildren[0];
              } else {
                // Si no hay hijos, intentar navegar al siguiente nivel en la pirámide
                const nextLevel = document.querySelector(`.pyramid-level[data-level="${currentRow + 1}"]`);
                if (nextLevel) {
                  // Encontrar el nodo más cercano horizontalmente en el siguiente nivel
                  const currentRect = currentFocusedNode.getBoundingClientRect();
                  const nodesInNextLevel = nextLevel.querySelectorAll('.pyramid-node');
                  
                  if (nodesInNextLevel.length > 0) {
                    let closestNode = nodesInNextLevel[0];
                    let minDistance = Infinity;
                    
                    nodesInNextLevel.forEach(node => {
                      const nodeRect = node.getBoundingClientRect();
                      const distance = Math.abs(nodeRect.left - currentRect.left);
                      if (distance < minDistance) {
                        minDistance = distance;
                        closestNode = node;
                      }
                    });
                    
                    nextNode = closestNode;
                  }
                }
              }
            }
            break;
            
          case 'ArrowLeft':
            // Verificar si estamos en un contenedor de hijos
            const isInChildrenContainer = currentFocusedNode.closest('.children-container') !== null;
            
            if (isInChildrenContainer) {
              // Si estamos en un contenedor de hijos, buscar el nodo anterior en el mismo contenedor
              const container = currentFocusedNode.closest('.children-container');
              const nodesInContainer = Array.from(container.querySelectorAll('.pyramid-node'));
              const currentIndex = nodesInContainer.indexOf(currentFocusedNode);
              
              if (currentIndex > 0) {
                nextNode = nodesInContainer[currentIndex - 1];
              } else {
                // Si es el primer nodo del contenedor, ir al padre
                const parentId = container.id.replace('children_', '');
                nextNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
              }
            } else {
              // Navegar al nodo a la izquierda en el mismo nivel
              // Obtener todos los nodos del mismo nivel y con el mismo padre
              const siblingNodes = document.querySelectorAll(
                `.pyramid-node[data-row="${currentRow}"][data-parent="${currentParent}"]`
              );
              
              if (siblingNodes.length > 1) {
                // Ordenar los nodos por su posición visual (izquierda a derecha)
                const sortedSiblings = Array.from(siblingNodes).sort((a, b) => {
                  const rectA = a.getBoundingClientRect();
                  const rectB = b.getBoundingClientRect();
                  return rectA.left - rectB.left;
                });
                
                // Encontrar el índice del nodo actual
                const currentIndex = sortedSiblings.findIndex(node => node === currentFocusedNode);
                
                // Seleccionar el nodo a la izquierda si existe
                if (currentIndex > 0) {
                  nextNode = sortedSiblings[currentIndex - 1];
                }
              }
            }
            break;
            
          case 'ArrowRight':
            // Verificar si estamos en un contenedor de hijos
            const isInContainer = currentFocusedNode.closest('.children-container') !== null;
            
            if (isInContainer) {
              // Si estamos en un contenedor de hijos, buscar el nodo siguiente en el mismo contenedor
              const container = currentFocusedNode.closest('.children-container');
              const nodesInContainer = Array.from(container.querySelectorAll('.pyramid-node'));
              const currentIndex = nodesInContainer.indexOf(currentFocusedNode);
              
              if (currentIndex < nodesInContainer.length - 1) {
                nextNode = nodesInContainer[currentIndex + 1];
              }
            } else {
              // Navegar al nodo a la derecha en el mismo nivel
              // Obtener todos los nodos del mismo nivel y con el mismo padre
              const siblingNodesRight = document.querySelectorAll(
                `.pyramid-node[data-row="${currentRow}"][data-parent="${currentParent}"]`
              );
              
              if (siblingNodesRight.length > 1) {
                // Ordenar los nodos por su posición visual (izquierda a derecha)
                const sortedSiblingsRight = Array.from(siblingNodesRight).sort((a, b) => {
                  const rectA = a.getBoundingClientRect();
                  const rectB = b.getBoundingClientRect();
                  return rectA.left - rectB.left;
                });
                
                // Encontrar el índice del nodo actual
                const currentIndexRight = sortedSiblingsRight.findIndex(node => node === currentFocusedNode);
                
                // Seleccionar el nodo a la derecha si existe
                if (currentIndexRight < sortedSiblingsRight.length - 1) {
                  nextNode = sortedSiblingsRight[currentIndexRight + 1];
                } else {
                  // Si es el último nodo, verificar si tiene hijos y expandirlos
                  const childrenContainer = document.getElementById(`children_${currentId}`);
                  if (childrenContainer && !childrenContainer.classList.contains('visible')) {
                    // Expandir el contenedor de hijos
                    childrenContainer.classList.add('visible');
                    currentFocusedNode.classList.remove('collapsed');
                    currentFocusedNode.classList.add('expanded');
                    
                    // Seleccionar el primer hijo
                    const firstChild = childrenContainer.querySelector('.pyramid-node');
                    if (firstChild) {
                      nextNode = firstChild;
                    }
                  }
                }
              } else {
                // Si no hay hermanos, verificar si tiene hijos y expandirlos
                const childrenContainer = document.getElementById(`children_${currentId}`);
                if (childrenContainer && !childrenContainer.classList.contains('visible')) {
                  // Expandir el contenedor de hijos
                  childrenContainer.classList.add('visible');
                  currentFocusedNode.classList.remove('collapsed');
                  currentFocusedNode.classList.add('expanded');
                  
                  // Seleccionar el primer hijo
                  const firstChild = childrenContainer.querySelector('.pyramid-node');
                  if (firstChild) {
                    nextNode = firstChild;
                  }
                }
              }
            }
            break;
        }
        
        if (nextNode) {
          nextNode.click();
          e.preventDefault();
        }
      });
    }
    
    // Función para alternar la visibilidad del panel YAML-JSON
    document.getElementById('toggle-panel').addEventListener('click', function() {
      const panel = document.getElementById('yaml-json-panel');
      panel.classList.toggle('visible');
      
      // Cambiar el ícono del botón
      this.textContent = panel.classList.contains('visible') ? '×' : '≡';
    });
    
    // Evento para cambiar entre formatos
    document.getElementById('format-selector').addEventListener('change', function() {
      const format = this.value;
      document.getElementById('current-format').textContent = format.toUpperCase();
      
      if (format === 'json') {
        // Convertir YAML a JSON
        try {
          const jsonData = yamlToJson(document.getElementById('data-display').value);
          document.getElementById('data-display').value = JSON.stringify(jsonData, null, 2);
        } catch (e) {
          console.error("Error al convertir a JSON:", e);
          document.getElementById('data-display').value = "Error al convertir a JSON. Verifica el formato YAML.";
        }
      } else {
        // Convertir JSON a YAML
        try {
          const jsonText = document.getElementById('data-display').value;
          const jsonObj = JSON.parse(jsonText);
          const yamlData = jsonToYaml(jsonObj);
          document.getElementById('data-display').value = yamlData;
        } catch (e) {
          console.error("Error al convertir a YAML:", e);
          document.getElementById('data-display').value = "# Error al convertir a YAML. Verifica el formato JSON.";
        }
      }
    });
    
    // Evento para actualizar la visualización
    document.getElementById('update-visualization').addEventListener('click', function() {
      const format = document.getElementById('format-selector').value;
      const dataText = document.getElementById('data-display').value;
      
      if (format === 'json') {
        try {
          const jsonObj = JSON.parse(dataText);
          updateNodeVisualization(jsonObj);
        } catch (e) {
          console.error("Error al parsear JSON:", e);
          alert("Error al parsear JSON. Verifica el formato.");
        }
      } else {
        updateNodeVisualization(dataText);
      }
    });
    
    // Función para verificar si hay desbordamiento y mostrar indicadores
    function checkForOverflow() {
      const container = document.querySelector('.nodes-container');
      const content = document.querySelector('.pyramid-container');
      
      if (!container || !content) return;
      
      // Eliminar indicadores existentes
      document.querySelectorAll('.navigation-indicator').forEach(el => el.remove());
      
      // Verificar desbordamiento horizontal
      if (content.scrollWidth > container.clientWidth) {
        // Hay contenido fuera de la vista a la derecha
        const rightIndicator = document.createElement('div');
        rightIndicator.className = 'navigation-indicator indicator-right';
        rightIndicator.textContent = '→';
        container.appendChild(rightIndicator);
        
        // Hay contenido fuera de la vista a la izquierda
        const leftIndicator = document.createElement('div');
        leftIndicator.className = 'navigation-indicator indicator-left';
        leftIndicator.textContent = '←';
        container.appendChild(leftIndicator);
      }
      
      // Verificar desbordamiento vertical
      if (content.scrollHeight > container.clientHeight) {
        // Hay contenido fuera de la vista abajo
        const downIndicator = document.createElement('div');
        downIndicator.className = 'navigation-indicator indicator-down';
        downIndicator.textContent = '↓';
        container.appendChild(downIndicator);
        
        // Hay contenido fuera de la vista arriba
        const upIndicator = document.createElement('div');
        upIndicator.className = 'navigation-indicator indicator-up';
        upIndicator.textContent = '↑';
        container.appendChild(upIndicator);
      }
    }
    
    // Inicializar la visualización al cargar la página
    document.addEventListener('DOMContentLoaded', function() {
      // Verificar que jsyaml esté cargado
      if (typeof jsyaml === 'undefined') {
        console.error("Error: jsyaml no está cargado");
        document.getElementById('node-visualization').innerHTML = 
          '<p>Error: No se pudo cargar la biblioteca js-yaml. Verifica las dependencias.</p>';
        return;
      }
      
      // Cargar datos iniciales
      document.getElementById('data-display').value = yamlData;
      
      // Generar visualización inicial
      updateNodeVisualization(yamlData);
      
      // Añadir evento de redimensionamiento para actualizar indicadores
      window.addEventListener('resize', checkForOverflow);
      
      // Añadir eventos de desplazamiento para actualizar indicadores
      document.querySelector('.nodes-container').addEventListener('scroll', function() {
        // Actualizar visibilidad de indicadores según la posición de desplazamiento
        const indicators = document.querySelectorAll('.navigation-indicator');
        indicators.forEach(indicator => {
          indicator.style.opacity = '0.7';
          setTimeout(() => {
            indicator.style.opacity = '0';
          }, 1500);
        });
      });
      
      // Inicializar el estado visual de los nodos
      setTimeout(() => {
        updateNodesVisualState();
      }, config.autoScrollDelay);
    });
  </script>
</body>
</html>