<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualizador de Taxonom√≠a</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    
    .container {
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .top-bar {
      background-color: #333;
      color: white;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 60px;
      box-sizing: border-box;
    }
    
    .top-bar h1 {
      margin: 0;
      font-size: 1.5rem;
    }
    
    .controls {
      display: flex;
      gap: 10px;
    }
    
    .controls button, .controls select {
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
    }
    
    .main-content {
      display: flex;
      height: calc(100vh - 60px - 40px);
      position: relative;
    }
    
    .YAML-JSON {
      width: 30%;
      background-color: #f5f5f5;
      padding: 20px;
      box-sizing: border-box;
      overflow: auto;
      transform: translateX(-100%);
      position: absolute;
      height: 100%;
      transition: transform 0.3s ease;
      z-index: 10;
    }
    
    .YAML-JSON.visible {
      transform: translateX(0);
    }
    
    .nodes-container {
      width: 100%;
      height: 100%;
      overflow: auto;
      padding: 20px;
      box-sizing: border-box;
    }
    
    .toggle-panel {
      position: fixed;
      top: 50%;
      left: 10px;
      width: 40px;
      height: 40px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .toggle-props-panel {
      position: fixed;
      top: 50%;
      right: 10px;
      width: 40px;
      height: 40px;
      background-color: #333;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .toggle-panel:hover, .toggle-props-panel:hover {
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      transition: all 0.2s ease;
    }
    
    /* Estilos para la visualizaci√≥n de nodos */
    .pyramid-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 30px;
      padding: 40px 20px;
      width: 100%;
      box-sizing: border-box;
    }
    
    .pyramid-level {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 20px;
      width: 100%;
      padding: 0 10px;
    }
    
    /* Contenedor para un nodo y sus hijos */
    .node-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 10px;
    }
    
    /* Contenedor para los hijos de un nodo */
    .children-container {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(0,0,0,0.05);
      border-radius: 8px;
      max-width: 300px;
      overflow-y: auto;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    .children-container.visible {
      display: flex;
      animation: fadeIn 0.3s ease;
    }
    
    /* Estilos para nodos colapsados/expandidos */
    .pyramid-node.collapsed::after {
      content: "‚ñ∂";
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    .pyramid-node.expanded::after {
      content: "‚ñº";
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    .pyramid-node {
      padding: 12px 20px;
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      min-width: 100px;
      max-width: 150px;
      word-wrap: break-word;
      flex-shrink: 0;
      position: relative;
    }
    
    /* Nodos minimizados (subnodos cuando su padre no est√° activo) */
    .pyramid-node.minimized {
      transform: scale(0.8);
      opacity: 0.7;
      filter: saturate(0.7);
    }
    
    /* Estilos para los diferentes tipos de nodos */
    .pyramid-node.main {
      background-color: #2196F3; /* Azul para el nodo principal */
      color: white;
    }
    
    .pyramid-node.category {
      background-color: #4CAF50; /* Verde para categor√≠as */
      color: white;
    }
    
    .pyramid-node.subcategory {
      background-color: #FF9800; /* Naranja para subcategor√≠as */
      color: white;
    }
    
    .pyramid-node.example {
      background-color: #9C27B0; /* P√∫rpura para ejemplos */
      color: white;
    }
    
    /* Nodo actualmente seleccionado/enfocado */
    .pyramid-node.focused {
      transform: scale(1.1);
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      z-index: 5;
      background-color: #1976D2; /* Azul m√°s oscuro para el nodo enfocado */
      border: 3px solid #0D47A1; /* Borde azul oscuro */
      color: white;
      font-weight: bold;
    }
    
    /* Efecto de brillo para el nodo enfocado */
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(25, 118, 210, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(25, 118, 210, 0); }
      100% { box-shadow: 0 0 0 0 rgba(25, 118, 210, 0); }
    }
    
    .pyramid-node.focused {
      animation: pulse 2s infinite;
    }
    
    /* Hijos directos del nodo activo */
    .pyramid-node.active-child {
      transform: scale(1);
      opacity: 1;
      filter: saturate(1);
      box-shadow: 0 3px 7px rgba(0,0,0,0.25);
    }
    
    /* Indicador visual para nodos con hijos */
    .pyramid-node.has-children::after {
      content: "‚ñº";
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      opacity: 0.7;
    }
    
    textarea {
      width: 100%;
      height: 70%;
      font-family: monospace;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
      resize: none;
    }
    
    #update-visualization {
      margin-top: 10px;
      padding: 8px 15px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    /* Estilos para pantallas peque√±as */
    @media (max-width: 768px) {
      .pyramid-node {
        min-width: 80px;
        padding: 10px 15px;
        font-size: 14px;
      }
      
      .pyramid-level {
        gap: 15px;
      }
    }
    
    /* Indicadores de navegaci√≥n */
    .navigation-indicator {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0.7;
    }
    
    .indicator-left {
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .indicator-right {
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .indicator-up {
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .indicator-down {
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    /* Estilos para el indicador de m√°s nodos */
    .more-nodes-indicator {
      background-color: #607D8B;
      color: white;
      padding: 8px 15px;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 10px;
      display: inline-block;
      font-size: 0.9em;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .more-nodes-indicator:hover {
      background-color: #455A64;
      transform: scale(1.05);
    }
    
    /* Contenedor para los nodos ocultos */
    .hidden-nodes-container {
      display: none;
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(0,0,0,0.05);
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .hidden-nodes-container.visible {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .pyramid-node.hidden {
      display: none;
    }
    
    .children-navigation {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 10px;
      gap: 5px;
    }
    
    .nav-prev, .nav-next {
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .nav-prev:disabled, .nav-next:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    
    .nav-indicator {
      font-size: 12px;
      color: #666;
    }
    
    /* Estilos para el panel de informaci√≥n */
    .info-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #333;
      color: white;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 40px;
      box-sizing: border-box;
      z-index: 30;
      font-size: 14px;
    }
    
    .info-panel-content {
      display: flex;
      gap: 20px;
    }
    
    .info-label {
      font-weight: bold;
      color: #4CAF50;
    }
    
    .info-panel.fixed {
      background-color: #4CAF50 !important;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
    }
    
    .info-panel.fixed::before {
      content: "üìå";
      margin-right: 10px;
    }
    
    .pyramid-node.pinned {
      border: 3px solid #FFD700 !important; /* Borde dorado para el nodo fijado principal */
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.7) !important; /* Sombra dorada */
      z-index: 10 !important; /* Asegurar que est√© por encima de otros nodos */
    }
    
    .pyramid-node.pinned::before {
      content: "1Ô∏è‚É£";
      position: absolute;
      top: -10px;
      right: -10px;
      font-size: 12px;
      background-color: #FFD700;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    
    .pyramid-node.secondary-pinned {
      border: 3px solid #1E90FF !important; /* Borde azul para el nodo fijado secundario */
      box-shadow: 0 0 10px rgba(30, 144, 255, 0.7) !important; /* Sombra azul */
      z-index: 9 !important; /* Justo debajo del nodo principal */
    }
    
    .pyramid-node.secondary-pinned::before {
      content: "2Ô∏è‚É£";
      position: absolute;
      top: -10px;
      right: -10px;
      font-size: 12px;
      background-color: #1E90FF;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    
    /* Estilos para el desplazamiento del contenedor de nodos */
    .nodes-container {
      transition: margin-left 0.3s ease;
    }
    
    .nodes-container.shifted {
      margin-left: 0; /* El panel YAML-JSON tiene su propio espacio */
    }
    
    /* Ajustar el dise√±o para evitar superposiciones */
    .main-content {
      display: flex;
      flex-direction: row;
      align-items: stretch;
      overflow: hidden;
    }
    
    .YAML-JSON {
      width: 0;
      overflow: hidden;
      transition: width 0.3s ease;
      flex-shrink: 0;
    }
    
    .YAML-JSON.visible {
      width: 40%; /* Ancho del panel cuando est√° visible */
      min-width: 300px;
      max-width: 500px;
    }
    
    .nodes-container {
      flex-grow: 1;
      overflow: auto;
      transition: margin-left 0.3s ease;
    }
    
    /* Asegurar que el bot√≥n de alternar siempre est√© visible */
    .toggle-panel {
      position: absolute;
      left: 10px;
      top: 10px;
      z-index: 1000;
    }
    
    /* Estilos para el panel de propiedades */
    .props-panel {
      width: 0;
      overflow: hidden;
      transition: width 0.3s ease;
      flex-shrink: 0;
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      background-color: #f5f5f5;
      z-index: 100;
      box-shadow: -2px 0 10px rgba(0,0,0,0.1);
      padding: 0;
      box-sizing: border-box;
    }
    
    .props-panel.visible {
      width: 40%;
      min-width: 300px;
      max-width: 500px;
      padding: 20px;
    }
    
    .toggle-props-panel {
      position: fixed;
      right: 10px;
      top: 10px;
      z-index: 1001;
      background-color: #333;
      color: white;
      border: none;
      border-radius: 4px;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .toggle-props-panel:hover {
      background-color: #555;
    }
    
    .main-content.props-panel-visible .nodes-container {
      margin-right: 40%;
      width: 60%;
    }
    
    /* Cuando ambos paneles est√°n visibles */
    .main-content.panel-visible.props-panel-visible .nodes-container {
      margin-left: 40%;
      margin-right: 40%;
      width: 20%;
    }
    
    /* Estilos para la visualizaci√≥n del √°rbol de propiedades */
    #props-tree {
      overflow: auto;
      max-height: calc(100% - 50px);
    }
    
    .prop-item {
      margin-bottom: 8px;
      padding: 8px;
      border-radius: 4px;
      background-color: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .prop-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      font-weight: bold;
    }
    
    .prop-children {
      margin-left: 20px;
      padding-left: 10px;
      border-left: 2px solid #ddd;
      margin-top: 8px;
      display: none;
    }
    
    .prop-children.visible {
      display: block;
    }
    
    .prop-toggle {
      margin-right: 5px;
      display: inline-block;
      width: 12px;
      height: 12px;
      text-align: center;
      line-height: 12px;
    }
    
    .prop-id {
      color: #666;
      font-size: 0.8em;
      margin-left: 10px;
    }
    
    .prop-value {
      color: #28a745;
      font-style: italic;
    }
    
    @media (max-width: 1200px) {
      .props-panel.visible {
        width: 350px;
        min-width: 300px;
      }
      
      .main-content.props-panel-visible .nodes-container {
        margin-right: 350px;
        width: calc(100% - 350px);
      }
      
      .main-content.panel-visible.props-panel-visible .nodes-container {
        margin-left: 350px;
        margin-right: 350px;
        width: calc(100% - 700px);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <h1>Visualizador de Taxonom√≠a</h1>
      <div class="controls">
        <button id="load-data">Cargar Datos</button>
        <select id="format-selector">
          <option value="yaml">YAML</option>
          <option value="json">JSON</option>
        </select>
      </div>
    </div>
    
    <div class="main-content">
      <button class="toggle-panel" id="toggle-panel">‚â°</button>
      <button class="toggle-props-panel" id="toggle-props-panel">‚öô</button>
      
      <div class="YAML-JSON" id="yaml-json-panel">
        <h2>Datos en formato <span id="current-format">YAML</span></h2>
        <textarea id="data-display"></textarea>
        <button id="update-visualization">Actualizar Visualizaci√≥n</button>
      </div>
      
      <div class="nodes-container" id="nodes-container">
        <div id="node-visualization">
          <!-- La visualizaci√≥n se generar√° aqu√≠ din√°micamente -->
        </div>
      </div>
      
      <div class="props-panel" id="props-panel">
        <h2>Jerarqu√≠a de Propiedades</h2>
        <div id="props-tree"></div>
      </div>
    </div>
    
    <!-- Panel de informaci√≥n del nodo -->
    <div class="info-panel" id="info-panel">
      <div class="info-panel-content">
        <div><span class="info-label">Nodo:</span> <span id="node-name">Ninguno seleccionado</span></div>
        <div><span class="info-label">ID:</span> <span id="node-id">-</span></div>
      </div>
    </div>
  </div>

  <!-- Incluir la biblioteca js-yaml para procesar YAML -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
  
  <script>
    // Configuraci√≥n personalizable
    const config = {
      maxVisibleChildren: 6,  // N√∫mero m√°ximo de nodos hijos visibles inicialmente
      animationDuration: 300, // Duraci√≥n de las animaciones en milisegundos
      autoScrollDelay: 100,   // Retraso para el desplazamiento autom√°tico
      collapseByDefault: true // Colapsar nodos hijos por defecto
    };
    
    // Datos de ejemplo en formato YAML
    const yamlData = `# Ejemplo de taxonom√≠a en YAML
taxonomia:
  - categoria: Animales
    subcategorias:
      - nombre: Mam√≠feros
        ejemplos:
          - Perro
          - Gato
          - Elefante
          - Le√≥n
          - Tigre
          - Oso
          - Jirafa
          - Cebra
          - Rinoceronte
          - Hipop√≥tamo
      - nombre: Aves
        ejemplos:
          - √Åguila
          - Ping√ºino
          - Colibr√≠
          - B√∫ho
          - Pato
          - Gallina
          - Pavo
          - Flamenco
  - categoria: Plantas
    subcategorias:
      - nombre: √Årboles
        ejemplos:
          - Roble
          - Pino
          - Sauce
          - Abeto
          - Cedro
          - Arce
          - Olmo
      - nombre: Flores
        ejemplos:
          - Rosa
          - Tulip√°n
          - Girasol
          - Margarita
          - Orqu√≠dea
          - Lirio
          - Clavel
          - Violeta`;

    // Variables globales
    let currentFocusedNode = null;
    let pinnedNode = null; // Nodo fijado principal
    let secondaryPinnedNode = null; // Segundo nodo fijado
    
    // Funci√≥n para convertir YAML a JSON
    function yamlToJson(yamlString) {
      return jsyaml.load(yamlString);
    }
    
    // Funci√≥n para convertir JSON a YAML
    function jsonToYaml(jsonObj) {
      return jsyaml.dump(jsonObj);
    }
    
    // Funci√≥n para generar la visualizaci√≥n de nodos
    function updateNodeVisualization(data) {
      const nodeVisualization = document.getElementById('node-visualization');
      
      try {
        if (typeof data === 'string') {
          // Si es YAML, convertir a JSON
          data = yamlToJson(data);
        }
        
        console.log("Datos procesados:", data);
        
        // Estructura para organizar los nodos por niveles
        const levels = [
          [{ text: 'Taxonom√≠a', type: 'main', parent: null, id: 'root' }], // Nivel 0: Ra√≠z
          [], // Nivel 1: Categor√≠as
          [], // Nivel 2: Subcategor√≠as
          []  // Nivel 3: Ejemplos
        ];
        
        // Procesar categor√≠as (nivel 1)
        if (data.taxonomia && Array.isArray(data.taxonomia)) {
          data.taxonomia.forEach((categoria, catIndex) => {
            levels[1].push({
              text: categoria.categoria,
              type: 'category',
              parent: 'root',
              id: `cat_${catIndex}`
            });
            
            // Procesar subcategor√≠as (nivel 2)
            if (categoria.subcategorias && Array.isArray(categoria.subcategorias)) {
              categoria.subcategorias.forEach((subcategoria, subIndex) => {
                levels[2].push({
                  text: subcategoria.nombre,
                  type: 'subcategory',
                  parent: `cat_${catIndex}`,
                  id: `subcat_${catIndex}_${subIndex}`
                });
                
                // Procesar ejemplos (nivel 3)
                if (subcategoria.ejemplos && Array.isArray(subcategoria.ejemplos)) {
                  subcategoria.ejemplos.forEach((ejemplo, ejIndex) => {
                    levels[3].push({
                      text: ejemplo,
                      type: 'example',
                      parent: `subcat_${catIndex}_${subIndex}`,
                      id: `example_${catIndex}_${subIndex}_${ejIndex}`
                    });
                  });
                }
              });
            }
          });
        }
        
        console.log("Niveles generados:", levels);
        
        // Generar HTML para la visualizaci√≥n
        let html = '<div class="pyramid-container">';
        
        // Para cada nivel (excepto el √∫ltimo que se manejar√° de forma especial)
        for (let levelIndex = 0; levelIndex < levels.length - 1; levelIndex++) {
          const level = levels[levelIndex];
          
          if (level.length > 0) {
            html += `<div class="pyramid-level" data-level="${levelIndex}">`;
            
            // Agrupar nodos por padre
            const nodesByParent = {};
            level.forEach(node => {
              const parentId = node.parent || 'null';
              if (!nodesByParent[parentId]) {
                nodesByParent[parentId] = [];
              }
              nodesByParent[parentId].push(node);
            });
            
            // Para cada grupo de nodos con el mismo padre
            const possibleParents = Object.keys(nodesByParent);
            possibleParents.forEach(parentId => {
              const children = nodesByParent[parentId] || [];
              
              children.forEach((node, nodeIndex) => {
                const nodeType = node.type;
                const parentAttr = node.parent ? `data-parent="${node.parent}"` : 'data-parent="null"';
                const hasChildren = levels[levelIndex + 1].some(child => child.parent === node.id);
                const collapseClass = hasChildren ? 'collapsed' : '';
                
                // Crear un grupo para el nodo y sus posibles hijos
                html += `<div class="node-group" data-node-id="${node.id}">`;
                
                // El nodo principal
                html += `<div class="pyramid-node ${nodeType} ${collapseClass}" tabindex="0" 
                             data-row="${levelIndex}" data-col="${nodeIndex}" 
                             ${parentAttr} data-id="${node.id}">
                          ${node.text}
                        </div>`;
                
                // Si es el √∫ltimo nivel antes de los ejemplos, a√±adir contenedor para ejemplos
                if (levelIndex === levels.length - 2) {
                  // Obtener los ejemplos para este nodo
                  const examples = levels[levelIndex + 1].filter(example => example.parent === node.id);
                  
                  if (examples.length > 0) {
                    // Contenedor para ejemplos (inicialmente oculto)
                    html += `<div class="children-container" id="children_${node.id}" data-total-children="${examples.length}" data-visible-start="0">`;
                    
                    // Mostrar todos los ejemplos, pero solo los primeros N visibles inicialmente
                    examples.forEach((example, exIndex) => {
                      const isVisible = exIndex < config.maxVisibleChildren;
                      html += `<div class="pyramid-node ${example.type} ${isVisible ? '' : 'hidden'}" tabindex="0" 
                                   data-row="${levelIndex + 1}" data-col="${exIndex}" 
                                   data-parent="${node.id}" data-id="${example.id}" data-index="${exIndex}">
                                ${example.text}
                              </div>`;
                    });
                    
                    // A√±adir controles de navegaci√≥n si hay m√°s de maxVisibleChildren
                    if (examples.length > config.maxVisibleChildren) {
                      html += `<div class="children-navigation">
                                <button class="nav-prev" disabled>‚ñ≤</button>
                                <span class="nav-indicator">1-${config.maxVisibleChildren} de ${examples.length}</span>
                                <button class="nav-next">‚ñº</button>
                              </div>`;
                    }
                    
                    html += '</div>'; // Cerrar contenedor de ejemplos
                  }
                }
                
                html += '</div>'; // Cerrar grupo de nodo
              });
            });
            
            html += '</div>'; // Cerrar nivel
          }
        }
        
        html += '</div>'; // Cerrar contenedor principal
        nodeVisualization.innerHTML = html;
        
        console.log("HTML generado:", html);
        
        // Configurar eventos para los nodos
        setupNodeEvents();
        
        // Configurar navegaci√≥n con teclado
        setupKeyboardNavigation();
        
        // Configurar controles de navegaci√≥n para contenedores de hijos
        setupChildrenNavigation();
        
        // Mostrar indicadores de navegaci√≥n si es necesario
        checkForOverflow();
        
      } catch (e) {
        console.error("Error al actualizar la visualizaci√≥n:", e);
        nodeVisualization.innerHTML = '<p>Error al generar la visualizaci√≥n. Verifica el formato de los datos.</p>';
      }
    }
    
    // Funci√≥n para configurar los controles de navegaci√≥n en contenedores de hijos
    function setupChildrenNavigation() {
      // Configurar botones de navegaci√≥n
      document.querySelectorAll('.nav-next').forEach(button => {
        button.addEventListener('click', function() {
          const container = this.closest('.children-container');
          const totalChildren = parseInt(container.getAttribute('data-total-children'));
          let visibleStart = parseInt(container.getAttribute('data-visible-start'));
          
          // Calcular el nuevo √≠ndice de inicio
          if (visibleStart + config.maxVisibleChildren < totalChildren) {
            visibleStart++;
            container.setAttribute('data-visible-start', visibleStart);
            
            // Actualizar visibilidad de los nodos
            updateVisibleChildren(container, visibleStart);
            
            // Actualizar estado de los botones
            updateNavigationButtons(container, visibleStart, totalChildren);
          }
        });
      });
      
      document.querySelectorAll('.nav-prev').forEach(button => {
        button.addEventListener('click', function() {
          const container = this.closest('.children-container');
          let visibleStart = parseInt(container.getAttribute('data-visible-start'));
          
          // Calcular el nuevo √≠ndice de inicio
          if (visibleStart > 0) {
            visibleStart--;
            container.setAttribute('data-visible-start', visibleStart);
            
            // Actualizar visibilidad de los nodos
            updateVisibleChildren(container, visibleStart);
            
            // Actualizar estado de los botones
            updateNavigationButtons(container, visibleStart, parseInt(container.getAttribute('data-total-children')));
          }
        });
      });
    }
    
    // Funci√≥n para actualizar la visibilidad de los nodos hijos
    function updateVisibleChildren(container, startIndex) {
      const children = container.querySelectorAll('.pyramid-node');
      const totalChildren = children.length;
      
      // Ocultar todos los nodos
      children.forEach(child => {
        child.classList.add('hidden');
      });
      
      // Mostrar solo los nodos en el rango visible
      for (let i = startIndex; i < Math.min(startIndex + config.maxVisibleChildren, totalChildren); i++) {
        children[i].classList.remove('hidden');
      }
      
      // Actualizar el indicador de navegaci√≥n
      const endIndex = Math.min(startIndex + config.maxVisibleChildren, totalChildren);
      const indicator = container.querySelector('.nav-indicator');
      if (indicator) {
        indicator.textContent = `${startIndex + 1}-${endIndex} de ${totalChildren}`;
      }
    }
    
    // Funci√≥n para actualizar el estado de los botones de navegaci√≥n
    function updateNavigationButtons(container, startIndex, totalChildren) {
      const prevButton = container.querySelector('.nav-prev');
      const nextButton = container.querySelector('.nav-next');
      
      if (prevButton) {
        prevButton.disabled = startIndex === 0;
      }
      
      if (nextButton) {
        nextButton.disabled = startIndex + config.maxVisibleChildren >= totalChildren;
      }
    }
    
    // Funci√≥n para actualizar el estado visual de los nodos
    function updateNodesVisualState(focusedNodeId = null) {
      // Obtener todos los nodos
      const allNodes = document.querySelectorAll('.pyramid-node');
      
      // Primero, restablecer todos los nodos a su estado minimizado
      allNodes.forEach(node => {
        node.classList.remove('focused', 'active-child', 'pinned', 'secondary-pinned');
        node.classList.add('minimized');
        
        // Restaurar colores originales seg√∫n el tipo de nodo
        const nodeType = node.classList.contains('main') ? 'main' : 
                         node.classList.contains('category') ? 'category' :
                         node.classList.contains('subcategory') ? 'subcategory' : 'example';
        
        // Marcar nodos que tienen hijos
        const nodeId = node.getAttribute('data-id');
        const hasChildren = document.querySelector(`.pyramid-node[data-parent="${nodeId}"]`) !== null;
        
        if (hasChildren) {
          node.classList.add('has-children');
        } else {
          node.classList.remove('has-children');
        }
      });
      
      // Si hay nodos fijados, mantenerlos destacados
      if (pinnedNode) {
        pinnedNode.classList.add('pinned');
        pinnedNode.classList.remove('minimized');
      }
      
      if (secondaryPinnedNode) {
        secondaryPinnedNode.classList.add('secondary-pinned');
        secondaryPinnedNode.classList.remove('minimized');
      }
      
      if (focusedNodeId) {
        // Obtener el nodo enfocado
        const focusedNode = document.querySelector(`.pyramid-node[data-id="${focusedNodeId}"]`);
        
        if (focusedNode) {
          // Activar el nodo enfocado
          focusedNode.classList.add('focused');
          focusedNode.classList.remove('minimized');
          
          // Mostrar informaci√≥n del nodo enfocado en la consola (para depuraci√≥n)
          console.log('Nodo enfocado:', focusedNode.textContent, 'ID:', focusedNodeId);
          
          // Activar el padre del nodo enfocado
          const parentId = focusedNode.getAttribute('data-parent');
          if (parentId && parentId !== 'null') {
            const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
            if (parentNode) {
              parentNode.classList.remove('minimized');
            }
            
            // Activar los hermanos del nodo enfocado
            const siblings = document.querySelectorAll(`.pyramid-node[data-parent="${parentId}"]`);
            siblings.forEach(sibling => {
              sibling.classList.remove('minimized');
              sibling.classList.add('active-child');
            });
          }
          
          // Activar los hijos del nodo enfocado
          const childrenNodes = document.querySelectorAll(`.pyramid-node[data-parent="${focusedNodeId}"]`);
          childrenNodes.forEach(child => {
            child.classList.remove('minimized');
            child.classList.add('active-child');
          });
          
          // Si el nodo enfocado es un hijo, activar sus hermanos
          const focusedParentId = focusedNode.getAttribute('data-parent');
          if (focusedParentId && focusedParentId !== 'null') {
            const siblings = document.querySelectorAll(`.pyramid-node[data-parent="${focusedParentId}"]`);
            siblings.forEach(sibling => {
              sibling.classList.remove('minimized');
              sibling.classList.add('active-child');
            });
          }
        }
      } else {
        // Si no hay nodo enfocado, mostrar el nodo ra√≠z y sus hijos normalmente
        const rootNode = document.querySelector('.pyramid-node[data-id="root"]');
        if (rootNode) {
          rootNode.classList.remove('minimized');
          rootNode.classList.add('focused');
          
          // Mostrar los hijos del nodo ra√≠z normalmente
          const rootChildren = document.querySelectorAll('.pyramid-node[data-parent="root"]');
          rootChildren.forEach(child => {
            child.classList.remove('minimized');
            child.classList.add('active-child');
          });
        }
      }
    }
    
    // Funci√≥n para actualizar la informaci√≥n del nodo en el panel inferior
    function updateNodeInfo(node) {
      const infoPanel = document.getElementById('info-panel');
      
      // Si el panel est√° fijado, no actualizar la informaci√≥n
      if (infoPanel.classList.contains('fixed')) {
        return;
      }
      
      if (!node) {
        document.getElementById('node-name').textContent = 'Ninguno seleccionado';
        document.getElementById('node-id').textContent = '-';
        return;
      }
      
      const nodeName = node.textContent.trim();
      const nodeId = node.getAttribute('data-id');
      
      document.getElementById('node-name').textContent = nodeName;
      document.getElementById('node-id').textContent = nodeId;
    }
    
    // Funci√≥n para fijar un nodo
    function pinNode(node) {
      if (!node) return;
      
      const infoPanel = document.getElementById('info-panel');
      
      // Si este nodo ya est√° fijado como secundario, solo desfijar el secundario
      if (secondaryPinnedNode === node) {
        secondaryPinnedNode.classList.remove('secondary-pinned');
        secondaryPinnedNode = null;
        
        // Actualizar la informaci√≥n en el panel para mostrar solo el nodo principal
        const primaryName = pinnedNode.textContent.trim();
        const primaryId = pinnedNode.getAttribute('data-id');
        
        document.getElementById('node-name').textContent = primaryName;
        document.getElementById('node-id').textContent = primaryId;
        
        return;
      }
      
      // Si este nodo ya est√° fijado como principal, desfijar ambos
      if (pinnedNode === node) {
        unpinAllNodes();
        return;
      }
      
      // Si no hay ning√∫n nodo fijado, fijar este como principal
      if (!pinnedNode) {
        pinnedNode = node;
        node.classList.add('pinned');
        
        infoPanel.classList.add('fixed');
        infoPanel.style.backgroundColor = '#4CAF50';
        
        // Actualizar la informaci√≥n en el panel
        const nodeName = node.textContent.trim();
        const nodeId = node.getAttribute('data-id');
        document.getElementById('node-name').textContent = nodeName;
        document.getElementById('node-id').textContent = nodeId;
      } 
      // Si ya hay un nodo fijado pero no un segundo, fijar este como secundario
      else if (!secondaryPinnedNode) {
        secondaryPinnedNode = node;
        node.classList.add('secondary-pinned');
        
        // Actualizar la informaci√≥n en el panel para mostrar ambos nodos
        const primaryName = pinnedNode.textContent.trim();
        const primaryId = pinnedNode.getAttribute('data-id');
        const secondaryName = node.textContent.trim();
        const secondaryId = node.getAttribute('data-id');
        
        document.getElementById('node-name').textContent = `${primaryName} | ${secondaryName}`;
        document.getElementById('node-id').textContent = `${primaryId} | ${secondaryId}`;
      }
      // Si ya hay dos nodos fijados, reemplazar el secundario
      else if (node !== pinnedNode) {
        // Quitar la clase del nodo secundario anterior
        secondaryPinnedNode.classList.remove('secondary-pinned');
        
        // Fijar el nuevo nodo como secundario
        secondaryPinnedNode = node;
        node.classList.add('secondary-pinned');
        
        // Actualizar la informaci√≥n en el panel
        const primaryName = pinnedNode.textContent.trim();
        const primaryId = pinnedNode.getAttribute('data-id');
        const secondaryName = node.textContent.trim();
        const secondaryId = node.getAttribute('data-id');
        
        document.getElementById('node-name').textContent = `${primaryName} | ${secondaryName}`;
        document.getElementById('node-id').textContent = `${primaryId} | ${secondaryId}`;
      }
    }
    
    // Funci√≥n para desfijar todos los nodos
    function unpinAllNodes() {
      const infoPanel = document.getElementById('info-panel');
      
      if (pinnedNode) {
        pinnedNode.classList.remove('pinned');
        pinnedNode = null;
      }
      
      if (secondaryPinnedNode) {
        secondaryPinnedNode.classList.remove('secondary-pinned');
        secondaryPinnedNode = null;
      }
      
      infoPanel.classList.remove('fixed');
      infoPanel.style.backgroundColor = '#333';
    }
    
    // Configurar eventos para los nodos
    function setupNodeEvents() {
      let currentFocusedNode = null;
      
      const nodes = document.querySelectorAll('.pyramid-node');
      
      nodes.forEach(node => {
        // Marcar nodos que tienen hijos
        const nodeId = node.getAttribute('data-id');
        const hasChildren = document.querySelector(`.pyramid-node[data-parent="${nodeId}"]`) !== null;
        const childrenContainer = document.getElementById(`children_${nodeId}`);
        
        if (hasChildren) {
          node.classList.add('collapsed');
        }
        
        node.addEventListener('click', function() {
          // Quitar el foco del nodo anterior
          if (currentFocusedNode) {
            currentFocusedNode.classList.remove('focused');
          }
          
          // Establecer el foco en el nodo actual
          this.classList.add('focused');
          currentFocusedNode = this;
          
          // Actualizar el estado visual de todos los nodos
          updateNodesVisualState(this.getAttribute('data-id'));
          
          // Actualizar la informaci√≥n del nodo en el panel inferior
          updateNodeInfo(this);
          
          // Hacer scroll para asegurar que el nodo est√° visible
          this.scrollIntoView({ block: 'center', inline: 'center', behavior: 'smooth' });
        });
        
        // A√±adir evento de teclado para expandir/colapsar con la barra espaciadora
        // y para fijar la informaci√≥n con Enter
        node.addEventListener('keydown', function(e) {
          if (e.key === ' ' || e.key === 'Spacebar') {
            e.preventDefault(); // Prevenir el desplazamiento de la p√°gina
            
            const nodeId = this.getAttribute('data-id');
            const childrenContainer = document.getElementById(`children_${nodeId}`);
            
            if (childrenContainer) {
              // Alternar visibilidad del contenedor de hijos
              childrenContainer.classList.toggle('visible');
              
              // Actualizar clase del nodo
              if (childrenContainer.classList.contains('visible')) {
                this.classList.remove('collapsed');
                this.classList.add('expanded');
                
                // Si se expande, hacer visibles los nodos hijos para la navegaci√≥n
                const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
                childNodes.forEach(child => {
                  child.classList.remove('minimized');
                  child.classList.add('active-child');
                });
              } else {
                this.classList.remove('expanded');
                this.classList.add('collapsed');
              }
            } else {
              // Verificar si este nodo es hijo de otro nodo
              const parentId = this.getAttribute('data-parent');
              if (parentId && parentId !== 'null') {
                // Buscar el contenedor de hijos del padre
                const parentContainer = document.getElementById(`children_${parentId}`);
                if (parentContainer && parentContainer.classList.contains('visible')) {
                  // Colapsar el contenedor del padre
                  parentContainer.classList.remove('visible');
                  
                  // Actualizar la clase del nodo padre
                  const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
                  if (parentNode) {
                    parentNode.classList.remove('expanded');
                    parentNode.classList.add('collapsed');
                    
                    // Enfocar el nodo padre
                    parentNode.click();
                  }
                }
              }
            }
          } else if (e.key === 'Enter') {
            e.preventDefault();
            
            // Usar la funci√≥n pinNode para manejar la fijaci√≥n/desfijaci√≥n
            pinNode(this);
            
            // Actualizar el estado visual de los nodos
            updateNodesVisualState(currentFocusedNode ? currentFocusedNode.getAttribute('data-id') : null);
          }
        });
      });
    }
    
    // Configurar navegaci√≥n con teclado
    function setupKeyboardNavigation() {
      let currentFocusedNode = null;
      
      // Primero, a√±adir evento de clic a todos los nodos
      const nodes = document.querySelectorAll('.pyramid-node');
      nodes.forEach(node => {
        node.addEventListener('click', function() {
          // Quitar el foco del nodo anterior
          if (currentFocusedNode) {
            currentFocusedNode.classList.remove('focused');
          }
          
          // Establecer el foco en el nodo actual
          this.classList.add('focused');
          currentFocusedNode = this;
          
          // Actualizar el estado visual de todos los nodos
          updateNodesVisualState(this.getAttribute('data-id'));
          
          // Actualizar la informaci√≥n del nodo en el panel inferior
          updateNodeInfo(this);
          
          // Hacer scroll para asegurar que el nodo est√° visible
          this.scrollIntoView({ block: 'center', inline: 'center', behavior: 'smooth' });
        });
      });
      
      // A√±adir evento de teclado para navegaci√≥n
      document.addEventListener('keydown', function(e) {
        // Si se presiona Enter y hay un nodo enfocado
        if (e.key === 'Enter' && currentFocusedNode) {
          e.preventDefault();
          
          // Usar la funci√≥n pinNode para manejar la fijaci√≥n/desfijaci√≥n
          pinNode(currentFocusedNode);
          
          // Actualizar el estado visual de los nodos
          updateNodesVisualState(currentFocusedNode.getAttribute('data-id'));
          
          return;
        }
        
        if (!currentFocusedNode) {
          // Si no hay nodo seleccionado, seleccionar el primero
          if (nodes.length > 0 && (e.key === 'ArrowDown' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowLeft')) {
            nodes[0].click();
            e.preventDefault();
          }
          return;
        }
        
        // Expandir/colapsar con la barra espaciadora
        if (e.key === ' ' || e.key === 'Spacebar') {
          e.preventDefault(); // Prevenir el desplazamiento de la p√°gina
          
          const nodeId = currentFocusedNode.getAttribute('data-id');
          const childrenContainer = document.getElementById(`children_${nodeId}`);
          
          if (childrenContainer) {
            // Alternar visibilidad del contenedor de hijos
            childrenContainer.classList.toggle('visible');
            
            // Actualizar clase del nodo
            if (childrenContainer.classList.contains('visible')) {
              currentFocusedNode.classList.remove('collapsed');
              currentFocusedNode.classList.add('expanded');
              
              // Si se expande, hacer visibles los nodos hijos para la navegaci√≥n
              const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
              childNodes.forEach(child => {
                child.classList.remove('minimized');
                child.classList.add('active-child');
              });
            } else {
              currentFocusedNode.classList.remove('expanded');
              currentFocusedNode.classList.add('collapsed');
            }
          } else {
            // Verificar si este nodo es hijo de otro nodo
            const parentId = currentFocusedNode.getAttribute('data-parent');
            if (parentId && parentId !== 'null') {
              // Buscar el contenedor de hijos del padre
              const parentContainer = document.getElementById(`children_${parentId}`);
              if (parentContainer && parentContainer.classList.contains('visible')) {
                // Colapsar el contenedor del padre
                parentContainer.classList.remove('visible');
                
                // Actualizar la clase del nodo padre
                const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
                if (parentNode) {
                  parentNode.classList.remove('expanded');
                  parentNode.classList.add('collapsed');
                  
                  // Enfocar el nodo padre
                  parentNode.click();
                }
              }
            }
          }
          
          return;
        }
        
        // Obtener informaci√≥n del nodo actual
        const currentRow = parseInt(currentFocusedNode.getAttribute('data-row'));
        const currentId = currentFocusedNode.getAttribute('data-id');
        const currentParent = currentFocusedNode.getAttribute('data-parent');
        
        let nextNode = null;
        
        switch (e.key) {
          case 'ArrowUp':
            // Verificar si estamos en un contenedor de hijos
            const isInChildrenContainerUp = currentFocusedNode.closest('.children-container') !== null;
            
            if (isInChildrenContainerUp) {
              // Si estamos en un contenedor de hijos, buscar el nodo anterior en el mismo contenedor
              const container = currentFocusedNode.closest('.children-container');
              const nodesInContainer = Array.from(container.querySelectorAll('.pyramid-node'));
              const currentIndex = nodesInContainer.indexOf(currentFocusedNode);
              
              if (currentIndex > 0) {
                // Ir al nodo anterior en el contenedor
                nextNode = nodesInContainer[currentIndex - 1];
                
                // Si el nodo anterior est√° oculto, ajustar la visualizaci√≥n
                if (nextNode.classList.contains('hidden')) {
                  let visibleStart = parseInt(container.getAttribute('data-visible-start'));
                  visibleStart--;
                  container.setAttribute('data-visible-start', visibleStart);
                  updateVisibleChildren(container, visibleStart);
                  updateNavigationButtons(container, visibleStart, nodesInContainer.length);
                }
              } else {
                // Si es el primer nodo del contenedor, ir al padre
                const parentId = container.id.replace('children_', '');
                nextNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
              }
            } else {
              // Navegar al nivel superior (padre)
              if (currentParent && currentParent !== 'null') {
                nextNode = document.querySelector(`.pyramid-node[data-id="${currentParent}"]`);
              } else {
                // Si no hay padre, intentar navegar al nivel anterior en la pir√°mide
                const prevLevel = document.querySelector(`.pyramid-level[data-level="${currentRow - 1}"]`);
                if (prevLevel) {
                  // Encontrar el nodo m√°s cercano horizontalmente en el nivel anterior
                  const currentRect = currentFocusedNode.getBoundingClientRect();
                  const nodesInPrevLevel = prevLevel.querySelectorAll('.pyramid-node');
                  
                  if (nodesInPrevLevel.length > 0) {
                    let closestNode = nodesInPrevLevel[0];
                    let minDistance = Infinity;
                    
                    nodesInPrevLevel.forEach(node => {
                      const nodeRect = node.getBoundingClientRect();
                      const distance = Math.abs(nodeRect.left - currentRect.left);
                      if (distance < minDistance) {
                        minDistance = distance;
                        closestNode = node;
                      }
                    });
                    
                    nextNode = closestNode;
                  }
                }
              }
            }
            break;
            
          case 'ArrowDown':
            // Verificar si estamos en un contenedor de hijos
            const isInChildrenContainerDown = currentFocusedNode.closest('.children-container') !== null;
            
            if (isInChildrenContainerDown) {
              // Si estamos en un contenedor de hijos, buscar el nodo siguiente en el mismo contenedor
              const container = currentFocusedNode.closest('.children-container');
              const nodesInContainer = Array.from(container.querySelectorAll('.pyramid-node'));
              const currentIndex = nodesInContainer.indexOf(currentFocusedNode);
              
              if (currentIndex < nodesInContainer.length - 1) {
                // Ir al siguiente nodo en el contenedor
                nextNode = nodesInContainer[currentIndex + 1];
                
                // Si el siguiente nodo est√° oculto, ajustar la visualizaci√≥n
                if (nextNode.classList.contains('hidden')) {
                  let visibleStart = parseInt(container.getAttribute('data-visible-start'));
                  visibleStart++;
                  container.setAttribute('data-visible-start', visibleStart);
                  updateVisibleChildren(container, visibleStart);
                  updateNavigationButtons(container, visibleStart, nodesInContainer.length);
                }
              } else {
                // Si es el √∫ltimo nodo, intentar navegar al siguiente nivel o hermano
                // C√≥digo existente para navegaci√≥n fuera de contenedores
                // ...
              }
            } else {
              // Navegar al nivel inferior (primer hijo)
              // Primero verificar si hay un contenedor de hijos visible
              const childrenContainer = document.getElementById(`children_${currentId}`);
              
              // Verificar si el nodo tiene hijos y el contenedor existe pero no est√° visible
              if (childrenContainer && !childrenContainer.classList.contains('visible')) {
                // Abrir el contenedor de hijos
                childrenContainer.classList.add('visible');
                currentFocusedNode.classList.remove('collapsed');
                currentFocusedNode.classList.add('expanded');
                
                // Hacer visibles los nodos hijos para la navegaci√≥n
                const childNodes = childrenContainer.querySelectorAll('.pyramid-node');
                childNodes.forEach(child => {
                  child.classList.remove('minimized');
                  child.classList.add('active-child');
                });
                
                // Seleccionar el primer hijo dentro del contenedor
                const visibleChildren = childrenContainer.querySelectorAll('.pyramid-node:not(.hidden)');
                if (visibleChildren.length > 0) {
                  nextNode = visibleChildren[0];
                  break;
                }
              }
              
              // Si el contenedor ya est√° visible o no existe, continuar con la l√≥gica anterior
              if (childrenContainer && childrenContainer.classList.contains('visible')) {
                // Si el contenedor est√° visible, seleccionar el primer hijo dentro del contenedor
                const visibleChildren = childrenContainer.querySelectorAll('.pyramid-node:not(.hidden)');
                if (visibleChildren.length > 0) {
                  nextNode = visibleChildren[0];
                  break;
                }
              }
              
              // Si no hay contenedor visible o est√° vac√≠o, buscar hijos en el DOM general
              const children = document.querySelectorAll(`.pyramid-node[data-parent="${currentId}"]`);
              
              if (children.length > 0) {
                // Ordenar los hijos por su posici√≥n visual (izquierda a derecha)
                const sortedChildren = Array.from(children).sort((a, b) => {
                  const rectA = a.getBoundingClientRect();
                  const rectB = b.getBoundingClientRect();
                  return rectA.left - rectB.left;
                });
                
                // Seleccionar el primer hijo (el m√°s a la izquierda)
                nextNode = sortedChildren[0];
              } else {
                // Si no hay hijos, intentar navegar al siguiente nivel en la pir√°mide
                const nextLevel = document.querySelector(`.pyramid-level[data-level="${currentRow + 1}"]`);
                if (nextLevel) {
                  // Encontrar el nodo m√°s cercano horizontalmente en el siguiente nivel
                  const currentRect = currentFocusedNode.getBoundingClientRect();
                  const nodesInNextLevel = nextLevel.querySelectorAll('.pyramid-node');
                  
                  if (nodesInNextLevel.length > 0) {
                    let closestNode = nodesInNextLevel[0];
                    let minDistance = Infinity;
                    
                    nodesInNextLevel.forEach(node => {
                      const nodeRect = node.getBoundingClientRect();
                      const distance = Math.abs(nodeRect.left - currentRect.left);
                      if (distance < minDistance) {
                        minDistance = distance;
                        closestNode = node;
                      }
                    });
                    
                    nextNode = closestNode;
                  }
                }
              }
            }
            break;
            
          case 'ArrowLeft':
            // Verificar si estamos en un contenedor de hijos
            const isInChildrenContainer = currentFocusedNode.closest('.children-container') !== null;
            
            if (isInChildrenContainer) {
              // Si estamos en un contenedor de hijos, ir al padre del contenedor
              const container = currentFocusedNode.closest('.children-container');
              const parentId = container.id.replace('children_', '');
              nextNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
              
              // Colapsar el contenedor de hijos al salir
              container.classList.remove('visible');
              
              // Actualizar la clase del nodo padre
              const parentNode = document.querySelector(`.pyramid-node[data-id="${parentId}"]`);
              if (parentNode) {
                parentNode.classList.remove('expanded');
                parentNode.classList.add('collapsed');
              }
            } else {
              // Navegar al nodo a la izquierda en el mismo nivel
              // Obtener todos los nodos del mismo nivel y con el mismo padre
              const siblingNodes = document.querySelectorAll(
                `.pyramid-node[data-row="${currentRow}"][data-parent="${currentParent}"]`
              );
              
              if (siblingNodes.length > 1) {
                // Ordenar los nodos por su posici√≥n visual (izquierda a derecha)
                const sortedSiblings = Array.from(siblingNodes).sort((a, b) => {
                  const rectA = a.getBoundingClientRect();
                  const rectB = b.getBoundingClientRect();
                  return rectA.left - rectB.left;
                });
                
                // Encontrar el √≠ndice del nodo actual
                const currentIndex = sortedSiblings.findIndex(node => node === currentFocusedNode);
                
                // Seleccionar el nodo a la izquierda si existe
                if (currentIndex > 0) {
                  nextNode = sortedSiblings[currentIndex - 1];
                }
              }
            }
            break;
            
          case 'ArrowRight':
            // Verificar si estamos en un contenedor de hijos
            const isInContainer = currentFocusedNode.closest('.children-container') !== null;
            
            if (isInContainer) {
              // Si estamos en un contenedor de hijos, no hacer nada con la flecha derecha
              // No abriremos conjuntos de nodos con flechas laterales
              break;
            } else {
              // Navegar al nodo a la derecha en el mismo nivel
              // Obtener todos los nodos del mismo nivel y con el mismo padre
              const siblingNodesRight = document.querySelectorAll(
                `.pyramid-node[data-row="${currentRow}"][data-parent="${currentParent}"]`
              );
              
              if (siblingNodesRight.length > 1) {
                // Ordenar los nodos por su posici√≥n visual (izquierda a derecha)
                const sortedSiblingsRight = Array.from(siblingNodesRight).sort((a, b) => {
                  const rectA = a.getBoundingClientRect();
                  const rectB = b.getBoundingClientRect();
                  return rectA.left - rectB.left;
                });
                
                // Encontrar el √≠ndice del nodo actual
                const currentIndexRight = sortedSiblingsRight.findIndex(node => node === currentFocusedNode);
                
                // Seleccionar el nodo a la derecha si existe
                if (currentIndexRight < sortedSiblingsRight.length - 1) {
                  nextNode = sortedSiblingsRight[currentIndexRight + 1];
                }
                // Ya no expandimos nodos con la flecha derecha
              }
              // Ya no expandimos nodos con la flecha derecha cuando no hay hermanos
            }
            break;
        }
        
        if (nextNode) {
          nextNode.click();
          e.preventDefault();
        }
      });
    }
    
    // Funci√≥n para alternar la visibilidad del panel YAML-JSON
    document.getElementById('toggle-panel').addEventListener('click', function() {
      const panel = document.getElementById('yaml-json-panel');
      const mainContent = document.querySelector('.main-content');
      const nodesContainer = document.getElementById('nodes-container');
      
      panel.classList.toggle('visible');
      mainContent.classList.toggle('panel-visible');
      
      // Si el panel est√° visible, desplazar el contenedor de nodos a la derecha
      if (panel.classList.contains('visible')) {
        this.textContent = '√ó'; // Cambiar el √≠cono del bot√≥n a una X
      } else {
        this.textContent = '‚â°'; // Cambiar el √≠cono del bot√≥n a barras
      }
      
      // Actualizar los indicadores de navegaci√≥n despu√©s de un breve retraso
      // para permitir que la animaci√≥n de desplazamiento termine
      setTimeout(checkForOverflow, 300);
      
      // Forzar un reflow para que el contenedor de nodos se ajuste correctamente
      setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
      }, 350);
    });
    
    // Evento para cambiar entre formatos
    document.getElementById('format-selector').addEventListener('change', function() {
      const format = this.value;
      document.getElementById('current-format').textContent = format.toUpperCase();
      
      if (format === 'json') {
        // Convertir YAML a JSON
        try {
          const jsonData = yamlToJson(document.getElementById('data-display').value);
          document.getElementById('data-display').value = JSON.stringify(jsonData, null, 2);
        } catch (e) {
          console.error("Error al convertir a JSON:", e);
          document.getElementById('data-display').value = "Error al convertir a JSON. Verifica el formato YAML.";
        }
      } else {
        // Convertir JSON a YAML
        try {
          const jsonText = document.getElementById('data-display').value;
          const jsonObj = JSON.parse(jsonText);
          const yamlData = jsonToYaml(jsonObj);
          document.getElementById('data-display').value = yamlData;
        } catch (e) {
          console.error("Error al convertir a YAML:", e);
          document.getElementById('data-display').value = "# Error al convertir a YAML. Verifica el formato JSON.";
        }
      }
    });
    
    // Evento para actualizar la visualizaci√≥n
    document.getElementById('update-visualization').addEventListener('click', function() {
      const format = document.getElementById('format-selector').value;
      const dataText = document.getElementById('data-display').value;
      
      if (format === 'json') {
        try {
          const jsonObj = JSON.parse(dataText);
          updateNodeVisualization(jsonObj);
        } catch (e) {
          console.error("Error al parsear JSON:", e);
          alert("Error al parsear JSON. Verifica el formato.");
        }
      } else {
        updateNodeVisualization(dataText);
      }
    });
    
    // Funci√≥n para verificar si hay desbordamiento y mostrar indicadores
    function checkForOverflow() {
      const container = document.querySelector('.nodes-container');
      const content = document.querySelector('.pyramid-container');
      
      if (!container || !content) return;
      
      // Eliminar indicadores existentes
      document.querySelectorAll('.navigation-indicator').forEach(el => el.remove());
      
      // Verificar desbordamiento horizontal
      if (content.scrollWidth > container.clientWidth) {
        // Hay contenido fuera de la vista a la derecha
        const rightIndicator = document.createElement('div');
        rightIndicator.className = 'navigation-indicator indicator-right';
        rightIndicator.textContent = '‚Üí';
        container.appendChild(rightIndicator);
        
        // Hay contenido fuera de la vista a la izquierda
        const leftIndicator = document.createElement('div');
        leftIndicator.className = 'navigation-indicator indicator-left';
        leftIndicator.textContent = '‚Üê';
        container.appendChild(leftIndicator);
      }
      
      // Verificar desbordamiento vertical
      if (content.scrollHeight > container.clientHeight) {
        // Hay contenido fuera de la vista abajo
        const downIndicator = document.createElement('div');
        downIndicator.className = 'navigation-indicator indicator-down';
        downIndicator.textContent = '‚Üì';
        container.appendChild(downIndicator);
        
        // Hay contenido fuera de la vista arriba
        const upIndicator = document.createElement('div');
        upIndicator.className = 'navigation-indicator indicator-up';
        upIndicator.textContent = '‚Üë';
        container.appendChild(upIndicator);
      }
    }
    
    // Funci√≥n para alternar la visibilidad del panel de propiedades
    document.getElementById('toggle-props-panel').addEventListener('click', function() {
      const panel = document.getElementById('props-panel');
      const mainContent = document.querySelector('.main-content');
      
      panel.classList.toggle('visible');
      mainContent.classList.toggle('props-panel-visible');
      
      // Si el panel est√° visible, cambiar el √≠cono del bot√≥n
      if (panel.classList.contains('visible')) {
        this.textContent = '√ó'; // Cambiar el √≠cono del bot√≥n a una X
      } else {
        this.textContent = '‚öô'; // Cambiar el √≠cono del bot√≥n a engranaje
      }
      
      // Actualizar los indicadores de navegaci√≥n despu√©s de un breve retraso
      setTimeout(checkForOverflow, 300);
      
      // Forzar un reflow para que el contenedor de nodos se ajuste correctamente
      setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
      }, 350);
    });
    
    // Funci√≥n para cargar y mostrar la jerarqu√≠a de propiedades
    async function loadPropertiesHierarchy() {
      try {
        // En un entorno real, esto ser√≠a una llamada a la API
        // Por ahora, usamos el ejemplo de props.json directamente
        const propsData = {
          "id": "root-game-123",
          "VideoJuego": {
            "id": "game-root-456",
            "Personajes": {
              "id": "characters-789",
              "Heroe": {
                "id": "hero-abc",
                "value": null
              },
              "Villano": {
                "id": "villain-def",
                "value": null
              }
            },
            "Items": {
              "id": "items-ghi",
              "Arma": {
                "id": "weapon-jkl",
                "value": null
              },
              "Pocion": {
                "id": "potion-mno",
                "value": null
              }
            },
            "Aliados": {
              "id": "allies-pqr",
              "Guerrero": {
                "id": "warrior-stu",
                "value": null
              },
              "Mago": {
                "id": "mage-vwx",
                "value": null
              }
            }
          }
        };
        
        renderPropertiesTree(propsData);
      } catch (error) {
        console.error('Error loading properties hierarchy:', error);
        document.getElementById('props-tree').innerHTML = '<p>Error al cargar la jerarqu√≠a de propiedades.</p>';
      }
    }
    
    // Funci√≥n para renderizar el √°rbol de propiedades
    function renderPropertiesTree(data, parentElement = null) {
      const container = parentElement || document.getElementById('props-tree');
      
      // Limpiar el contenedor si es el contenedor principal
      if (!parentElement) {
        container.innerHTML = '';
      }
      
      // Recorrer las propiedades del objeto
      Object.entries(data).forEach(([key, value]) => {
        // Ignorar la propiedad "id" cuando est√° sola
        if (key === 'id' || key === 'value') return;
        
        const itemDiv = document.createElement('div');
        itemDiv.className = 'prop-item';
        
        const headerDiv = document.createElement('div');
        headerDiv.className = 'prop-item-header';
        
        // Determinar si este nodo tiene hijos
        const hasChildren = typeof value === 'object' && value !== null && 
                            Object.keys(value).some(k => k !== 'id' && k !== 'value');
        
        // Crear el contenido del encabezado
        let headerContent = '';
        if (hasChildren) {
          headerContent += '<span class="prop-toggle">‚ñ∂</span>';
        } else {
          headerContent += '<span class="prop-toggle" style="visibility:hidden">‚ñ∂</span>';
        }
        
        headerContent += key;
        
        // A√±adir el ID si existe
        if (value && value.id) {
          headerContent += `<span class="prop-id">(ID: ${value.id})</span>`;
        }
        
        // A√±adir el valor si existe y no es null
        if (value && value.value !== undefined && value.value !== null) {
          headerContent += `<span class="prop-value">${value.value}</span>`;
        }
        
        headerDiv.innerHTML = headerContent;
        itemDiv.appendChild(headerDiv);
        
        // Si tiene hijos, crear un contenedor para ellos
        if (hasChildren) {
          const childrenDiv = document.createElement('div');
          childrenDiv.className = 'prop-children';
          itemDiv.appendChild(childrenDiv);
          
          // A√±adir evento para expandir/colapsar
          headerDiv.addEventListener('click', function() {
            childrenDiv.classList.toggle('visible');
            const toggle = this.querySelector('.prop-toggle');
            if (childrenDiv.classList.contains('visible')) {
              toggle.textContent = '‚ñº';
              
              // Si a√∫n no se han renderizado los hijos, hacerlo ahora
              if (childrenDiv.children.length === 0) {
                renderPropertiesTree(value, childrenDiv);
              }
            } else {
              toggle.textContent = '‚ñ∂';
            }
          });
        }
        
        container.appendChild(itemDiv);
      });
    }
    
    // Inicializar la visualizaci√≥n al cargar la p√°gina
    document.addEventListener('DOMContentLoaded', function() {
      // Verificar que jsyaml est√© cargado
      if (typeof jsyaml === 'undefined') {
        console.error("Error: jsyaml no est√° cargado");
        document.getElementById('node-visualization').innerHTML = 
          '<p>Error: No se pudo cargar la biblioteca js-yaml. Verifica las dependencias.</p>';
        return;
      }
      
      // Cargar datos iniciales
      document.getElementById('data-display').value = yamlData;
      
      // Generar visualizaci√≥n inicial
      updateNodeVisualization(yamlData);
      
      // A√±adir evento de redimensionamiento para actualizar indicadores
      window.addEventListener('resize', checkForOverflow);
      
      // A√±adir eventos de desplazamiento para actualizar indicadores
      document.querySelector('.nodes-container').addEventListener('scroll', function() {
        // Actualizar visibilidad de indicadores seg√∫n la posici√≥n de desplazamiento
        const indicators = document.querySelectorAll('.navigation-indicator');
        indicators.forEach(indicator => {
          indicator.style.opacity = '0.7';
          setTimeout(() => {
            indicator.style.opacity = '0';
          }, 1500);
        });
      });
      
      // Inicializar el estado visual de los nodos
      setTimeout(() => {
        updateNodesVisualState();
        
        // Seleccionar el nodo ra√≠z por defecto
        const rootNode = document.querySelector('.pyramid-node[data-id="root"]');
        if (rootNode) {
          rootNode.click();
        }
      }, config.autoScrollDelay);
      
      // A√±adir estilos CSS para el desplazamiento del contenedor de nodos
      const style = document.createElement('style');
      style.textContent = `
        /* Estilos existentes para nodos fijados... */
        
        /* Ajustar el dise√±o para evitar superposiciones */
        .main-content {
          display: flex;
          flex-direction: row;
          align-items: stretch;
          overflow: hidden;
        }
        
        .YAML-JSON {
          width: 0;
          overflow: hidden;
          transition: width 0.3s ease;
          flex-shrink: 0;
        }
        
        .YAML-JSON.visible {
          width: 40%; /* Ancho del panel cuando est√° visible */
          min-width: 300px;
          max-width: 500px;
        }
        
        .nodes-container {
          flex-grow: 1;
          overflow: auto;
          transition: margin-left 0.3s ease, width 0.3s ease;
          width: 100%;
        }
        
        .main-content.panel-visible .nodes-container {
          margin-left: 40%; /* Debe coincidir con el ancho del panel */
          width: 60%; /* El ancho restante */
        }
        
        @media (max-width: 1200px) {
          .YAML-JSON.visible {
            width: 350px;
            min-width: 300px;
          }
          
          .main-content.panel-visible .nodes-container {
            margin-left: 350px;
            width: calc(100% - 350px);
          }
        }
        
        /* Asegurar que el bot√≥n de alternar siempre est√© visible */
        .toggle-panel {
          position: fixed;
          left: 10px;
          top: 10px;
          z-index: 1001;
          background-color: #333;
          color: white;
          border: none;
          border-radius: 4px;
          width: 30px;
          height: 30px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          font-size: 18px;
          box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .toggle-panel:hover {
          background-color: #555;
        }
        
        /* Asegurar que el contenido de la visualizaci√≥n se ajuste correctamente */
        .pyramid-container {
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          transition: transform 0.3s ease;
        }
      `;
      document.head.appendChild(style);
      
      // Asegurarse de que el contenedor de nodos se ajuste cuando cambia el tama√±o de la ventana
      window.addEventListener('resize', function() {
        checkForOverflow();
        
        // Ajustar el tama√±o del contenedor de nodos si el panel est√° visible
        const panel = document.getElementById('yaml-json-panel');
        const nodesContainer = document.getElementById('nodes-container');
        
        if (panel && panel.classList.contains('visible') && nodesContainer) {
          // Forzar un reflow para que el contenedor se ajuste correctamente
          nodesContainer.style.display = 'none';
          setTimeout(() => {
            nodesContainer.style.display = '';
          }, 10);
        }
      });
      
      // Cargar la jerarqu√≠a de propiedades
      loadPropertiesHierarchy();
      
      // A√±adir estilos CSS adicionales para manejar ambos paneles
      const additionalStyle = document.createElement('style');
      additionalStyle.textContent = `
        /* Ajustes para cuando ambos paneles est√°n visibles */
        .main-content.panel-visible.props-panel-visible .nodes-container {
          margin-left: 40%;
          margin-right: 40%;
          width: 20%;
        }
        
        @media (max-width: 1200px) {
          .main-content.panel-visible.props-panel-visible .nodes-container {
            margin-left: 350px;
            margin-right: 350px;
            width: calc(100% - 700px);
          }
        }
      `;
      document.head.appendChild(additionalStyle);
    });
  </script>
</body>
</html>