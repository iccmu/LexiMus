<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Añadir Taxonomía</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }

        .container {
            max-width: none;
            margin: 0;
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            flex-shrink: 0;
        }

        .back-btn {
            padding: 8px 16px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .json-preview {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .content-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            flex: 1;
            height: calc(100% - 70px); /* Altura total menos top-bar */
            overflow: hidden;
        }

        .input-section {
            flex: 0 0 400px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            height: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .content-wrapper {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 10px;
            overflow: hidden;
        }

        #yamlInput {
            flex: 1;
            min-height: 0;
            resize: none;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.4;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            white-space: pre;
            overflow-x: auto;
            overflow-y: auto;
        }

        .button-error-container {
            position: relative;
            height: 38px; /* Altura fija igual a la del botón */
            flex-shrink: 0;
        }

        .yaml-error {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            color: #dc3545;
            padding: 10px;
            border-radius: 4px;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            font-size: 0.9em;
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 1;
        }

        .yaml-error.show {
            opacity: 1;
            transform: translateY(0);
        }

        button {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        button.hide {
            opacity: 0;
            pointer-events: none;
        }

        .error-icon {
            font-size: 1em;
            margin-right: 5px;
        }

        .error-message {
            font-family: 'Consolas', monospace;
            white-space: pre-wrap;
            margin-top: 5px;
            padding: 5px;
            background-color: #fff;
            border-radius: 4px;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .error-line {
            background-color: #ffebee;
            font-weight: bold;
        }

        .error-pointer {
            color: #dc3545;
            font-weight: bold;
        }

        #jsonOutput {
            flex: 0 0 30%;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
        }

        .visualization-section {
            flex: 1;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
            height: 100%;
        }

        #mynetwork {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 15px;
        }

        .taxonomy-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .taxonomy-section {
            padding: 15px;
            background-color: #fff;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }

        .taxonomy-input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }

        .save-btn {
            padding: 10px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 20px;
        }

        .save-btn:hover {
            background-color: #218838;
        }

        /* Añadir los estilos del sistema de jerarquías */
        .json-hierarchy {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .json-hierarchy li {
            margin: 5px 0;
        }

        .node-item {
            background: #ffffff;
            padding: 4px 8px;
            border-radius: 6px;
            margin: 2px 0;
            transition: all 0.3s ease;
            cursor: pointer;
            border-left: 3px solid #3498db;
            position: relative;
            padding-right: 30px;
        }

        .node-item:hover {
            transform: translateX(5px);
            background: #f0f0f0;
        }

        .node-item.has-children {
            border-left: 3px solid #2ecc71;
        }

        .key {
            font-weight: bold;
            color: #2c3e50;
        }

        .value {
            color: #7f8c8d;
            font-style: italic;
        }

        .json-hierarchy ul {
            position: relative;
            display: none;
            padding-left: 20px;
        }

        .json-hierarchy ul::before {
            content: '';
            position: absolute;
            left: -15px;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #e9ecef;
        }

        .json-hierarchy li.expanded > ul {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        .node-item.has-children::after {
            content: '▸';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.3s ease;
        }

        .node-item.has-children.expanded::after {
            transform: translateY(-50%) rotate(90deg);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Diferentes niveles de profundidad */
        .json-hierarchy .node-item {
            border-left-width: 3px;
        }

        .json-hierarchy ul .node-item {
            border-left-color: #e74c3c;  /* Rojo */
        }

        .json-hierarchy ul ul .node-item {
            border-left-color: #f1c40f;  /* Amarillo */
        }

        .json-hierarchy ul ul ul .node-item {
            border-left-color: #9b59b6;  /* Morado */
        }

        .json-hierarchy ul ul ul ul .node-item {
            border-left-color: #2ecc71;  /* Verde */
        }

        .json-hierarchy ul ul ul ul ul .node-item {
            border-left-color: #e67e22;  /* Naranja */
        }

        /* Actualizar estilos del ejemplo */
        .example {
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e1e1e1;
            max-height: 300px;
            overflow-y: auto;
        }

        .example pre {
            margin: 0;
            padding: 15px;
            background-color: #fff;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .example h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--primary-color);
            font-size: 1.2em;
        }

        /* Actualizar estilos para manejar múltiples ejemplos */
        .example pre {
            margin-bottom: 20px;
        }

        .example h3:not(:first-child) {
            margin-top: 20px;
        }

        h3 {
            margin: 0;
            padding: 10px 0;
            flex-shrink: 0;
        }

        /* Añadir estilos para el menú contextual */
        .context-menu {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            padding: 8px 0;
            z-index: 1000;
        }

        .context-menu-option {
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .context-menu-option:hover {
            background-color: #f0f0f0;
        }

        /* Añadir estilos para el minimapa */
        .minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            overflow: hidden;
            z-index: 1000;
        }

        #minimap {
            width: 100%;
            height: 100%;
        }

        /* Añadir estilo para el indicador de posición */
        .viewport-indicator {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1001;
        }

        .coordinates-display {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1002;
        }

        .center-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: red;
            border-radius: 50%;
            left: 50%;  /* Centrado horizontal */
            top: 50%;   /* Centrado vertical */
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            border: 2px solid white;
            box-shadow: 0 0 4px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-bar">
            <h2>Añadir Taxonomía - <span id="filename"></span></h2>
            <button class="back-btn" onclick="window.location.href='/dashboard'">Volver</button>
        </div>

        <div class="content-container">
            <div class="input-section">
                <div class="content-wrapper">
                    <textarea id="yamlInput" placeholder="Escribe tu taxonomía usando YAML..."></textarea>
                    <div class="button-error-container">
                        <div id="yamlError" class="yaml-error">
                            <span class="error-icon">⚠️</span>
                            <span id="errorMessage"></span>
                        </div>
                        <button id="visualizeButton" onclick="visualizeGraph()">Visualizar Grafo</button>
                    </div>
                    <h3>JSON Resultante:</h3>
                    <div id="jsonOutput"></div>
                </div>
            </div>

            <div class="visualization-section">
                <div id="mynetwork"></div>
                <div class="center-marker"></div>
                <div class="minimap-container">
                    <div id="minimap"></div>
                    <div class="coordinates-display">
                        <div>Grid: <span id="gridCoordinates"></span></div>
                        <div>Nodo central: <span id="centerNode"></span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Añadir el menú contextual -->
    <div id="contextMenu" class="context-menu">
        <div class="context-menu-option" data-relation="Inversa">Inversa</div>
        <div class="context-menu-option" data-relation="Transitiva">Transitiva</div>
        <div class="context-menu-option" data-relation="Simétrica">Simétrica</div>
        <div class="context-menu-option" data-relation="Funcional">Funcional</div>
        <div class="context-menu-option" data-relation="Inversamente Funcional">Inversamente Funcional</div>
    </div>

    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script>
        // Modificar la función de carga inicial
        window.onload = function() {
            if (!sessionStorage.getItem('user')) {
                window.location.href = '/';
            }

            const urlParts = window.location.pathname.split('/');
            const filename = decodeURIComponent(urlParts[urlParts.length - 1]);
            
            const filenameElement = document.getElementById('filename');
            if (filenameElement) {
                filenameElement.textContent = filename;
            }

            // Cargar el JSON específico del archivo
            loadJsonContent(filename);
        }

        // Función para filtrar los campos 'id' de un objeto
        function filterIds(obj) {
            if (Array.isArray(obj)) {
                return obj.map(item => filterIds(item));
            } else if (typeof obj === 'object' && obj !== null) {
                const filtered = {};
                for (const [key, value] of Object.entries(obj)) {
                    if (key !== 'id') {
                        filtered[key] = filterIds(value);
                    }
                }
                return filtered;
            }
            return obj;
        }

        // Añadir event listener para actualización en tiempo real
        document.getElementById('yamlInput').addEventListener('input', debounce(function() {
            visualizeGraph();
        }, 500)); // Espera 500ms después de la última edición antes de actualizar

        // Función debounce para evitar demasiadas actualizaciones
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function formatYamlError(error) {
            if (!error.message) return 'Error desconocido';

            // Extraer información del error
            let errorLine, errorColumn;
            let customMessage = '';

            if (error.message.includes('bad indentation')) {
                const match = error.message.match(/bad indentation.+\((\d+):(\d+)\)/i);
                if (match) {
                    errorLine = parseInt(match[1]);
                    errorColumn = parseInt(match[2]);
                    customMessage = 'Mala indentación!!!';
                }
            } else if (error.message.includes('can not read a block mapping entry')) {
                const match = error.message.match(/block mapping entry.+\((\d+):(\d+)\)/i);
                if (match) {
                    errorLine = parseInt(match[1]);
                    errorColumn = parseInt(match[2]);
                    customMessage = 'Mala indentación!!!';
                }
            } else {
                return error.message;
            }

            if (!errorLine || !errorColumn) return error.message;
            
            // Obtener el YAML actual
            const yaml = document.getElementById('yamlInput').value;
            const lines = yaml.split('\n');
            
            // Crear contexto del error (3 líneas antes y después)
            const start = Math.max(0, errorLine - 4);
            const end = Math.min(lines.length, errorLine + 3);
            
            let contextLines = [];
            for (let i = start; i < end; i++) {
                const lineNum = i + 1;
                const isErrorLine = lineNum === errorLine;
                
                // Formatear línea
                let line = `${lineNum} | ${lines[i]}`;
                if (isErrorLine) {
                    line += '\n' + ' '.repeat(errorColumn + 3) + '^'.repeat(20);
                }
                
                contextLines.push({
                    text: line,
                    isError: isErrorLine
                });
            }

            // Construir mensaje de error formateado
            let formattedMessage = `${customMessage} (línea ${errorLine}, columna ${errorColumn}):\n\n`;
            formattedMessage += contextLines.map(line => 
                line.isError ? 
                    `<span class="error-line">${line.text}</span>` : 
                    line.text
            ).join('\n');

            return formattedMessage;
        }

        function visualizeGraph() {
            try {
                const yamlInput = document.getElementById('yamlInput').value;
                const jsonData = jsyaml.load(yamlInput);
                
                // Filtrar los IDs antes de mostrar el JSON resultante
                const filteredData = filterIds(jsonData);
                
                document.getElementById('jsonOutput').innerHTML = 
                    `<pre>${JSON.stringify(filteredData, null, 2)}</pre>`;
                
                const { nodes, edges } = convertToGraph(filteredData);
                
                const container = document.getElementById('mynetwork');
                const graphData = {
                    nodes: new vis.DataSet(nodes),
                    edges: new vis.DataSet(edges)
                };
                
                // Mantener el estado del zoom y la posición de la vista
                let network = container._network;
                let viewPosition = network ? {
                    position: network.getViewPosition(),
                    scale: network.getScale()
                } : null;
                
                const options = {
                    layout: {
                        hierarchical: {
                            direction: 'UD',
                            sortMethod: 'directed',
                            nodeSpacing: 150,
                            levelSeparation: 150,
                            treeSpacing: 200
                        }
                    },
                    physics: {
                        enabled: false
                    },
                    edges: {
                        arrows: 'to',
                        smooth: {
                            type: 'cubicBezier',
                            forceDirection: 'vertical',
                            roundness: 0.2
                        },
                        color: {
                            color: '#2B7CE9'
                        }
                    },
                    nodes: {
                        shape: 'box',
                        margin: 10,
                        font: {
                            size: 16,
                            face: 'arial'
                        },
                        color: {
                            background: '#D2E5FF',
                            border: '#2B7CE9'
                        },
                        shadow: true
                    },
                    manipulation: {
                        enabled: false
                    },
                    interaction: {
                        dragNodes: true,
                        dragView: true,
                        zoomView: true,
                        hover: true
                    }
                };
                
                network = new vis.Network(container, graphData, options);
                let selectedNodes = [];
                // Definir el tamaño del grid y límites
                const GRID_SIZE = 50; // Tamaño de cada celda del grid
                const GRID_SPACING = 150; // Espacio entre niveles jerárquicos
                const MAX_X = 2000; // Límite horizontal
                const MAX_Y = 2000; // Límite vertical

                // Fijar las posiciones iniciales y configurar el grid
                network.once('stabilized', function() {
                    const positions = network.getPositions();
                    const levels = {};
                    
                    // Agrupar nodos por niveles
                    Object.keys(positions).forEach(nodeId => {
                        const y = Math.round(positions[nodeId].y / GRID_SPACING) * GRID_SPACING;
                        if (!levels[y]) levels[y] = [];
                        levels[y].push(nodeId);
                    });

                    // Ordenar los niveles por coordenada Y
                    const sortedLevels = Object.keys(levels).sort((a, b) => parseFloat(a) - parseFloat(b));

                    // Distribuir los nodos horizontalmente en cada nivel
                    sortedLevels.forEach((y, levelIndex) => {
                        const nodeIds = levels[y];
                        const levelWidth = nodeIds.length * GRID_SIZE;
                        const startX = -levelWidth / 2;
                        
                        nodeIds.forEach((nodeId, index) => {
                            const xPos = Math.max(-MAX_X, Math.min(MAX_X, startX + (index * GRID_SIZE)));
                            const yPos = Math.max(-MAX_Y, Math.min(MAX_Y, levelIndex * GRID_SPACING));
                            
                            network.body.data.nodes.update({
                                id: nodeId,
                                fixed: {
                                    x: true,
                                    y: true
                                },
                                x: xPos,
                                y: yPos
                            });
                        });
                    });

                    // Ajustar el zoom para mostrar todos los nodos
                    network.fit({
                        animation: {
                            duration: 1000,
                            easingFunction: 'easeInOutQuad'
                        }
                    });
                });

                // Función para ajustar la posición al grid más cercano
                function snapToGrid(position) {
                    return {
                        x: Math.round(position.x / GRID_SIZE) * GRID_SIZE,
                        y: Math.round(position.y / GRID_SPACING) * GRID_SPACING
                    };
                }

                // Función para mantener los nodos dentro de los límites
                function constrainPosition(position) {
                    return {
                        x: Math.max(-MAX_X, Math.min(MAX_X, position.x)),
                        y: Math.max(-MAX_Y, Math.min(MAX_Y, position.y))
                    };
                }

                // Manejar el movimiento de los nodos
                network.on("dragEnd", function(params) {
                    if (params.nodes.length > 0) {
                        const nodeId = params.nodes[0];
                        const position = network.getPosition(nodeId);
                        const constrained = constrainPosition(position);
                        const snapped = snapToGrid(constrained);
                        
                        network.body.data.nodes.update({
                            id: nodeId,
                            x: snapped.x,
                            y: snapped.y,
                            fixed: {
                                x: true,
                                y: true
                            }
                        });
                    }
                });

                // Manejar clicks en los nodos
                network.on('click', function(params) {
                    if (params.nodes.length > 0) {
                        const clickedNode = params.nodes[0];
                        const nodeIndex = selectedNodes.indexOf(clickedNode);
                        
                        if (nodeIndex === -1) {
                            selectedNodes.push(clickedNode);
                            network.selectNodes(selectedNodes);
                        } else {
                            selectedNodes.splice(nodeIndex, 1);
                            network.selectNodes(selectedNodes);
                        }

                        if (selectedNodes.length === 2) {
                            const contextMenu = document.getElementById('contextMenu');
                            const [pos1, pos2] = selectedNodes.map(nodeId => 
                                network.getPositions([nodeId])[nodeId]);
                            
                            const centerX = (pos1.x + pos2.x) / 2;
                            const centerY = (pos1.y + pos2.y) / 2;
                            const canvasPos = network.canvasToDOM({x: centerX, y: centerY});
                            
                            contextMenu.style.left = `${canvasPos.x}px`;
                            contextMenu.style.top = `${canvasPos.y}px`;
                            contextMenu.style.display = 'block';
                        } else {
                            document.getElementById('contextMenu').style.display = 'none';
                        }
                    } else {
                        selectedNodes = [];
                        network.selectNodes([]);
                        document.getElementById('contextMenu').style.display = 'none';
                    }
                });

                // Manejar selección de relación desde el menú contextual
                document.querySelectorAll('.context-menu-option').forEach(option => {
                    option.addEventListener('click', function() {
                        if (selectedNodes.length === 2) {
                            const relation = this.dataset.relation;
                            const [fromNode, toNode] = selectedNodes;
                            
                            // Guardar las posiciones actuales de los nodos
                            const fromPos = network.getPosition(fromNode);
                            const toPos = network.getPosition(toNode);
                            
                            const relationColors = {
                                'Inversa': '#FF4444',
                                'Transitiva': '#33CC33',
                                'Simétrica': '#9933CC',
                                'Funcional': '#FF8C00',
                                'Inversamente Funcional': '#00CED1'
                            };

                            // Añadir la nueva arista
                            graphData.edges.add({
                                from: fromNode,
                                to: toNode,
                                label: relation,
                                arrows: {
                                    to: {
                                        enabled: true,
                                        type: 'arrow'
                                    }
                                },
                                color: {
                                    color: relationColors[relation] || '#666666'
                                },
                                smooth: {
                                    enabled: true,
                                    type: 'curvedCW',
                                    roundness: 0.2
                                },
                                width: 2,
                                dashes: false,
                                physics: false, // Deshabilitamos la física para evitar movimientos no deseados
                                font: {
                                    size: 12,
                                    color: relationColors[relation] || '#666666',
                                    face: 'arial',
                                    background: 'white',
                                    strokeWidth: 2
                                }
                            });

                            // Asegurar que los nodos mantengan sus posiciones
                            network.body.data.nodes.update([
                                {
                                    id: fromNode,
                                    x: fromPos.x,
                                    y: fromPos.y,
                                    fixed: {
                                        x: true,
                                        y: true
                                    }
                                },
                                {
                                    id: toNode,
                                    x: toPos.x,
                                    y: toPos.y,
                                    fixed: {
                                        x: true,
                                        y: true
                                    }
                                }
                            ]);
                            
                            document.getElementById('contextMenu').style.display = 'none';
                            selectedNodes = [];
                            network.selectNodes([]);
                        }
                    });
                });

                // Ocultar menú al hacer clic en el fondo
                document.addEventListener('click', function(e) {
                    if (!e.target.closest('.context-menu') && 
                        !e.target.closest('.vis-network')) {
                        document.getElementById('contextMenu').style.display = 'none';
                        selectedNodes = [];
                        network.selectNodes([]);
                    }
                });
                
                // Restaurar la posición de la vista si existía previamente
                if (viewPosition) {
                    network.moveTo({
                        position: viewPosition.position,
                        scale: viewPosition.scale
                    });
                }
                
                // Guardar referencia a la red para futuras actualizaciones
                container._network = network;
                
                // Limpiar error y mostrar botón
                const errorDiv = document.getElementById('yamlError');
                const visualizeButton = document.getElementById('visualizeButton');
                errorDiv.classList.remove('show');
                visualizeButton.classList.remove('hide');
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 300);
                document.getElementById('yamlInput').classList.remove('error');
                
                // Añadir el minimapa
                const minimapContainer = document.getElementById('minimap');
                const minimapOptions = {
                    ...options,
                    interaction: {
                        dragNodes: false,
                        dragView: false,
                        zoomView: false,
                        selectable: false,
                        hover: false
                    },
                    manipulation: {
                        enabled: false
                    },
                    nodes: {
                        ...options.nodes,
                        size: 10,
                        font: {
                            size: 8
                        }
                    },
                    edges: {
                        ...options.edges,
                        width: 1,
                        font: {
                            size: 0
                        }
                    },
                    physics: {
                        enabled: false
                    }
                };
                
                const minimap = new vis.Network(minimapContainer, {
                    nodes: graphData.nodes,
                    edges: graphData.edges
                }, minimapOptions);
                
                // Añadir el indicador de viewport
                const indicator = document.createElement('div');
                indicator.className = 'viewport-indicator';
                minimapContainer.appendChild(indicator);

                // Modificar la función updateViewportIndicator para usar el centro del canvas
                function updateViewportIndicator() {
                    const mainViewPosition = network.getViewPosition();
                    const mainScale = network.getScale();
                    const minimapScale = minimap.getScale();
                    
                    // Convertir las coordenadas del grafo principal a coordenadas del minimapa
                    const minimapPos = minimap.canvasToDOM({
                        x: mainViewPosition.x,
                        y: mainViewPosition.y
                    });
                    
                    // Actualizar la posición del indicador
                    indicator.style.left = `${minimapPos.x}px`;
                    indicator.style.top = `${minimapPos.y}px`;
                    
                    // Calcular coordenadas del grid usando la posición del punto central
                    const gridX = Math.round(mainViewPosition.x / GRID_SIZE);
                    const gridY = Math.round(mainViewPosition.y / GRID_SPACING);
                    document.getElementById('gridCoordinates').textContent = `(${gridX}, ${gridY})`;
                    
                    // Encontrar el nodo más cercano al centro del canvas
                    const allNodes = network.body.data.nodes.get();
                    let closestNode = null;
                    let minDistance = Infinity;
                    
                    allNodes.forEach(node => {
                        const nodePos = network.getPosition(node.id);
                        const distance = Math.sqrt(
                            Math.pow(nodePos.x - mainViewPosition.x, 2) + 
                            Math.pow(nodePos.y - mainViewPosition.y, 2)
                        );
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestNode = node;
                        }
                    });
                    
                    document.getElementById('centerNode').textContent = 
                        closestNode ? `${closestNode.label} (${closestNode.id})` : 'Ninguno';
                }

                // Añadir más eventos para actualizar la información
                network.on('zoom', updateViewportIndicator);
                network.on('dragEnd', updateViewportIndicator);
                network.on('dragStart', updateViewportIndicator);
                network.on('drag', updateViewportIndicator);

                // Asegurarse de que el minimapa mantenga la misma disposición que el grafo principal
                minimap.once('afterDrawing', function() {
                    minimap.fit({
                        animation: false
                    });
                    
                    // Mantener esta vista completa
                    const minimapScale = minimap.getScale();
                    const minimapPosition = minimap.getViewPosition();
                    
                    // Copiar las posiciones de los nodos del grafo principal al minimapa
                    network.once('stabilized', function() {
                        const positions = network.getPositions();
                        Object.keys(positions).forEach(nodeId => {
                            minimap.moveNode(nodeId, positions[nodeId].x, positions[nodeId].y);
                        });
                        
                        // Ajustar la vista del minimapa
                        minimap.fit({
                            animation: false
                        });
                    });
                    
                    // Actualizar el viewport en el minimapa y el indicador
                    network.on('afterDrawing', function() {
                        // Mantener las posiciones sincronizadas
                        const positions = network.getPositions();
                        Object.keys(positions).forEach(nodeId => {
                            minimap.moveNode(nodeId, positions[nodeId].x, positions[nodeId].y);
                        });
                        
                        minimap.moveTo({
                            position: minimapPosition,
                            scale: minimapScale,
                            animation: false
                        });
                        updateViewportIndicator();
                    });
                    
                    // Actualización inicial del indicador
                    updateViewportIndicator();
                });
                
            } catch (error) {
                console.error('Error:', error);
                const errorDiv = document.getElementById('yamlError');
                const visualizeButton = document.getElementById('visualizeButton');
                
                errorDiv.style.display = 'block';
                visualizeButton.classList.add('hide');
                
                // Forzar un reflow para que la animación funcione
                errorDiv.offsetHeight;
                errorDiv.innerHTML = `
                    <div>
                        <span class="error-icon">⚠️</span>
                        <strong>Mala indentación!!!</strong>
                    </div>
                    <div class="error-message">${formatYamlError(error)}</div>
                `;
                errorDiv.classList.add('show');
                document.getElementById('yamlInput').classList.add('error');
            }
        }

        // Event listener para Tab y Ctrl+Enter
        document.getElementById('yamlInput').addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                const value = this.value;
                
                if (start !== end) {
                    const beforeSelection = value.substring(0, start);
                    const selection = value.substring(start, end);
                    const afterSelection = value.substring(end);
                    
                    const indentedText = selection
                        .split('\n')
                        .map(line => '  ' + line)
                        .join('\n');
                    
                    this.value = beforeSelection + indentedText + afterSelection;
                    this.selectionStart = start;
                    this.selectionEnd = start + indentedText.length;
                } else {
                    this.value = value.substring(0, start) + '  ' + value.substring(end);
                    this.selectionStart = this.selectionEnd = start + 2;
                }
            }
            
            if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault();
                visualizeGraph();
            }
        });

        function processHierarchy(data, container, level = 0) {
            const ul = document.createElement('ul');
            ul.className = 'json-hierarchy';
            ul.style.paddingLeft = level > 0 ? '20px' : '0';

            Object.entries(data).forEach(([key, value]) => {
                if (key === 'id') return;

                const li = document.createElement('li');
                const nodeItem = document.createElement('div');
                nodeItem.className = 'node-item';

                const keySpan = document.createElement('span');
                keySpan.className = 'key';
                keySpan.textContent = key;

                nodeItem.appendChild(keySpan);

                if (typeof value === 'object' && value !== null) {
                    nodeItem.classList.add('has-children');
                    
                    nodeItem.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const parentLi = this.parentElement;
                        parentLi.classList.toggle('expanded');
                        this.classList.toggle('expanded');
                    });

                    li.appendChild(nodeItem);
                    processHierarchy(value, li, level + 1);
                } else {
                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'value';
                    valueSpan.textContent = value === null ? 
                        ': ¡Has llegado al final de la rama!' : 
                        `: ${value}`;
                    nodeItem.appendChild(valueSpan);
                    li.appendChild(nodeItem);
                }

                ul.appendChild(li);
            });

            container.appendChild(ul);
        }

        async function loadJsonContent(filename) {
            try {
                const response = await fetch(`/get-json-content/${filename}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const jsonData = await response.json();
                
                // Filtrar los IDs antes de mostrar
                const filteredData = filterIds(jsonData);
                
                // Convertir el JSON filtrado a YAML y mostrarlo en el textarea
                const yamlText = jsyaml.dump(filteredData);
                document.getElementById('yamlInput').value = yamlText;
                
                // Mostrar el JSON filtrado
                document.getElementById('jsonOutput').innerHTML = 
                    `<pre>${JSON.stringify(filteredData, null, 2)}</pre>`;
                
                // Visualizar el grafo con los datos filtrados
                visualizeGraph();
                
            } catch (error) {
                console.error('Error loading JSON:', error);
                alert('Error al cargar el archivo JSON: ' + error.message);
            }
        }

        function convertToGraph(data, parentId = null, level = 0) {
            let nodes = [];
            let edges = [];
            let counter = 0;
            
            function processItem(key, value, parentId, currentLevel) {
                // Ignorar si la clave es 'id'
                if (key === 'id') return;
                
                counter++;
                const nodeId = parentId ? `${parentId}_${key}_${counter}` : `${key}_${counter}`;
                
                // Si el valor es un objeto y tiene una propiedad 'id', la omitimos
                if (typeof value === 'object' && value !== null) {
                    delete value['id'];
                }

                // Crear el nodo con la clave como etiqueta y el nivel asignado
                nodes.push({
                    id: nodeId,
                    label: String(key),
                    shape: 'box',
                    level: currentLevel // Asignar el nivel actual
                });
                
                if (parentId) {
                    edges.push({
                        from: parentId,
                        to: nodeId,
                        label: ''
                    });
                }
                
                if (typeof value === 'object' && value !== null) {
                    Object.entries(value).forEach(([k, v]) => {
                        // Omitir propiedades que empiezan con '@' o son 'id'
                        if (!k.startsWith('@') && k !== 'id') {
                            processItem(k, v, nodeId, currentLevel + 1);
                        }
                    });
                } else if (value !== undefined && value !== null && !String(key).startsWith('@') && key !== 'id') {
                    const valueId = `${nodeId}_value_${counter}`;
                    nodes.push({
                        id: valueId,
                        label: String(value),
                        shape: 'box',
                        level: currentLevel + 1 // Asignar nivel para nodos de valor
                    });
                    edges.push({
                        from: nodeId,
                        to: valueId,
                        label: ''
                    });
                }
            }
            
            Object.entries(data).forEach(([key, value]) => {
                // Omitir propiedades que empiezan con '@' o son 'id'
                if (!key.startsWith('@') && key !== 'id') {
                    processItem(key, value, parentId, level);
                }
            });
            
            return { nodes, edges };
        }

        // Añadir función para convertir entre JSON y YAML
        function jsonToYaml(jsonData) {
            try {
                return jsyaml.dump(jsonData);
            } catch (error) {
                console.error('Error converting JSON to YAML:', error);
                return '';
            }
        }

        function yamlToJson(yamlData) {
            try {
                return jsyaml.load(yamlData);
            } catch (error) {
                console.error('Error converting YAML to JSON:', error);
                return null;
            }
        }

        // Modificar saveTaxonomy para manejar YAML
        async function saveTaxonomy() {
            try {
                const yamlData = document.getElementById('yamlInput').value;
                const jsonData = yamlToJson(yamlData);
                
                if (!jsonData) {
                    throw new Error('Error al convertir YAML a JSON');
                }

                const response = await fetch(`/save-taxonomy/${filename}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(jsonData)
                });

                if (!response.ok) {
                    throw new Error('Error al guardar la taxonomía');
                }

                alert('Taxonomía guardada correctamente');
                loadJsonContent(filename);
            } catch (error) {
                console.error('Error:', error);
                alert('Error al guardar la taxonomía: ' + error.message);
            }
        }

        // Función para validar que la taxonomía sigue el formato JSON-LD
        function validateJsonLd(jsonLd) {
            const requiredProperties = ['@context', '@type', '@id', 'prefLabel'];
            for (const prop of requiredProperties) {
                if (!(prop in jsonLd)) {
                    throw new Error(`Falta la propiedad requerida: ${prop}`);
                }
            }
            return true;
        }
    </script>
</body>
</html> 