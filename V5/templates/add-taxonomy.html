<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Añadir Taxonomía</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }

        .container {
            max-width: none;
            margin: 0;
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            flex-shrink: 0;
        }

        .back-btn {
            padding: 8px 16px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .json-preview {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .content-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            flex: 1;
            height: calc(100% - 70px); /* Altura total menos top-bar */
            overflow: hidden;
        }

        .input-section {
            flex: 0 0 400px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            height: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .content-wrapper {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 10px;
            overflow: hidden;
        }

        #yamlInput {
            flex: 1;
            min-height: 0;
            resize: none;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.4;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            white-space: pre;
            overflow-x: auto;
            overflow-y: auto;
        }

        .button-error-container {
            position: relative;
            height: 38px; /* Altura fija igual a la del botón */
            flex-shrink: 0;
        }

        .yaml-error {
            display: none;
            color: #dc3545;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            font-family: 'Consolas', monospace;
            white-space: pre-wrap;
            font-size: 0.9em;
        }

        .error-line {
            background-color: #ffebee;
            display: block;
            font-weight: bold;
        }

        .error-pointer {
            color: #dc3545;
            font-weight: bold;
        }

        button {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        button.hide {
            opacity: 0;
            pointer-events: none;
        }

        .error-icon {
            font-size: 1em;
            margin-right: 5px;
        }

        .error-message {
            font-family: 'Consolas', monospace;
            white-space: pre-wrap;
            margin-top: 5px;
            padding: 5px;
            background-color: #fff;
            border-radius: 4px;
            font-size: 0.85em;
            line-height: 1.4;
        }

        #jsonOutput {
            flex: 0 0 30%;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
        }

        .visualization-section {
            flex: 1;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
            height: 100%;
        }

        #mynetwork {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 15px;
        }

        .taxonomy-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .taxonomy-section {
            padding: 15px;
            background-color: #fff;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }

        .taxonomy-input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }

        .save-btn {
            padding: 10px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 20px;
        }

        .save-btn:hover {
            background-color: #218838;
        }

        /* Añadir los estilos del sistema de jerarquías */
        .json-hierarchy {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .json-hierarchy li {
            margin: 5px 0;
        }

        .node-item {
            background: #ffffff;
            padding: 4px 8px;
            border-radius: 6px;
            margin: 2px 0;
            transition: all 0.3s ease;
            cursor: pointer;
            border-left: 3px solid #3498db;
            position: relative;
            padding-right: 30px;
        }

        .node-item:hover {
            transform: translateX(5px);
            background: #f0f0f0;
        }

        .node-item.has-children {
            border-left: 3px solid #2ecc71;
        }

        .key {
            font-weight: bold;
            color: #2c3e50;
        }

        .value {
            color: #7f8c8d;
            font-style: italic;
        }

        .json-hierarchy ul {
            position: relative;
            display: none;
            padding-left: 20px;
        }

        .json-hierarchy ul::before {
            content: '';
            position: absolute;
            left: -15px;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #e9ecef;
        }

        .json-hierarchy li.expanded > ul {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        .node-item.has-children::after {
            content: '▸';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.3s ease;
        }

        .node-item.has-children.expanded::after {
            transform: translateY(-50%) rotate(90deg);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Diferentes niveles de profundidad */
        .json-hierarchy .node-item {
            border-left-width: 3px;
        }

        .json-hierarchy ul .node-item {
            border-left-color: #e74c3c;  /* Rojo */
        }

        .json-hierarchy ul ul .node-item {
            border-left-color: #f1c40f;  /* Amarillo */
        }

        .json-hierarchy ul ul ul .node-item {
            border-left-color: #9b59b6;  /* Morado */
        }

        .json-hierarchy ul ul ul ul .node-item {
            border-left-color: #2ecc71;  /* Verde */
        }

        .json-hierarchy ul ul ul ul ul .node-item {
            border-left-color: #e67e22;  /* Naranja */
        }

        /* Actualizar estilos del ejemplo */
        .example {
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e1e1e1;
            max-height: 300px;
            overflow-y: auto;
        }

        .example pre {
            margin: 0;
            padding: 15px;
            background-color: #fff;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .example h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--primary-color);
            font-size: 1.2em;
        }

        /* Actualizar estilos para manejar múltiples ejemplos */
        .example pre {
            margin-bottom: 20px;
        }

        .example h3:not(:first-child) {
            margin-top: 20px;
        }

        h3 {
            margin: 0;
            padding: 10px 0;
            flex-shrink: 0;
        }

        /* Actualizar estilos para el menú contextual */
        .context-menu {
            position: absolute;
            top: 10px;
            right: 620px; /* Mantener la distancia desde la derecha */
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            padding: 8px 0;
            z-index: 1000;
            min-width: 200px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0,0,0,0.1);
            display: none; /* Inicialmente oculto */
        }

        .context-menu-option {
            padding: 10px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #333;
            font-size: 14px;
        }

        .context-menu-option:hover {
            background-color: rgba(0,0,0,0.05);
        }

        .context-menu-option.active {
            background-color: rgba(43, 124, 233, 0.1);
            outline: none;
            border-left: 3px solid #2B7CE9;
        }

        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            border: 2px solid rgba(255,255,255,0.8);
            box-shadow: 0 0 4px rgba(0,0,0,0.2);
        }

        /* Añadir estilos para el minimapa */
        .minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            overflow: hidden;
            z-index: 1000;
        }

        #minimap {
            width: 100%;
            height: 100%;
        }

        /* Añadir estilo para el indicador de posición */
        .viewport-indicator {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1001;
            transition: all 0.3s ease-out; /* Añadir transición suave */
        }

        .coordinates-display {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1002;
        }

        .center-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(255, 0, 0, 0.25); /* Cambiado a 25% de opacidad */
            border-radius: 50%;
            left: 50%;  /* Centrado horizontal */
            top: 50%;   /* Centrado vertical */
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            border: 2px solid rgba(255, 255, 255, 0.25); /* También ajustado el borde a 25% de opacidad */
            box-shadow: 0 0 4px rgba(0,0,0,0.25); /* También ajustada la sombra a 25% de opacidad */
        }

        @keyframes shadowPulse {
            0% {
                box-shadow: 0 0 0 rgba(46, 204, 113, 0);
            }
            50% {
                box-shadow: 0 5px 10px rgba(46, 204, 113, 0.5);
            }
            100% {
                box-shadow: 0 0 0 rgba(46, 204, 113, 0);
            }
        }

        .node-shadow-animation {
            animation: shadowPulse 2s infinite;
        }

        .format-selector {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .format-selector select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            font-size: 14px;
            cursor: pointer;
        }

        .format-selector select:hover {
            border-color: #2B7CE9;
        }

        .format-selector select:focus {
            outline: none;
            border-color: #2B7CE9;
            box-shadow: 0 0 0 2px rgba(43, 124, 233, 0.2);
        }

        .properties-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .properties-panel.minimized .properties-content {
            display: none;
        }

        .properties-panel.minimized .minimize-btn {
            transform: rotate(180deg);
        }

        .properties-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
        }

        .properties-header h4 {
            margin: 0;
            font-size: 14px;
            color: #333;
        }

        .minimize-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            padding: 0 5px;
        }

        .minimize-btn:hover {
            color: #333;
        }

        .properties-content {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }

        /* Estilos heredados del index.html para la jerarquía */
        .properties-content .hierarchy-container {
            margin-top: 0;
            padding: 5px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        .relation-info-panel {
            position: absolute;
            bottom: 20px;
            left: 620px; /* Cambiado de right a left y ajustado para alinearse con el menú contextual */
            width: 300px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .relation-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
        }

        .relation-info-content {
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .relation-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .relation-item:last-child {
            border-bottom: none;
        }

        .delete-relation {
            color: #dc3545;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .delete-relation:hover {
            background-color: #dc3545;
            color: white;
        }

        /* Añadir estilos CSS para los items activos en el panel de relaciones */
        .relation-item.active {
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        .relation-info-content {
            max-height: 200px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #888 #f0f0f0;
        }
        .relation-info-content::-webkit-scrollbar {
            width: 6px;
        }
        .relation-info-content::-webkit-scrollbar-track {
            background: #f0f0f0;
        }
        .relation-info-content::-webkit-scrollbar-thumb {
            background-color: #888;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-bar">
            <h2>Añadir Taxonomía - <span id="filename"></span></h2>
            <button class="back-btn" onclick="window.location.href='/dashboard'">Volver</button>
        </div>

        <div class="content-container">
            <div class="input-section">
                <div class="content-wrapper">
                    <textarea id="yamlInput" placeholder="Escribe tu taxonomía usando YAML..."></textarea>
                    <div class="button-error-container">
                        <div id="yamlError" class="yaml-error">
                            <span class="error-icon">⚠️</span>
                            <span id="errorMessage"></span>
                        </div>
                        <button id="saveButton" onclick="saveTaxonomy()">Guardar Modificación</button>
                    </div>
                    <div class="format-selector">
                        <h3>JSON Resultante:</h3>
                        <select id="formatSelector" onchange="updateOutputFormat()">
                            <option value="json">JSON</option>
                            <option value="jsonld">JSON-LD</option>
                            <option value="rdf">XML/RDF</option>
                        </select>
                    </div>
                    <div id="jsonOutput" style="white-space: pre; font-family: monospace;"></div>
                </div>
            </div>

            <div class="visualization-section">
                <div id="mynetwork"></div>
                <div class="center-marker"></div>
                <div class="minimap-container">
                    <div id="minimap"></div>
                    <div class="coordinates-display">
                        <div>Nodo: <span id="centerNode"></span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Añadir el menú contextual -->
    <div id="contextMenu" class="context-menu">
        <div class="context-menu-option" data-relation="Funcional">
            <span class="color-dot" style="background-color: #FF8C00"></span>
            Funcional
        </div>
        <div class="context-menu-option" data-relation="Inversa">
            <span class="color-dot" style="background-color: #FF4444"></span>
            Inversa
        </div>
        <div class="context-menu-option" data-relation="Inversamente Funcional">
            <span class="color-dot" style="background-color: #00CED1"></span>
            Inversamente Funcional
        </div>
        <div class="context-menu-option" data-relation="Simétrica">
            <span class="color-dot" style="background-color: #9933CC"></span>
            Simétrica
        </div>
        <div class="context-menu-option" data-relation="Transitiva">
            <span class="color-dot" style="background-color: #33CC33"></span>
            Transitiva
        </div>
    </div>

    <!-- Añadir después del div del minimapa -->
    <div class="properties-panel">
        <div class="properties-header">
            <h4>Jerarquía de Propiedades</h4>
            <button class="minimize-btn">−</button>
        </div>
        <div class="properties-content" id="propertiesContainer">
            <!-- Se llenará dinámicamente -->
        </div>
    </div>

    <!-- Añadir después de la definición del panel de propiedades -->

    <!-- Añadir panel de información de relaciones -->
    <div class="relation-info-panel">
        <div class="relation-info-header">
            <h4>Relaciones Seleccionadas</h4>
            <button class="minimize-btn">−</button>
        </div>
        <div class="relation-info-content"></div>
    </div>

    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script>
        // Añadir al inicio del script, junto con las otras variables globales
        const DEFAULT_ZOOM = 0.8; // Puedes ajustar este valor según necesites
        let currentZoom = DEFAULT_ZOOM;

        // Declaración global de nodeShadows
        let nodeShadows = new Map();

        // Añadir la variable de configuración al inicio del script
        const NODE_LABEL_MAX_LENGTH = 20; // Puedes ajustar este valor según necesites

        // Añadir variable para controlar el temporizador de autoguardado
        let autoSaveTimer;
        const AUTO_SAVE_DELAY = 30000; // 30 segundos

        // Declarar network como variable global
        let network;

        // Modificar la función de carga inicial
        window.onload = function() {
            if (!sessionStorage.getItem('user')) {
                window.location.href = '/';
            }

            const urlParts = window.location.pathname.split('/');
            const filename = decodeURIComponent(urlParts[urlParts.length - 1]);
            
            const filenameElement = document.getElementById('filename');
            if (filenameElement) {
                filenameElement.textContent = filename;
            }

            // Cargar el JSON específico del archivo
            loadJsonContent(filename);
        }

        // Función para filtrar los campos 'id' de un objeto
        function filterIds(obj) {
            if (Array.isArray(obj)) {
                return obj.map(item => filterIds(item));
            } else if (typeof obj === 'object' && obj !== null) {
                const filtered = {};
                for (const [key, value] of Object.entries(obj)) {
                    if (key !== 'id') {
                        filtered[key] = filterIds(value);
                    }
                }
                return filtered;
            }
            return obj;
        }

        // Función de autoguardado centralizada
        function triggerAutoSave(source = 'editor') {
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(async () => {
                try {
                    // Verificar si network existe y está inicializado
                    const currentPosition = network?.getViewPosition() || null;
                    const currentScale = network?.getScale() || null;
                    
                    await saveTaxonomy();
                    
                    // Restaurar la posición y zoom después de guardar si network existe
                    if (network && currentPosition && currentScale) {
                        network.moveTo({
                            position: currentPosition,
                            scale: currentScale,
                            animation: false
                        });
                    }
                    
                    // Mostrar indicador de autoguardado
                    const autoSaveIndicator = document.createElement('div');
                    autoSaveIndicator.style.cssText = `
                        position: fixed;
                        bottom: 20px;
                        right: 20px;
                        background-color: rgba(46, 204, 113, 0.9);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 4px;
                        font-size: 14px;
                        z-index: 1000;
                        animation: fadeOut 2s forwards;
                    `;
                    autoSaveIndicator.textContent = `Autoguardado completado (${source})`;
                    document.body.appendChild(autoSaveIndicator);
                    
                    setTimeout(() => {
                        autoSaveIndicator.remove();
                    }, 2000);
                    
                } catch (error) {
                    console.error('Error en autoguardado:', error);
                }
            }, 500);
        }

        // Modificar el event listener del textarea
        document.getElementById('yamlInput').addEventListener('input', debounce(function() {
            const errorDiv = document.getElementById('yamlError');
            const saveButton = document.getElementById('saveButton');
            
            try {
                const yamlData = this.value;
                const jsonData = yamlToJson(yamlData);
                
                if (jsonData) {
                    updateOutputFormat();
                    visualizeGraph();
                    
                    errorDiv.classList.remove('show');
                    saveButton.classList.remove('hide');
                    
                    // Activar autoguardado solo cuando hay cambios en el YAML
                    triggerAutoSave('editor YAML');
                }
            } catch (error) {
                errorDiv.style.display = 'block';
                errorDiv.innerHTML = formatYamlError(error);
                errorDiv.classList.add('show');
                saveButton.classList.add('hide');
                
                clearTimeout(autoSaveTimer);
            }
        }, 300));

        // Función debounce para evitar demasiadas actualizaciones
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function formatYamlError(error) {
            if (!error.message) return 'Error desconocido';

            // Extraer información del error
            let errorLine, errorColumn;
            let customMessage = '';

            // Manejar diferentes tipos de errores YAML
            if (error.message.includes('bad indentation')) {
                const match = error.message.match(/\((\d+):(\d+)\)/);
                if (match) {
                    errorLine = parseInt(match[1]);
                    errorColumn = parseInt(match[2]);
                    customMessage = '⚠️ Error de indentación - Asegúrate de usar 2 espacios para cada nivel';
                }
            } else if (error.message.includes('can not read a block mapping entry')) {
                const match = error.message.match(/\((\d+):(\d+)\)/);
                if (match) {
                    errorLine = parseInt(match[1]);
                    errorColumn = parseInt(match[2]);
                    customMessage = '⚠️ Error de formato - Verifica los dos puntos (:) y la indentación';
                }
            }

            if (!errorLine || !errorColumn) return error.message;

            // Obtener el contexto del error
            const yaml = document.getElementById('yamlInput').value;
            const lines = yaml.split('\n');
            const start = Math.max(0, errorLine - 3);
            const end = Math.min(lines.length, errorLine + 2);
            
            let contextLines = [];
            for (let i = start; i < end; i++) {
                const lineNum = i + 1;
                const isErrorLine = lineNum === errorLine;
                const line = `${lineNum} | ${lines[i]}`;
                
                if (isErrorLine) {
                    contextLines.push(`<span class="error-line">${line}</span>`);
                    contextLines.push(`${' '.repeat(errorColumn + 3)}<span class="error-pointer">^--- Error aquí</span>`);
                } else {
                    contextLines.push(line);
                }
            }

            return `${customMessage}\n\n${contextLines.join('\n')}`;
        }

        function visualizeGraph() {
            const errorDiv = document.getElementById('yamlError');
            const saveButton = document.getElementById('saveButton');
            
            try {
                const yamlInput = document.getElementById('yamlInput').value;
                const jsonData = jsyaml.load(yamlInput);
                
                if (jsonData) {
                    // Limpiar mensaje de error si existe
                    errorDiv.style.display = 'none';
                    errorDiv.classList.remove('show');
                    saveButton.classList.remove('hide');
                    document.getElementById('yamlInput').classList.remove('error');
                    
                    // Continuar con la visualización
                    const { nodes, edges } = convertToGraph(jsonData);
                    
                    const container = document.getElementById('mynetwork');
                    const graphData = {
                        nodes: new vis.DataSet(nodes),
                        edges: new vis.DataSet(edges)
                    };
                    
                    // Mantener el estado del zoom y la posición de la vista
                    let network = container._network;
                    let viewPosition = network ? {
                        position: network.getViewPosition(),
                        scale: network.getScale()
                    } : null;
                    
                    const options = {
                        layout: {
                            hierarchical: {
                                direction: 'UD',
                                sortMethod: 'directed',
                                nodeSpacing: 150,
                                levelSeparation: 150,
                                treeSpacing: 200
                            }
                        },
                        physics: {
                            enabled: false,
                            stabilization: {
                                enabled: true,
                                iterations: 1000
                            }
                        },
                        edges: {
                            arrows: 'to',
                            smooth: {
                                type: 'cubicBezier',
                                forceDirection: 'vertical',
                                roundness: 0.2
                            },
                            color: {
                                color: '#2B7CE9'
                            },
                            selectionWidth: 3,
                            chosen: {
                                edge: function(values, id, selected, hovering) {
                                    if (selected) {
                                        values.width = 4;
                                        values.color = '#2ecc71';
                                        values.shadow = true;
                                        values.shadowColor = 'rgba(46, 204, 113, 0.6)';
                                        values.shadowSize = 15;
                                        values.shadowX = 0;
                                        values.shadowY = 0;
                                        values.glow = true;
                                    }
                                }
                            }
                        },
                        nodes: {
                            shape: 'box',
                            margin: 10,
                            font: {
                                size: 16,
                                face: 'arial'
                            },
                            color: {
                                background: '#D2E5FF',
                                border: '#2B7CE9'
                            },
                            shadow: true
                        },
                        manipulation: {
                            enabled: false
                        },
                        interaction: {
                            dragNodes: true,
                            dragView: true,
                            zoomView: true,
                            hover: false,  // Desactivar hover
                            hoverConnectedEdges: false,  // Desactivar resaltado de bordes al pasar el ratón
                            selectConnectedEdges: true,  // Mantener la selección de bordes al hacer clic
                            tooltipDelay: 300,  // Aumentar el retraso del tooltip para evitar apariciones no deseadas
                            keyboard: {
                                enabled: true,
                                speed: {
                                    x: 10,
                                    y: 10,
                                    zoom: 0.02
                                },
                                bindToWindow: false
                            }
                        }
                    };
                    
                    network = new vis.Network(container, graphData, options);

                    // Asegurarnos de que el zoom inicial se aplique después de que el grafo esté listo
                    network.once('stabilized', () => {
                        const rootNode = nodes[0];
                        if (rootNode) {
                            network.focus(rootNode.id, {
                                scale: currentZoom,
                                animation: {
                                    duration: 1000,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                            network.selectNodes([rootNode.id]);
                            currentNodeId = rootNode.id;
                        }
                    });

                    // Añadir un respaldo por si 'stabilized' no se dispara
                    setTimeout(() => {
                        const rootNode = nodes[0];
                        if (rootNode && (!network.getScale() || network.getScale() === 1)) {
                            network.focus(rootNode.id, {
                                scale: currentZoom,
                                animation: {
                                    duration: 1000,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                            network.selectNodes([rootNode.id]);
                            currentNodeId = rootNode.id;
                        }
                    }, 1000);

                    let selectedNodes = [];
                    let currentNodeId = null;
                    let gridNodes = {};
                    const GRID_SIZE = 100;    // Tamaño de la celda del grid en el eje X
                    const GRID_SPACING = 150; // Tamaño de la celda del grid en el eje Y (mayor para jerarquías)

                    // Función para organizar los nodos en una estructura de grid
                    function updateGridStructure() {
                        gridNodes = {};
                        const positions = network.getPositions();
                        
                        Object.entries(positions).forEach(([nodeId, pos]) => {
                            const x = Math.round(pos.x / GRID_SIZE) * GRID_SIZE;
                            const y = Math.round(pos.y / GRID_SPACING) * GRID_SPACING;
                            
                            if (!gridNodes[y]) gridNodes[y] = {};
                            gridNodes[y][x] = nodeId;
                        });
                    }

                    // Función para encontrar el nodo más cercano en la dirección especificada
                    function findNextNode(direction) {
                        if (!currentNodeId) {
                            const firstNode = network.body.data.nodes.get()[0];
                            if (firstNode) {
                                currentNodeId = firstNode.id;
                                network.selectNodes([currentNodeId]);
                                return;
                            }
                        }

                        const currentPos = network.getPosition(currentNodeId);
                        const currentX = Math.round(currentPos.x / GRID_SIZE) * GRID_SIZE;
                        const currentY = Math.round(currentPos.y / GRID_SPACING) * GRID_SPACING;
                        
                        let nextNodeId = null;
                        let minDistance = Infinity;
                        
                        switch (direction) {
                            case 'up':
                                // Buscar el nodo más cercano en el nivel inmediatamente superior
                                let closestUpperY = -Infinity;
                                for (const y in gridNodes) {
                                    const gridY = parseInt(y);
                                    if (gridY < currentY && gridY > closestUpperY) {
                                        closestUpperY = gridY;
                                    }
                                }
                                if (closestUpperY !== -Infinity) {
                                    for (const x in gridNodes[closestUpperY]) {
                                        const distance = Math.abs(parseInt(x) - currentX);
                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            nextNodeId = gridNodes[closestUpperY][x];
                                        }
                                    }
                                } else {
                                    // Efecto de "rebote" hacia arriba
                                    network.moveTo({
                                        position: { x: currentPos.x, y: currentPos.y - 50 },
                                        animation: {
                                            duration: 150,
                                            easingFunction: 'easeOutQuint'
                                        }
                                    });
                                    setTimeout(() => {
                                        network.moveTo({
                                            position: currentPos,
                                            animation: {
                                                duration: 200,
                                                easingFunction: 'linear'
                                            }
                                        });
                                    }, 150);
                                }
                                break;
                                
                            case 'down':
                                let closestLowerY = Infinity;
                                for (const y in gridNodes) {
                                    const gridY = parseInt(y);
                                    if (gridY > currentY && gridY < closestLowerY) {
                                        closestLowerY = gridY;
                                    }
                                }
                                if (closestLowerY !== Infinity) {
                                    for (const x in gridNodes[closestLowerY]) {
                                        const distance = Math.abs(parseInt(x) - currentX);
                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            nextNodeId = gridNodes[closestLowerY][x];
                                        }
                                    }
                                } else {
                                    // Efecto de "rebote" hacia abajo
                                    network.moveTo({
                                        position: { x: currentPos.x, y: currentPos.y + 50 },
                                        animation: {
                                            duration: 150,
                                            easingFunction: 'easeOutQuint'
                                        }
                                    });
                                    setTimeout(() => {
                                        network.moveTo({
                                            position: currentPos,
                                            animation: {
                                                duration: 200,
                                                easingFunction: 'linear'
                                            }
                                        });
                                    }, 150);
                                }
                                break;
                                
                            case 'left':
                                let closestLeftX = -Infinity;
                                if (gridNodes[currentY]) {
                                    for (const x in gridNodes[currentY]) {
                                        const gridX = parseInt(x);
                                        if (gridX < currentX && gridX > closestLeftX) {
                                            closestLeftX = gridX;
                                            nextNodeId = gridNodes[currentY][x];
                                        }
                                    }
                                }
                                if (nextNodeId === null) {
                                    // Efecto de "rebote" hacia la izquierda
                                    network.moveTo({
                                        position: { x: currentPos.x - 50, y: currentPos.y },
                                        animation: {
                                            duration: 150,
                                            easingFunction: 'easeOutQuint'
                                        }
                                    });
                                    setTimeout(() => {
                                        network.moveTo({
                                            position: currentPos,
                                            animation: {
                                                duration: 200,
                                                easingFunction: 'linear'
                                            }
                                        });
                                    }, 150);
                                }
                                break;
                                
                            case 'right':
                                let closestRightX = Infinity;
                                if (gridNodes[currentY]) {
                                    for (const x in gridNodes[currentY]) {
                                        const gridX = parseInt(x);
                                        if (gridX > currentX && gridX < closestRightX) {
                                            closestRightX = gridX;
                                            nextNodeId = gridNodes[currentY][x];
                                        }
                                    }
                                }
                                if (nextNodeId === null) {
                                    // Efecto de "rebote" hacia la derecha
                                    network.moveTo({
                                        position: { x: currentPos.x + 50, y: currentPos.y },
                                        animation: {
                                            duration: 150,
                                            easingFunction: 'easeOutQuint'
                                        }
                                    });
                                    setTimeout(() => {
                                        network.moveTo({
                                            position: currentPos,
                                            animation: {
                                                duration: 200,
                                                easingFunction: 'linear'
                                            }
                                        });
                                    }, 150);
                                }
                                break;
                        }

                        if (nextNodeId) {
                            currentNodeId = nextNodeId;
                            network.selectNodes([...selectedNodes, currentNodeId]);
                            
                            selectedNodes.forEach(nodeId => {
                                network.body.data.nodes.update({
                                    id: nodeId,
                                    shadow: {
                                        enabled: true,
                                        color: 'rgba(46, 204, 113, 0.5)', // Verde #2ecc71 con transparencia
                                        size: 10,
                                        x: 0,
                                        y: 5
                                    },
                                    shapeProperties: {
                                        borderDashes: false,
                                        interpolation: true,
                                        useImageSize: false,
                                        useBorderWithImage: false,
                                        animation: {
                                            enabled: true,
                                            duration: 2000,
                                            easingFunction: 'easeInOutQuad'
                                        }
                                    }
                                });
                            });
                            
                            network.focus(currentNodeId, {
                                scale: network.getScale(),
                                animation: {
                                    duration: 300,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                        }
                    }

                    // Añadir event listener para las teclas de flecha y espaciadora
                    document.addEventListener('keydown', function(e) {
                        const yamlInput = document.getElementById('yamlInput');
                        const contextMenu = document.getElementById('contextMenu');
                        const relationPanel = document.querySelector('.relation-info-panel');
                        const isContextMenuVisible = contextMenu.style.display === 'block';
                        const isRelationPanelVisible = relationPanel && !relationPanel.classList.contains('minimized');
                        
                        // Si el foco está en el textarea, no procesar las teclas
                        if (document.activeElement === yamlInput) {
                            return;
                        }

                        if (!network) return;
                        
                        // Manejar primero el panel de relaciones si está visible y tiene contenido
                        if (isRelationPanelVisible) {
                            const relationItems = relationPanel.querySelectorAll('.relation-item');
                            if (relationItems.length > 0) {
                                let currentIndex = Array.from(relationItems).findIndex(item => item.classList.contains('active'));
                                if (currentIndex === -1) currentIndex = 0;

                                switch(e.key) {
                                    case 'ArrowUp':
                                        e.preventDefault();
                                        relationItems[currentIndex]?.classList.remove('active');
                                        currentIndex = (currentIndex - 1 + relationItems.length) % relationItems.length;
                                        relationItems[currentIndex].classList.add('active');
                                        relationItems[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                        return;
                                    case 'ArrowDown':
                                        e.preventDefault();
                                        relationItems[currentIndex]?.classList.remove('active');
                                        currentIndex = (currentIndex + 1) % relationItems.length;
                                        relationItems[currentIndex].classList.add('active');
                                        relationItems[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                        return;
                                    case 'Enter':
                                        e.preventDefault();
                                        // Simular clic en el botón de eliminar de la relación activa
                                        const activeItem = relationItems[currentIndex];
                                        if (activeItem) {
                                            const deleteButton = activeItem.querySelector('.delete-relation');
                                            if (deleteButton) {
                                                deleteButton.click();
                                            }
                                        }
                                        return;
                                    case 'Escape':
                                        e.preventDefault();
                                        network.unselectAll();
                                        return;
                                }
                            }
                        }
                        
                        // Si el menú contextual está visible, manejar su navegación
                        if (isContextMenuVisible) {
                            const options = contextMenu.querySelectorAll('.context-menu-option');
                            let currentIndex = Array.from(options).findIndex(option => option.classList.contains('active'));
                            if (currentIndex === -1) currentIndex = 0;

                            switch(e.key) {
                                case 'ArrowUp':
                                    e.preventDefault();
                                    options[currentIndex]?.classList.remove('active');
                                    currentIndex = (currentIndex - 1 + options.length) % options.length;
                                    options[currentIndex].classList.add('active');
                                    return;
                                case 'ArrowDown':
                                    e.preventDefault();
                                    options[currentIndex]?.classList.remove('active');
                                    currentIndex = (currentIndex + 1) % options.length;
                                    options[currentIndex].classList.add('active');
                                    return;
                                case 'Enter':
                                    e.preventDefault();
                                    // Simular clic en la opción activa
                                    const activeOption = options[currentIndex];
                                    if (activeOption) {
                                        activeOption.click();
                                    }
                                    return;
                                case 'Escape':
                                    e.preventDefault();
                                    contextMenu.style.display = 'none';
                                    return;
                            }
                        }
                        
                        // Navegación normal del grafo
                        updateGridStructure();
                        
                        switch(e.key) {
                            case ' ':
                                e.preventDefault();
                                const rootNode = network.body.data.nodes.get()[0];
                                if (rootNode) {
                                    currentNodeId = rootNode.id;
                                    network.selectNodes([currentNodeId]);
                                    network.focus(rootNode.id, {
                                        scale: currentZoom,
                                        animation: {
                                            duration: 1000,
                                            easingFunction: 'easeInOutQuad'
                                        }
                                    });
                                }
                                break;
                            case 'ArrowUp':
                                e.preventDefault();
                                findNextNode('up');
                                break;
                            case 'ArrowDown':
                                e.preventDefault();
                                findNextNode('down');
                                break;
                            case 'ArrowLeft':
                                e.preventDefault();
                                findNextNode('left');
                                break;
                            case 'ArrowRight':
                                e.preventDefault();
                                findNextNode('right');
                                break;
                            case 'Enter':
                                e.preventDefault();
                                if (currentNodeId) {
                                    const nodeIndex = selectedNodes.indexOf(currentNodeId);
                                    
                                    if (nodeIndex === -1) {
                                        selectedNodes.push(currentNodeId);
                                        network.body.data.nodes.update({
                                            id: currentNodeId,
                                            shadow: {
                                                enabled: true,
                                                color: 'rgba(46, 204, 113, 0.5)',
                                                size: 10,
                                                x: 0,
                                                y: 5
                                            }
                                        });
                                    } else {
                                        selectedNodes.splice(nodeIndex, 1);
                                        network.body.data.nodes.update({
                                            id: currentNodeId,
                                            shadow: {
                                                enabled: false
                                            }
                                        });
                                    }
                                    network.selectNodes(selectedNodes);

                                    if (selectedNodes.length === 2) {
                                        contextMenu.style.display = 'block';
                                        const options = contextMenu.querySelectorAll('.context-menu-option');
                                        options.forEach((option, index) => {
                                            option.classList[index === 0 ? 'add' : 'remove']('active');
                                        });
                                    } else {
                                        contextMenu.style.display = 'none';
                                    }
                                }
                                break;
                            case 'Delete':
                            case 'Backspace':
                                if (selectedEdges.length > 0) {
                                    if (confirm('¿Deseas eliminar las relaciones seleccionadas?')) {
                                        network.body.data.edges.remove(selectedEdges);
                                        network.setSelection({ edges: [] });
                                        updateOutputFormat();
                                        triggerAutoSave('eliminación de relaciones');
                                    }
                                }
                                break;
                        }
                    });

                    // Actualizar la estructura del grid cuando el grafo se estabilice
                    network.once('stabilized', () => {
                        updateGridStructure();
                    });

                    // Modificar el manejador de clicks en los nodos
                    network.on("click", function(params) {
                        if (params.nodes.length > 0) {
                            const nodeId = params.nodes[0];
                            currentNodeId = nodeId;
                            
                            const nodeIndex = selectedNodes.indexOf(nodeId);
                            
                            // Si ya hay 2 nodos seleccionados y se intenta seleccionar un tercero diferente
                            if (selectedNodes.length === 2 && nodeIndex === -1) {
                                // Deseleccionar todos los nodos
                                selectedNodes.forEach(id => {
                                    network.body.data.nodes.update({
                                        id: id,
                                        shadow: {
                                            enabled: false
                                        }
                                    });
                                });
                                selectedNodes = [nodeId]; // Comenzar nueva selección con el nodo actual
                                network.body.data.nodes.update({
                                    id: nodeId,
                                    shadow: {
                                        enabled: true,
                                        color: 'rgba(46, 204, 113, 0.5)',
                                        size: 10,
                                        x: 0,
                                        y: 5
                                    }
                                });
                            } else if (nodeIndex === -1) {
                                // Añadir a la selección si no está seleccionado
                                selectedNodes.push(nodeId);
                                network.body.data.nodes.update({
                                    id: nodeId,
                                    shadow: {
                                        enabled: true,
                                        color: 'rgba(46, 204, 113, 0.5)',
                                        size: 10,
                                        x: 0,
                                        y: 5
                                    }
                                });
                            } else {
                                // Quitar de la selección si ya estaba seleccionado
                                selectedNodes.splice(nodeIndex, 1);
                                network.body.data.nodes.update({
                                    id: nodeId,
                                    shadow: {
                                        enabled: false
                                    }
                                });
                            }
                            
                            network.selectNodes(selectedNodes);

                            // Mostrar/ocultar el menú contextual cuando hay exactamente 2 nodos seleccionados
                            const contextMenu = document.getElementById('contextMenu');
                            if (selectedNodes.length === 2) {
                                contextMenu.style.display = 'block';
                                const options = contextMenu.querySelectorAll('.context-menu-option');
                                options.forEach((option, index) => {
                                    if (index === 0) {
                                        option.classList.add('active');
                                    } else {
                                        option.classList.remove('active');
                                    }
                                });
                            } else {
                                contextMenu.style.display = 'none';
                            }
                        } else {
                            // Click en el fondo
                            selectedNodes = [];
                            network.selectNodes([]);
                            document.getElementById('contextMenu').style.display = 'none';
                        }
                    });

                    // Actualizar el manejo de las opciones del menú
                    document.querySelectorAll('.context-menu-option').forEach(option => {
                        option.addEventListener('click', function() {
                            if (selectedNodes.length === 2) {
                                const relation = this.dataset.relation;
                                const [fromNode, toNode] = selectedNodes;
                                
                                const relationColors = {
                                    'Inversa': '#FF4444',
                                    'Transitiva': '#33CC33',
                                    'Simétrica': '#9933CC',
                                    'Funcional': '#FF8C00',
                                    'Inversamente Funcional': '#00CED1'
                                };

                                const relationColor = relationColors[relation] || '#666666';

                                // Actualizar las sombras de los nodos
                                updateNodeShadows(fromNode, relationColor, network);
                                updateNodeShadows(toNode, relationColor, network);

                                // Añadir la nueva arista
                                graphData.edges.add({
                                    from: fromNode,
                                    to: toNode,
                                    label: relation,
                                    arrows: {
                                        to: {
                                            enabled: true,
                                            type: 'arrow'
                                        }
                                    },
                                    color: {
                                        color: relationColor
                                    },
                                    smooth: {
                                        enabled: true,
                                        type: 'curvedCW',
                                        roundness: 0.2
                                    },
                                    width: 2,
                                    dashes: false,
                                    physics: false,
                                    font: {
                                        size: 12,
                                        color: relationColor,
                                        face: 'arial',
                                        background: 'white',
                                        strokeWidth: 2
                                    }
                                });

                                // Calcular el punto medio entre los dos nodos
                                const fromNodePosition = network.getPosition(fromNode);
                                const toNodePosition = network.getPosition(toNode);
                                const centerPoint = {
                                    x: (fromNodePosition.x + toNodePosition.x) / 2,
                                    y: (fromNodePosition.y + toNodePosition.y) / 2
                                };

                                // Centrar la vista en el punto medio de la nueva relación
                                network.moveTo({
                                    position: centerPoint,
                                    animation: {
                                        duration: 1000,
                                        easingFunction: 'easeInOutQuad'
                                    }
                                });

                                // Actualizar el JSON después de añadir la relación
                                updateOutputFormat();

                                // Limpiar selección después de añadir la relación
                                selectedNodes = [];
                                network.selectNodes([]);
                                document.getElementById('contextMenu').style.display = 'none';

                                // Después de añadir la relación, actualizar el YAML
                                updateYamlWithRelations();
                                
                                // Activar autoguardado
                                triggerAutoSave('nueva relación');
                            }
                        });
                    });

                    // Restaurar la posición de la vista si existía previamente
                    if (viewPosition) {
                        network.moveTo({
                            position: viewPosition.position,
                            scale: viewPosition.scale
                        });
                    }
                    
                    // Guardar referencia a la red para futuras actualizaciones
                    container._network = network;
                    
                    // Limpiar error y mostrar botón
                    errorDiv.classList.remove('show');
                    saveButton.classList.remove('hide');
                    setTimeout(() => {
                        errorDiv.style.display = 'none';
                    }, 300);
                    document.getElementById('yamlInput').classList.remove('error');
                    
                    // Crear el indicador del viewport si no existe
                    let indicator = document.querySelector('.viewport-indicator');
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.className = 'viewport-indicator';
                        document.querySelector('.minimap-container').appendChild(indicator);
                    }

                    // Función updateViewportIndicator mejorada
                    function updateViewportIndicator() {
                        if (!network || !network.body || !minimap) return;

                        try {
                            const mainViewPosition = network.getViewPosition();
                            
                            // Encontrar el nodo más cercano al centro
                            const allNodes = network.body.data.nodes.get();
                            let closestNode = null;
                            let minDistance = Infinity;
                            
                            allNodes.forEach(node => {
                                const nodePos = network.getPosition(node.id);
                                const distance = Math.sqrt(
                                    Math.pow(nodePos.x - mainViewPosition.x, 2) + 
                                    Math.pow(nodePos.y - mainViewPosition.y, 2)
                                );
                                
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestNode = node;
                                }
                            });
                            
                            // Actualizar el nombre del nodo más cercano
                            const centerNodeElement = document.getElementById('centerNode');
                            if (centerNodeElement) {
                                centerNodeElement.textContent = closestNode ? closestNode.label : 'Ninguno';
                            }

                            // Actualizar la posición del indicador en el minimapa con requestAnimationFrame
                            requestAnimationFrame(() => {
                                const minimapPos = minimap.canvasToDOM({
                                    x: mainViewPosition.x,
                                    y: mainViewPosition.y
                                });
                                
                                const indicator = document.querySelector('.viewport-indicator');
                                if (indicator) {
                                    indicator.style.left = `${minimapPos.x}px`;
                                    indicator.style.top = `${minimapPos.y}px`;
                                }
                            });
                        } catch (error) {
                            console.error('Error en updateViewportIndicator:', error);
                        }
                    }

                    // Actualizar los event listeners para un movimiento más suave
                    network.on('dragStart', () => {
                        let animationFrameId;
                        
                        function update() {
                            if (network.dragging) {
                                updateViewportIndicator();
                                animationFrameId = requestAnimationFrame(update);
                            }
                        }
                        
                        animationFrameId = requestAnimationFrame(update);
                        
                        network.once('dragEnd', () => {
                            if (animationFrameId) {
                                cancelAnimationFrame(animationFrameId);
                            }
                        });
                    });

                    // Asegurar que las actualizaciones sean suaves durante el zoom
                    network.on('zoom', () => {
                        requestAnimationFrame(updateViewportIndicator);
                    });

                    // Asegurar que las actualizaciones sean suaves durante la animación
                    network.on('animationFinished', () => {
                        requestAnimationFrame(updateViewportIndicator);
                    });

                    // Actualización inicial
                    network.once('stabilized', () => {
                        updateViewportIndicator();
                    });

                    // Asegurarnos de que el zoom al nodo principal funcione
                    network.once('afterDrawing', () => {
                        setTimeout(() => {
                            const rootNode = nodes[0];
                            if (rootNode) {
                                network.focus(rootNode.id, {
                                    scale: currentZoom,
                                    animation: {
                                        duration: 1000,
                                        easingFunction: 'easeInOutQuad'
                                    }
                                });
                                network.selectNodes([rootNode.id]);
                                currentNodeId = rootNode.id;
                            }
                        }, 500);
                    });

                    // Actualizar también el respaldo de estabilización
                    network.once('stabilizationIterationsDone', () => {
                        const rootNode = nodes[0];
                        if (rootNode) {
                            network.focus(rootNode.id, {
                                scale: currentZoom,
                                animation: {
                                    duration: 1000,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                            network.selectNodes([rootNode.id]);
                            currentNodeId = rootNode.id;
                        }
                    });

                    // Configurar el minimapa
                    const minimapContainer = document.getElementById('minimap');
                    const minimapOptions = {
                        ...options,
                        interaction: {
                            dragNodes: false,
                            dragView: false,
                            zoomView: false,
                            selectable: false,
                            hover: false,
                            keyboard: false,
                            zoomSpeed: 0.1
                        },
                        manipulation: {
                            enabled: false
                        },
                        nodes: {
                            ...options.nodes,
                            size: 10,
                            font: {
                                size: 8
                            }
                        },
                        edges: {
                            ...options.edges,
                            width: 1,
                            font: {
                                size: 0
                            }
                        },
                        physics: {
                            enabled: false
                        }
                    };

                    const minimap = new vis.Network(minimapContainer, {
                        nodes: graphData.nodes,
                        edges: graphData.edges
                    }, minimapOptions);

                    // Asegurar que el minimapa se mantenga estático
                    minimap.once('afterDrawing', () => {
                        minimap.setOptions({ physics: { enabled: false } });
                        updateViewportIndicator();
                    });

                    // Guardar referencias para uso posterior
                    container._network = network;
                    minimapContainer._network = minimap;
                    
                    // Función para detectar solapamiento entre nodos
                    function checkNodeOverlap() {
                        const nodes = network.body.nodes;
                        const nodePositions = {};
                        const overlappingPairs = [];

                        // Obtener posiciones y dimensiones de todos los nodos
                        Object.values(nodes).forEach(node => {
                            const position = network.getPosition(node.id);
                            const boundingBox = node.shape.boundingBox;
                            nodePositions[node.id] = {
                                x: position.x,
                                y: position.y,
                                width: boundingBox.right - boundingBox.left,
                                height: boundingBox.bottom - boundingBox.top
                            };
                        });

                        // Comprobar solapamientos
                        Object.entries(nodePositions).forEach(([id1, pos1]) => {
                            Object.entries(nodePositions).forEach(([id2, pos2]) => {
                                if (id1 < id2) { // Evitar comparaciones duplicadas
                                    if (isOverlapping(pos1, pos2)) {
                                        overlappingPairs.push([id1, id2]);
                                        
                                        // Resaltar nodos solapados
                                        network.body.data.nodes.update([
                                            {
                                                id: id1,
                                                color: {
                                                    background: '#ffcccb',
                                                    border: '#ff0000'
                                                }
                                            },
                                            {
                                                id: id2,
                                                color: {
                                                    background: '#ffcccb',
                                                    border: '#ff0000'
                                                }
                                            }
                                        ]);
                                    }
                                }
                            });
                        });

                        return overlappingPairs;
                    }

                    // Función auxiliar para detectar si dos nodos se solapan
                    function isOverlapping(pos1, pos2) {
                        const horizontalOverlap = Math.abs(pos1.x - pos2.x) < (pos1.width + pos2.width) / 2;
                        const verticalOverlap = Math.abs(pos1.y - pos2.y) < (pos1.height + pos2.height) / 2;
                        return horizontalOverlap && verticalOverlap;
                    }

                    // Añadir evento para detectar solapamientos después de mover nodos
                    network.on('dragEnd', function(params) {
                        if (params.nodes && params.nodes.length > 0) {
                            const overlappingPairs = checkNodeOverlap();
                            if (overlappingPairs.length > 0) {
                                console.log('Nodos solapados:', overlappingPairs);
                            }
                        }
                    });

                    // Comprobar solapamientos después de que el grafo se estabilice
                    network.once('stabilizationIterationsDone', function() {
                        const overlappingPairs = checkNodeOverlap();
                        if (overlappingPairs.length > 0) {
                            console.log('Nodos solapados inicialmente:', overlappingPairs);
                        }
                    });
                    
                    // Función para centrar en el nodo raíz
                    function centerOnRootNode() {
                        const allNodes = network.body.data.nodes.get();
                        if (allNodes.length > 0) {
                            const rootNode = allNodes[0];
                            const position = network.getPosition(rootNode.id);
                            
                            network.moveTo({
                                position: position,
                                scale: currentZoom,
                                animation: {
                                    duration: 1000,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                            
                            // Actualizar el nodo central
                            const centerNodeElement = document.getElementById('centerNode');
                            if (centerNodeElement) {
                                centerNodeElement.textContent = rootNode.label;
                            }
                        }
                    }

                    // Centrar en el nodo raíz después de la estabilización
                    network.once("stabilizationIterationsDone", function() {
                        centerOnRootNode();
                        updateCenterMarker();
                    });

                    // Resto de eventos existentes...
                    network.on("afterDrawing", function() {
                        // ... existing afterDrawing code ...
                    });

                    // Modificar el evento click para mantener la escala actual
                    network.on("click", function(params) {
                        if (params.nodes.length > 0) {
                            const nodeId = params.nodes[0];
                            const position = network.getPosition(nodeId);
                            const currentScale = network.getScale();
                            
                            network.moveTo({
                                position: position,
                                scale: currentScale,
                                animation: {
                                    duration: 500,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                        }
                    });

                    // Actualizar el manejador de selección para mostrar información en el panel
                    network.on("select", function(params) {
                        const selectedEdges = params.edges;
                        const content = document.querySelector('.relation-info-content');
                        
                        // Remover animaciones previas
                        network.body.data.edges.forEach(edge => {
                            network.body.data.edges.update({
                                id: edge.id,
                                shadow: false,
                                width: 1
                            });
                        });
                        
                        if (selectedEdges.length > 0) {
                            const edgeData = network.body.data.edges.get(selectedEdges);
                            content.innerHTML = edgeData.map(edge => {
                                const fromNode = network.body.data.nodes.get(edge.from);
                                const toNode = network.body.data.nodes.get(edge.to);
                                
                                network.body.data.edges.update({
                                    id: edge.id,
                                    shadow: {
                                        enabled: true,
                                        color: 'rgba(46, 204, 113, 0.6)',
                                        size: 15,
                                        x: 0,
                                        y: 0
                                    },
                                    width: 4,
                                    animation: {
                                        enabled: true,
                                        duration: 2000,
                                        easingFunction: 'easeInOutQuad'
                                    }
                                });

                                return `
                                    <div class="relation-item">
                                        <span>${fromNode.label} → ${edge.label} → ${toNode.label}</span>
                                        <span class="delete-relation" data-edge-id="${edge.id}">×</span>
                                    </div>
                                `;
                            }).join('');

                            // Actualizar manejadores para eliminar relaciones
                            content.querySelectorAll('.delete-relation').forEach(btn => {
                                btn.onclick = function() {
                                    const edgeId = this.dataset.edgeId;
                                    if (confirm('¿Deseas eliminar esta relación?')) {
                                        // Obtener los nodos conectados por esta arista antes de eliminarla
                                        const edge = network.body.data.edges.get(edgeId);
                                        const fromNode = edge.from;
                                        const toNode = edge.to;
                                        
                                        // Eliminar la arista
                                        network.body.data.edges.remove(edgeId);
                                        
                                        // Limpiar las sombras de los nodos conectados
                                        network.body.data.nodes.update([
                                            { id: fromNode, shadow: false },
                                            { id: toNode, shadow: false }
                                        ]);
                                        
                                        // Actualizar la selección después de eliminar
                                        const remainingEdges = selectedEdges.filter(id => id !== edgeId);
                                        network.setSelection({ edges: remainingEdges });
                                        
                                        // Actualizar el panel de relaciones seleccionadas
                                        const relationContent = document.querySelector('.relation-info-content');
                                        if (remainingEdges.length === 0) {
                                            relationContent.innerHTML = '<div style="padding: 8px;">No hay relaciones seleccionadas</div>';
                                        } else {
                                            // Actualizar el panel solo con las relaciones restantes
                                            const remainingEdgeData = network.body.data.edges.get(remainingEdges);
                                            relationContent.innerHTML = remainingEdgeData.map(edge => {
                                                const fromNode = network.body.data.nodes.get(edge.from);
                                                const toNode = network.body.data.nodes.get(edge.to);
                                                return `
                                                    <div class="relation-item">
                                                        <span>${fromNode.label} → ${edge.label} → ${toNode.label}</span>
                                                        <span class="delete-relation" data-edge-id="${edge.id}">×</span>
                                                    </div>
                                                `;
                                            }).join('');
                                            
                                            // Reenlazar los eventos de eliminación para las relaciones restantes
                                            relationContent.querySelectorAll('.delete-relation').forEach(newBtn => {
                                                newBtn.onclick = btn.onclick;
                                            });
                                        }
                                        
                                        // Actualizar inmediatamente el formato de salida
                                        updateOutputFormat();
                                        
                                        // Obtener las relaciones personalizadas actuales
                                        const currentEdges = network.body.data.edges.get();
                                        const currentCustomRelations = currentEdges
                                            .filter(e => e.label && [
                                                'Inversa', 'Transitiva', 'Simétrica', 'Funcional', 
                                                'Inversamente Funcional'
                                            ].includes(e.label))
                                            .map(e => ({
                                                type: e.label,
                                                from: e.from,
                                                to: e.to
                                            }));
                                        
                                        // Forzar la actualización del YAML en el textarea
                                        const currentJson = yamlToJson(document.getElementById('yamlInput').value);
                                        delete currentJson.relationships;
                                        if (currentCustomRelations.length > 0) {
                                            currentJson.relationships = currentCustomRelations;
                                        }
                                        document.getElementById('yamlInput').value = jsonToYaml(currentJson);

                                        // Después de eliminar la relación, actualizar el YAML
                                        updateYamlWithRelations();
                                        
                                        // Activar autoguardado
                                        triggerAutoSave('eliminación de relación');
                                    }
                                };
                            });
                        } else {
                            content.innerHTML = '<div style="padding: 8px;">No hay relaciones seleccionadas</div>';
                        }
                    });

                    // Actualizar el manejador de tecla Delete
                    document.addEventListener('keydown', function(e) {
                        if (e.key === 'Delete' || e.key === 'Backspace') {
                            const selectedEdges = network.getSelectedEdges();
                            if (selectedEdges.length > 0) {
                                if (confirm('¿Deseas eliminar las relaciones seleccionadas?')) {
                                    // Obtener todos los nodos afectados antes de eliminar las aristas
                                    const affectedNodes = new Set();
                                    selectedEdges.forEach(edgeId => {
                                        const edge = network.body.data.edges.get(edgeId);
                                        affectedNodes.add(edge.from);
                                        affectedNodes.add(edge.to);
                                    });
                                    
                                    // Eliminar las aristas
                                    network.body.data.edges.remove(selectedEdges);
                                    
                                    // Limpiar las sombras de todos los nodos afectados
                                    Array.from(affectedNodes).forEach(nodeId => {
                                        network.body.data.nodes.update({
                                            id: nodeId,
                                            shadow: false
                                        });
                                    });
                                    
                                    // Limpiar la selección después de eliminar
                                    network.setSelection({ edges: [] });
                                    updateOutputFormat();

                                    // Activar autoguardado después de eliminar relaciones
                                    triggerAutoSave('eliminación de relaciones');
                                }
                            }
                        }
                    });

                    // Actualizar el manejador de selección
                    network.on("click", function(params) {
                        // Si no se hizo clic en ningún nodo ni arista, limpiar la selección
                        if (params.nodes.length === 0 && params.edges.length === 0) {
                            network.unselectAll();
                            
                            // Limpiar los efectos visuales de todas las aristas
                            network.body.data.edges.forEach(edge => {
                                network.body.data.edges.update({
                                    id: edge.id,
                                    shadow: false,
                                    width: 1
                                });
                            });
                            
                            // Limpiar el panel de relaciones
                            const content = document.querySelector('.relation-info-content');
                            if (content) {
                                content.innerHTML = '<div style="padding: 8px;">No hay relaciones seleccionadas</div>';
                            }
                        }
                    });

                }
            } catch (error) {
                console.error('Error:', error);
                const errorDiv = document.getElementById('yamlError');
                const saveButton = document.getElementById('saveButton');
                
                errorDiv.style.display = 'block';
                saveButton.classList.add('hide');
                
                errorDiv.innerHTML = formatYamlError(error);
                errorDiv.classList.add('show');
                document.getElementById('yamlInput').classList.add('error');
            }
        }

        // Event listener para Tab y Ctrl+Enter
        document.getElementById('yamlInput').addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                const value = this.value;
                
                if (start !== end) {
                    const beforeSelection = value.substring(0, start);
                    const selection = value.substring(start, end);
                    const afterSelection = value.substring(end);
                    
                    const indentedText = selection
                        .split('\n')
                        .map(line => '  ' + line)
                        .join('\n');
                    
                    this.value = beforeSelection + indentedText + afterSelection;
                    this.selectionStart = start;
                    this.selectionEnd = start + indentedText.length;
                } else {
                    this.value = value.substring(0, start) + '  ' + value.substring(end);
                    this.selectionStart = this.selectionEnd = start + 2;
                }
            }
            
            if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault();
                visualizeGraph();
            }
        });

        function processHierarchy(data, container, level = 0) {
            const ul = document.createElement('ul');
            ul.className = 'json-hierarchy';
            ul.style.paddingLeft = level > 0 ? '20px' : '0';

            Object.entries(data).forEach(([key, value]) => {
                if (key === 'id') return;

                const li = document.createElement('li');
                const nodeItem = document.createElement('div');
                nodeItem.className = 'node-item';

                const keySpan = document.createElement('span');
                keySpan.className = 'key';
                keySpan.textContent = key;

                nodeItem.appendChild(keySpan);

                if (typeof value === 'object' && value !== null) {
                    nodeItem.classList.add('has-children');
                    
                    nodeItem.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const parentLi = this.parentElement;
                        parentLi.classList.toggle('expanded');
                        this.classList.toggle('expanded');
                    });

                    li.appendChild(nodeItem);
                    processHierarchy(value, li, level + 1);
                } else {
                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'value';
                    valueSpan.textContent = value === null ? 
                        ': ¡Has llegado al final de la rama!' : 
                        `: ${value}`;
                    nodeItem.appendChild(valueSpan);
                    li.appendChild(nodeItem);
                }

                ul.appendChild(li);
            });

            container.appendChild(ul);
        }

        async function loadJsonContent(filename) {
            try {
                const response = await fetch(`/get-json-content/${filename}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const jsonData = await response.json();
                
                // Filtrar los IDs antes de mostrar
                const filteredData = filterIds(jsonData);
                
                // Convertir el JSON filtrado a YAML y mostrarlo en el textarea
                const yamlText = jsyaml.dump(filteredData);
                document.getElementById('yamlInput').value = yamlText;
                
                // Mostrar el JSON filtrado
                document.getElementById('jsonOutput').innerHTML = 
                    `<pre>${JSON.stringify(filteredData, null, 2)}</pre>`;
                
                // Visualizar el grafo con los datos filtrados
                visualizeGraph();
                
            } catch (error) {
                console.error('Error loading JSON:', error);
                alert('Error al cargar el archivo JSON: ' + error.message);
            }
        }

        function convertToGraph(data, parentId = null, level = 0) {
            let nodes = [];
            let edges = [];
            let counter = 0;
            let nodeConnections = new Map();
            
            function processItem(key, value, parentId, currentLevel) {
                if (key === 'id' || key === 'relationships') return; // Ignorar relationships en el procesamiento normal
                
                counter++;
                const nodeId = parentId ? 
                    (key === 'value' ? `${parentId}_definiciones_${counter}` : `${parentId}_${key}_${counter}`) : 
                    (key === 'value' ? `definiciones_${counter}` : `${key}_${counter}`);
                
                // Inicializar contador de conexiones para el nodo padre
                if (parentId && !nodeConnections.has(parentId)) {
                    nodeConnections.set(parentId, 0);
                }
                
                // Incrementar contador de conexiones del padre
                if (parentId) {
                    nodeConnections.set(parentId, nodeConnections.get(parentId) + 1);
                }
                
                // Determinar si el nodo debe estar oculto inicialmente
                const isHidden = parentId && nodeConnections.get(parentId) > 4;

                if (typeof value === 'object' && value !== null) {
                    delete value['id'];
                }

                const hasOverlap = checkLevelOverlap(currentLevel);
                const nodeLabel = key === 'value' ? 'definiciones' : truncateLabel(String(key), hasOverlap);

                nodes.push({
                    id: nodeId,
                    label: nodeLabel,
                    shape: 'box',
                    level: currentLevel,
                    hidden: isHidden,
                    color: key === 'value' ? {
                        background: '#E8E8E8',
                        border: '#A9A9A9'
                    } : undefined,
                    title: key === 'value' ? 'definiciones' : String(key)
                });
                
                if (parentId) {
                    edges.push({
                        id: `${parentId}-${nodeId}`,
                        from: parentId,
                        to: nodeId,
                        label: '',
                        hidden: isHidden
                    });
                }
                
                if (typeof value === 'object' && value !== null) {
                    Object.entries(value).forEach(([k, v]) => {
                        if (!k.startsWith('@') && k !== 'id') {
                            processItem(k, v, nodeId, currentLevel + 1);
                        }
                    });
                } else if (value !== undefined && value !== null && !String(key).startsWith('@') && key !== 'id') {
                    const valueId = `${nodeId}_definiciones_${counter}`;
                    // Truncar el valor también solo si hay solapamiento
                    const truncatedValue = truncateLabel(String(value), hasOverlap);
                    
                    nodes.push({
                        id: valueId,
                        label: truncatedValue,
                        shape: 'box',
                        level: currentLevel + 1,
                        hidden: isHidden,
                        color: {
                            background: '#E8E8E8',
                            border: '#A9A9A9'
                        },
                        title: String(value) // Tooltip con el texto completo
                    });
                    edges.push({
                        id: `${nodeId}-${valueId}`,
                        from: nodeId,
                        to: valueId,
                        label: '',
                        hidden: isHidden
                    });
                }
            }
            
            // Procesar la estructura principal
            Object.entries(data).forEach(([key, value]) => {
                if (!key.startsWith('@') && key !== 'id' && key !== 'relationships') {
                    processItem(key, value, parentId, level);
                }
            });
            
            // Procesar las relaciones si existen
            if (data.relationships && Array.isArray(data.relationships)) {
                data.relationships.forEach(relation => {
                    edges.push({
                        from: relation.from,
                        to: relation.to,
                        label: relation.type,
                        arrows: {
                            to: {
                                enabled: true,
                                type: 'arrow'
                            }
                        },
                        color: {
                            color: getRelationColor(relation.type)
                        },
                        smooth: {
                            enabled: true,
                            type: 'curvedCW',
                            roundness: 0.2
                        },
                        width: 2,
                        dashes: false,
                        physics: false,
                        font: {
                            size: 12,
                            color: getRelationColor(relation.type),
                            face: 'arial',
                            background: 'white',
                            strokeWidth: 2
                        }
                    });
                });
            }
            
            return { nodes, edges };
        }

        // Añadir función auxiliar para obtener el color de cada tipo de relación
        function getRelationColor(relationType) {
            const relationColors = {
                'Inversa': '#FF4444',
                'Transitiva': '#33CC33',
                'Simétrica': '#9933CC',
                'Funcional': '#FF8C00',
                'Inversamente Funcional': '#00CED1'
            };
            return relationColors[relationType] || '#666666';
        }

        // Añadir función para convertir entre JSON y YAML
        function jsonToYaml(jsonData) {
            try {
                // Función para limpiar IDs antes de convertir a YAML
                function cleanObject(obj) {
                    if (!obj || typeof obj !== 'object') return obj;
                    
                    if (Array.isArray(obj)) {
                        return obj.map(item => cleanObject(item));
                    }
                    
                    const newObj = {};
                    for (const [key, value] of Object.entries(obj)) {
                        if (key !== 'id') {
                            newObj[key] = cleanObject(value);
                        }
                    }
                    return newObj;
                }

                const cleanData = cleanObject(jsonData);
                return jsyaml.dump(cleanData);
            } catch (error) {
                console.error('Error converting JSON to YAML:', error);
                return '';
            }
        }

        function yamlToJson(yamlData) {
            try {
                const jsonData = jsyaml.load(yamlData);
                return jsonData;
            } catch (error) {
                console.error('Error converting YAML to JSON:', error);
                return null;
            }
        }

        // Modificar saveTaxonomy para manejar YAML
        async function saveTaxonomy() {
            try {
                // Guardar la posición y zoom actuales
                const currentPosition = network?.getViewPosition() || null;
                const currentScale = network?.getScale() || null;

                const yamlContent = document.getElementById('yamlInput').value;
                const filename = document.getElementById('filename').textContent;
                
                // Corregir la URL para incluir el filename
                const response = await fetch(`/save-taxonomy/${filename}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(yamlToJson(yamlContent))
                });

                if (!response.ok) {
                    throw new Error('Error al guardar la taxonomía');
                }

                // Restaurar la posición y zoom después de guardar
                if (network && currentPosition && currentScale) {
                    network.moveTo({
                        position: currentPosition,
                        scale: currentScale,
                        animation: false
                    });
                }

                return await response.json();
            } catch (error) {
                console.error('Error:', error);
                throw error;
            }
        }

        // Función para validar que la taxonomía sigue el formato JSON-LD
        function validateJsonLd(jsonLd) {
            const requiredProperties = ['@context', '@type', '@id', 'prefLabel'];
            for (const prop of requiredProperties) {
                if (!(prop in jsonLd)) {
                    throw new Error(`Falta la propiedad requerida: ${prop}`);
                }
            }
            return true;
        }

        // Modificar la función que muestra el menú contextual
        function showContextMenu(x, y) {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'block';
            
            // Asegurarnos de que la primera opción esté seleccionada visualmente
            const options = contextMenu.querySelectorAll('.context-menu-option');
            options.forEach((option, index) => {
                if (index === 0) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });
        }

        // Modificar la función de actualización de sombras para recibir network como parámetro
        function updateNodeShadows(nodeId, relationColor, network, add = true) {
            if (!nodeShadows.has(nodeId)) {
                nodeShadows.set(nodeId, new Set());
            }
            
            const nodeShadowSet = nodeShadows.get(nodeId);
            if (add) {
                nodeShadowSet.add(relationColor);
            } else {
                nodeShadowSet.delete(relationColor);
            }

            // Crear efecto de sombras múltiples
            if (nodeShadowSet.size > 0) {
                const shadowsArray = Array.from(nodeShadowSet);
                const multipleShadows = shadowsArray.map((color, index) => ({
                    enabled: true,
                    color: color,
                    size: 10,
                    x: index * 3,
                    y: 5 + (index * 3)
                }));

                network.body.data.nodes.update({
                    id: nodeId,
                    shadow: multipleShadows[0],
                    shadowMultiple: multipleShadows
                });
            } else {
                network.body.data.nodes.update({
                    id: nodeId,
                    shadow: {
                        enabled: false
                    },
                    shadowMultiple: []
                });
            }
        }

        // Definir la función antes de los event listeners
        function highlightNodeFromYamlLine(lineNumber, yaml) {
            const network = document.getElementById('mynetwork')._network;
            if (!network) return;

            // Limpiar resaltados anteriores
            const nodes = network.body.data.nodes.get();
            nodes.forEach(node => {
                network.body.data.nodes.update({
                    id: node.id,
                    shadow: {
                        enabled: false
                    }
                });
            });

            // Obtener la línea actual y su nivel de indentación
            const lines = yaml.split('\n');
            const currentLine = lines[lineNumber - 1];
            if (!currentLine) return;

            const indentation = currentLine.search(/\S/);
            const key = currentLine.trim().split(':')[0];

            // Buscar el nodo correspondiente
            const node = nodes.find(n => n.label === key);

            if (node) {
                // Aplicar efecto de resaltado
                network.body.data.nodes.update({
                    id: node.id,
                    shadow: {
                        enabled: true,
                        color: '#2ecc71',
                        size: 15,
                        x: 0,
                        y: 0
                    }
                });

                // Centrar la vista en el nodo
                network.focus(node.id, {
                    scale: network.getScale(),
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            }
        }

        // Ahora añadir los event listeners
        document.getElementById('yamlInput').addEventListener('keyup', function(e) {
            const cursorPosition = this.selectionStart;
            const yaml = this.value;
            const lines = yaml.substring(0, cursorPosition).split('\n');
            const currentLine = lines.length;
            highlightNodeFromYamlLine(currentLine, yaml);
        });

        document.getElementById('yamlInput').addEventListener('click', function(e) {
            const cursorPosition = this.selectionStart;
            const yaml = this.value;
            const lines = yaml.substring(0, cursorPosition).split('\n');
            const currentLine = lines.length;
            highlightNodeFromYamlLine(currentLine, yaml);
        });

        document.getElementById('yamlInput').addEventListener('select', function(e) {
            const cursorPosition = this.selectionStart;
            const yaml = this.value;
            const lines = yaml.substring(0, cursorPosition).split('\n');
            const currentLine = lines.length;
            highlightNodeFromYamlLine(currentLine, yaml);
        });

        // Añadir función para mostrar/ocultar nodos hijos
        function toggleChildNodes(nodeId, network) {
            const positions = network.getPositions(); // Se crea pero no se usa después
            const connectedEdges = network.getConnectedEdges(nodeId);
            const childNodes = new Set();
            
            // Encontrar todos los nodos hijos directos
            connectedEdges.forEach(edgeId => {
                const edge = network.body.data.edges.get(edgeId);
                if (edge.from === nodeId) {
                    childNodes.add(edge.to);
                }
            });
            
            // Contar nodos hijos visibles
            const visibleChildren = Array.from(childNodes).filter(childId => 
                !network.body.data.nodes.get(childId).hidden
            );
            
            // Si hay nodos visibles, ocultarlos todos
            // Si no hay nodos visibles, mostrar solo los primeros 4
            const shouldShow = visibleChildren.length === 0;
            let counter = 0;
            
            // Desactivar física temporalmente
            const physics = network.physics.options.enabled;
            network.setOptions({ physics: { enabled: false } });
            
            childNodes.forEach(childId => {
                const shouldHide = shouldShow ? counter >= 4 : true;
                counter++;
                
                // Mantener la posición original del nodo
                const position = positions[childId];
                
                network.body.data.nodes.update({
                    id: childId,
                    hidden: shouldHide,
                    x: position ? position.x : undefined,
                    y: position ? position.y : undefined,
                    physics: false // Desactivar física para este nodo
                });
                
                // También actualizar la visibilidad de las aristas
                const edge = network.body.data.edges.get(`${nodeId}-${childId}`);
                if (edge) {
                    network.body.data.edges.update({
                        id: edge.id,
                        hidden: shouldHide
                    });
                }
            });
            
            // Restaurar la física después de un breve retraso
            setTimeout(() => {
                network.setOptions({ physics: { enabled: physics } });
            }, 500);
        }

        // Definir la función updateOutputFormat fuera de cualquier otro contexto
        function updateOutputFormat() {
            const formatSelector = document.getElementById('formatSelector');
            const selectedFormat = formatSelector.value;
            const jsonOutput = document.getElementById('jsonOutput');
            const yamlInput = document.getElementById('yamlInput').value;
            
            try {
                const jsonData = jsyaml.load(yamlInput);
                const network = document.getElementById('mynetwork')._network;
                const edges = network.body.data.edges.get();
                
                // Obtener la clave principal (primera clave del objeto JSON)
                const mainKey = Object.keys(jsonData)[0] || "Untitled Taxonomy";
                
                // Obtener las relaciones personalizadas una sola vez
                const customRelations = edges.filter(edge => edge.label && [
                    'Inversa', 'Transitiva', 'Simétrica', 'Funcional', 
                    'Inversamente Funcional'
                ].includes(edge.label));
                
                switch(selectedFormat) {
                    case 'json':
                        // Create a deep copy of the JSON data
                        const enhancedJson = JSON.parse(JSON.stringify(jsonData));
                        
                        // Add relationships section if there are custom relationships
                        if (customRelations.length > 0) {
                            enhancedJson['relationships'] = customRelations.map(edge => ({
                                type: edge.label,
                                from: edge.from,
                                to: edge.to
                            }));
                        }
                        
                        jsonOutput.innerHTML = `<pre>${JSON.stringify(enhancedJson, null, 2)}</pre>`;
                        break;
                        
                    case 'jsonld':
                        // Convertir la estructura a JSON-LD
                        const jsonLdData = {
                            "@context": {
                                "@vocab": "http://www.w3.org/2004/02/skos/core#",
                                "skos": "http://www.w3.org/2004/02/skos/core#",
                                "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
                                "dct": "http://purl.org/dc/terms/",
                                "owl": "http://www.w3.org/2002/07/owl#",
                                "hasTopConcept": "skos:hasTopConcept",
                                "broader": "skos:broader",
                                "narrower": "skos:narrower",
                                "prefLabel": "skos:prefLabel",
                                "inverseOf": "owl:inverseOf",
                                "transitiveProperty": "owl:TransitiveProperty",
                                "symmetricProperty": "owl:SymmetricProperty",
                                "functionalProperty": "owl:FunctionalProperty",
                                "inverseFunctionalProperty": "owl:InverseFunctionalProperty"
                            },
                            "@type": "skos:ConceptScheme",
                            "@id": jsonData.id || "_:taxonomy",
                            "dct:title": mainKey,
                            "hasTopConcept": []
                        };
                        
                        // Usar customRelations que ya fue declarada arriba
                        // ... resto del código jsonld ...
                        jsonOutput.innerHTML = `<pre>${JSON.stringify(jsonLdData, null, 2)}</pre>`;
                        break;
                        
                    case 'rdf':
                        let rdfXml = `<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF xmlns="http://www.example.org/ontology#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:owl="http://www.w3.org/2002/07/owl#"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema#">

    <owl:Ontology rdf:about="${jsonData.id || '_:taxonomy'}">
        <rdfs:label>${mainKey || "Untitled Taxonomy"}</rdfs:label>
        <owl:versionInfo>1.0</owl:versionInfo>
    </owl:Ontology>`;

                        // Añadir clases y propiedades base
                        rdfXml += `
    <!-- Clases base -->
    <owl:Class rdf:about="#Descriptor">
        <rdfs:label>Descriptor</rdfs:label>
    </owl:Class>

    <!-- Propiedades base -->
    <owl:ObjectProperty rdf:about="#hasProperty">
        <rdfs:label>tiene propiedad</rdfs:label>
        <rdfs:domain rdf:resource="#Thing"/>
        <rdfs:range rdf:resource="#Descriptor"/>
    </owl:ObjectProperty>`;

                        // Convertir la taxonomía
                        if (mainKey && jsonData[mainKey]) {
                            rdfXml += convertToRdfXml({[mainKey]: jsonData[mainKey]});
                        }

                        rdfXml += '\n</rdf:RDF>';

                        jsonOutput.innerHTML = `<pre>${rdfXml}</pre>`;
                        
                        // Añadir botón para guardar RDF si no existe
                        if (!document.getElementById('saveRdfButton')) {
                            const saveButton = document.createElement('button');
                            saveButton.id = 'saveRdfButton';
                            saveButton.textContent = 'Guardar RDF';
                            saveButton.onclick = saveRdfFile;
                            saveButton.style.marginTop = '10px';
                            jsonOutput.appendChild(saveButton);
                        }
                        break;
                }
            } catch (error) {
                console.error('Error:', error);
                jsonOutput.innerHTML = `<pre class="error">Error: ${error.message}</pre>`;
            }
        }

        async function saveRdfFile() {
            try {
                // Obtener el JSON actual
                const yamlInput = document.getElementById('yamlInput').value;
                const jsonData = jsyaml.load(yamlInput);
                
                const urlParts = window.location.pathname.split('/');
                const filename = decodeURIComponent(urlParts[urlParts.length - 1]);
                
                console.log("Enviando JSON para conversión:", jsonData); // Debug
                
                const response = await fetch(`/save-rdf/${filename}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        json: jsonData // Enviamos el JSON en lugar del RDF
                    })
                });
                
                const result = await response.json();
                
                if (!response.ok) {
                    throw new Error(result.detail || 'Error desconocido al guardar el archivo RDF');
                }
                
                console.log("Respuesta del servidor:", result);
                alert('Archivo OWL guardado correctamente');
                
            } catch (error) {
                console.error('Error completo:', error);
                alert('Error al guardar el archivo OWL: ' + error.message);
            }
        }

        function convertToRdfXml(obj, parentId = null, indent = '    ') {
            let xml = '';
            
            if (!obj || typeof obj !== 'object') {
                return xml;
            }

            // Obtener las relaciones del grafo
            const network = document.getElementById('mynetwork')._network;
            const edges = network.body.data.edges.get();

            Object.entries(obj).forEach(([key, value]) => {
                if (key === 'id') return;
                
                const conceptId = (value && value.id) || `_:concept_${Math.random().toString(36).substr(2, 9)}`;
                
                xml += `\n${indent}<owl:Class rdf:about="${conceptId}">
${indent}    <rdfs:label xml:lang="es">${key}</rdfs:label>`;

                // Añadir owl:equivalentClass si hay restricciones
                const restrictions = edges.filter(edge => edge.from === conceptId && edge.label);
                if (restrictions.length > 0) {
                    xml += `\n${indent}    <owl:equivalentClass>
${indent}        <owl:Class>
${indent}            <owl:intersectionOf rdf:parseType="Collection">
${indent}                <rdf:Description rdf:about="${parentId || conceptId}"/>`;

                    restrictions.forEach(restriction => {
                        xml += `\n${indent}                <owl:Restriction>
${indent}                    <owl:onProperty rdf:resource="#${restriction.label}"/>`;

                        if (restriction.type === 'hasValue') {
                            xml += `\n${indent}                    <owl:hasValue rdf:resource="#${restriction.to}"/>`;
                        } else if (restriction.type === 'someValuesFrom') {
                            xml += `\n${indent}                    <owl:someValuesFrom rdf:resource="#${restriction.to}"/>`;
                        } else if (restriction.type === 'allValuesFrom') {
                            xml += `\n${indent}                    <owl:allValuesFrom>
${indent}                        <owl:Class>
${indent}                            <owl:oneOf rdf:parseType="Collection">
${indent}                                <rdf:Description rdf:about="#${restriction.to}"/>
${indent}                            </owl:oneOf>
${indent}                        </owl:Class>
${indent}                    </owl:allValuesFrom>`;
                        }

                        xml += `\n${indent}                </owl:Restriction>`;
                    });

                    xml += `\n${indent}            </owl:intersectionOf>
${indent}        </owl:Class>
${indent}    </owl:equivalentClass>`;
                }

                // Añadir rdfs:subClassOf para la jerarquía
                if (parentId) {
                    xml += `\n${indent}    <rdfs:subClassOf rdf:resource="${parentId}"/>`;
                }

                // Procesar propiedades específicas del dominio
                if (value.properties) {
                    Object.entries(value.properties).forEach(([propName, propValue]) => {
                        xml += `\n${indent}    <rdfs:subClassOf>
${indent}        <owl:Restriction>
${indent}            <owl:onProperty rdf:resource="#${propName}"/>
${indent}            <owl:hasValue rdf:resource="#${propValue}"/>
${indent}        </owl:Restriction>
${indent}    </rdfs:subClassOf>`;
                    });
                }

                // Procesar nodos hijos recursivamente
                if (value.value !== null) {
                    Object.entries(value)
                        .filter(([k, v]) => k !== 'id' && k !== 'properties' && v && typeof v === 'object')
                        .forEach(([childKey, childValue]) => {
                            xml += convertToRdfXml({[childKey]: childValue}, conceptId, indent + '    ');
                        });
                }

                xml += `\n${indent}</owl:Class>`;
            });

            return xml;
        }

        // Función para cargar las propiedades
        async function loadProperties() {
            try {
                const response = await fetch('/api/properties');
                const properties = await response.json();
                
                const container = document.getElementById('propertiesContainer');
                const hierarchyContainer = document.createElement('div');
                hierarchyContainer.className = 'hierarchy-container';
                
                const hierarchyData = buildHierarchyFromProperties(properties);
                processHierarchy(hierarchyData, hierarchyContainer);
                
                container.innerHTML = '';
                container.appendChild(hierarchyContainer);
                
                // Expandir el primer nivel por defecto
                const firstLevelItems = hierarchyContainer.querySelectorAll(':scope > ul > li');
                firstLevelItems.forEach(item => {
                    item.classList.add('expanded');
                    item.querySelector('.node-item')?.classList.add('expanded');
                });
            } catch (error) {
                console.error('Error loading properties:', error);
            }
        }

        // Función auxiliar para construir la jerarquía (igual que en index.html)
        function buildHierarchyFromProperties(properties) {
            const hierarchy = {};
            const rootProperties = properties.filter(p => !p.parent);
            
            function addChildren(parent) {
                const children = properties.filter(p => p.parent === parent.id);
                const result = {};
                
                children.forEach(child => {
                    if (child.type === "string") {
                        result[child.name] = null;
                    } else {
                        result[child.name] = addChildren(child);
                    }
                });
                
                return result;
            }
            
            rootProperties.forEach(root => {
                hierarchy[root.name] = addChildren(root);
            });
            
            return hierarchy;
        }

        // Añadir funcionalidad para minimizar/maximizar el panel
        document.querySelector('.minimize-btn').addEventListener('click', function() {
            const panel = document.querySelector('.properties-panel');
            panel.classList.toggle('minimized');
            this.textContent = panel.classList.contains('minimized') ? '+' : '−';
        });

        // Cargar las propiedades cuando se carga la página
        document.addEventListener('DOMContentLoaded', loadProperties);

        // Añadir event listener para cuando el foco sale del textarea
        document.getElementById('yamlInput').addEventListener('blur', function() {
            const network = document.getElementById('mynetwork')._network;
            if (!network) return;

            // Limpiar resaltados de todos los nodos
            const nodes = network.body.data.nodes.get();
            nodes.forEach(node => {
                network.body.data.nodes.update({
                    id: node.id,
                    shadow: {
                        enabled: false
                    }
                });
            });
        });

        // Añadir función para verificar solapamiento en un nivel
        function checkLevelOverlap(level) {
            const nodesInLevel = [];
            const network = document.getElementById('mynetwork')._network;
            
            if (!network) return false;
            
            // Obtener todos los nodos en el nivel actual
            network.body.data.nodes.get().forEach(node => {
                if (node.level === level) {
                    nodesInLevel.push(node);
                }
            });
            
            // Si hay más de 5 nodos en el mismo nivel, consideramos que hay solapamiento
            return nodesInLevel.length > 5;
        }

        // Función auxiliar para truncar etiquetas largas
        function truncateLabel(label, hasOverlap) {
            const maxLength = hasOverlap ? NODE_LABEL_MAX_LENGTH : NODE_LABEL_MAX_LENGTH * 2;
            if (label.length > maxLength) {
                return label.substring(0, maxLength - 3) + '...';
            }
            return label;
        }

        // Función para manejar las sombras de los nodos
        function updateNodeShadows(nodeId, color, network) {
            // Verificar que la red y sus componentes estén inicializados
            if (!network || !network.body || !network.body.data || !network.body.data.nodes) {
                console.warn('Red no inicializada completamente al intentar actualizar sombras');
                return;
            }

            try {
                // Obtener el nodo
                const node = network.body.data.nodes.get(nodeId);
                if (!node) {
                    console.warn(`Nodo ${nodeId} no encontrado`);
                    return;
                }

                // Actualizar la sombra del nodo
                network.body.data.nodes.update({
                    id: nodeId,
                    shadow: {
                        enabled: true,
                        color: color + '80', // Añadir transparencia (50%)
                        size: 10,
                        x: 0,
                        y: 5
                    }
                });

                // Guardar la sombra en el mapa de sombras
                if (!nodeShadows.has(nodeId)) {
                    nodeShadows.set(nodeId, []);
                }
                nodeShadows.get(nodeId).push(color);

            } catch (error) {
                console.error('Error al actualizar sombras del nodo:', error);
            }
        }

        // Asegurarse de que nodeShadows esté definido globalmente
        if (typeof nodeShadows === 'undefined') {
            let nodeShadows = new Map();
        }

        // Añadir estilo para la animación de fadeOut
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeOut {
                0% { opacity: 1; }
                70% { opacity: 1; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // Añadir función para actualizar el YAML con las relaciones actuales
        function updateYamlWithRelations() {
            const yamlInput = document.getElementById('yamlInput');
            const network = document.getElementById('mynetwork')._network;
            
            try {
                // Obtener el YAML actual y convertirlo a JSON
                const currentYaml = yamlInput.value;
                const jsonData = jsyaml.load(currentYaml);
                
                // Obtener todas las relaciones del grafo
                const edges = network.body.data.edges.get();
                const customRelations = edges
                    .filter(edge => ['Inversa', 'Transitiva', 'Simétrica', 'Funcional', 'Inversamente Funcional']
                        .includes(edge.label))
                    .map(edge => ({
                        type: edge.label,
                        from: edge.from,
                        to: edge.to
                    }));
                
                // Actualizar el JSON con las nuevas relaciones
                if (customRelations.length > 0) {
                    jsonData.relationships = customRelations;
                } else {
                    delete jsonData.relationships;
                }
                
                // Convertir de vuelta a YAML y actualizar el textarea
                const updatedYaml = jsyaml.dump(jsonData);
                yamlInput.value = updatedYaml;
                
                // Actualizar también la visualización JSON
                updateOutputFormat();
            } catch (error) {
                console.error('Error updating YAML with relations:', error);
            }
        }

        // Modificar el manejador de eliminación de relaciones
        function handleRelationDelete(edgeId) {
            if (confirm('¿Deseas eliminar esta relación?')) {
                network.body.data.edges.remove(edgeId);
                
                // Después de eliminar la relación, actualizar el YAML
                updateYamlWithRelations();
                
                // Actualizar la visualización y activar autoguardado
                updateOutputFormat();
                triggerAutoSave('eliminación de relación');
            }
        }
    </script>
</body>
</html> 